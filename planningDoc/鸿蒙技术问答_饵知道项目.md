# 鸿蒙（HarmonyOS）研发技术问答 - 饵知道项目

> 基于「饵知道」钓鱼助手App的实际开发经验，整理30个有深度的技术问答

---

## 一、ArkTS 语言与声明式UI

### Q1: @State、@Prop、@Link 装饰器

**问题**：在ArkTS开发中，@State、@Prop、@Link这三个状态装饰器分别是什么作用？它们之间有什么区别？在实际项目中你是如何选择使用的？

**答：** 这三个装饰器用于组件状态管理，区别如下：

- **@State**：组件内部状态，变化触发UI刷新。适用于组件私有数据。
- **@Prop**：父组件单向传递给子组件，子组件修改不影响父组件。适用于只读配置。
- **@Link**：父子组件双向绑定，任一方修改都会同步。适用于表单输入等场景。

**项目实例**：在 `AddRecordPage` 中使用 `@State` 管理表单状态：
```typescript
@State selectedFishList: string[] = [];
@State weight: string = '';
@State isSaving: boolean = false;
@State hasSaved: boolean = false;  // 防止重复保存
```

---

### Q2: 组件间跨层级通信

**问题**：当组件嵌套层级很深时，如果需要在祖先组件和深层后代组件之间传递数据，你会怎么处理？逐层传递@Prop太麻烦了，有没有更好的方案？

**答：** HarmonyOS 提供多种方案：

1. **@Provide/@Consume**：祖先组件提供，后代组件消费，无需逐层传递
2. **EventHub**：应用级事件总线
3. **AppStorage/LocalStorage**：全局/页面级状态存储

**项目实例**：使用单例服务实现全局状态共享：
```typescript
// LocationService 单例模式
export class LocationService {
  private static instance: LocationService;
  static currentLocation: LocationInfo = { latitude: 30.5928, longitude: 114.3055 };
  
  static getInstance(): LocationService {
    if (!LocationService.instance) {
      LocationService.instance = new LocationService();
    }
    return LocationService.instance;
  }
}
```

---

### Q3: @Builder 和 @BuilderParam

**问题**：我看到ArkTS里有@Builder装饰器，它和普通的@Component有什么区别？@BuilderParam又是干什么用的？能举个实际使用场景吗？

**答：**

- **@Builder**：定义可复用的UI片段，类似函数式组件，比@Component更轻量
- **@BuilderParam**：允许父组件向子组件传递UI片段（类似Vue的slot插槽）

**项目实例**：`VictorySharePage` 中使用 @Builder 构建预览卡片：
```typescript
@Builder
PreviewCard() {
  Column() {
    Text('预览效果')
    // 分享卡片内容...
  }
}

@Builder
BaitRecommendDialog() {
  Stack() {
    // 弹窗遮罩和内容...
  }
}
```

---

## 二、地图服务（Map Kit）

### Q4: 地图初始化失败处理

**问题**：你在项目中使用了华为地图服务，地图加载失败是很常见的问题。你遇到过哪些地图初始化失败的情况？是怎么排查和解决的？

**答：** 常见错误码及解决方案：

| 错误码 | 原因 | 解决方案 |
|--------|------|----------|
| 1002600003 | 身份校验失败 | 检查AGC地图服务开通状态、更新签名证书 |
| 1002600001 | 系统内部错误 | 关闭网络代理、切换网络 |
| 201 | 网络权限被拒绝 | 补全 GET_NETWORK_INFO 权限 |

**项目实例**：MapPage 中的错误处理：
```typescript
this.mapCallback = async (err, mapController) => {
  if (err) {
    const errCode = err.code;
    if (errCode === 1002600003) {
      hint = '身份校验失败，请检查AGC地图服务是否开通';
    } else if (errCode === 1002600001) {
      hint = '系统内部错误，请关闭网络代理';
    }
    this.currentLocation = `地图加载失败(${errCode}): ${hint}`;
    return;
  }
};
```

---

### Q5: 逆地理编码实现

**问题**：用户点击地图上的某个位置，你需要显示这个位置的地名而不是经纬度坐标。这个功能是怎么实现的？有没有遇到什么坑？

**答：** 使用 `site.reverseGeocode` API 实现逆地理编码：

```typescript
async onMapClick(position: mapCommon.LatLng): Promise<void> {
  const params: site.ReverseGeocodeParams = {
    location: {
      latitude: position.latitude,
      longitude: position.longitude
    },
    language: 'zh',
    radius: 50  // 搜索半径，影响结果精度
  };
  
  const result = await site.reverseGeocode(params);
  if (result?.addressComponent) {
    const addr = result.addressComponent;
    // 拼接地址：区 + 街道
    this.clickedLocationName = [addr.adminLevel3, addr.adminLevel4]
      .filter(Boolean).join('');
  }
}
```

**踩坑经验**：radius参数设置太大会返回较粗略的地址，设置50米左右能获取更精确的街道级地址。

---

### Q6: 地图标记管理

**问题**：你的钓点地图上有很多标记点，这些标记是怎么添加的？用户点击标记时怎么知道点的是哪个钓点？标记太多时性能怎么优化？

**答：**

```typescript
// 添加标记
const markerOptions: mapCommon.MarkerOptions = {
  position: { latitude: spot.latitude, longitude: spot.longitude },
  title: `${icon} ${spot.name}`,
  snippet: `${WaterTypeNames[spot.waterType]} · ${distance}`,
  clickable: true
};
const marker = await this.mapController.addMarker(markerOptions);
this.spotMarkers.push(marker);  // 保存引用，便于后续管理

// 监听点击 - 通过坐标匹配找到对应钓点
eventManager.on('markerClick', (clickedMarker: map.Marker) => {
  const clickedSpot = this.fishingSpots.find(s =>
    Math.abs(s.latitude - clickedMarker.getPosition().latitude) < 0.0001 &&
    Math.abs(s.longitude - clickedMarker.getPosition().longitude) < 0.0001
  );
  if (clickedSpot) this.onSpotClick(clickedSpot);
});
```

**性能优化**：标记过多时可使用聚合（Cluster），或根据缩放级别动态显示/隐藏标记。

---

## 三、定位服务（Location Kit）

### Q7: 定位权限与降级处理

**问题**：定位功能涉及用户隐私，需要申请权限。如果用户拒绝授权怎么办？定位失败了整个地图功能就不能用了吗？你是怎么处理这种情况的？

**答：** 采用渐进式降级策略，确保功能可用：

```typescript
static async refreshLocation(): Promise<LocationInfo> {
  try {
    // 1. 检查权限
    const hasPermission = await this.checkAndRequestPermission();
    if (!hasPermission) {
      this.currentLocation.errorMsg = '定位权限未授权';
      return this.currentLocation;  // 返回默认位置（武汉）
    }
    
    // 2. 获取位置
    const location = await geoLocationManager.getCurrentLocation(request);
    this.currentLocation = { 
      latitude: location.latitude, 
      longitude: location.longitude,
      isValid: true 
    };
  } catch (error) {
    // 3. 失败时使用默认位置
    this.currentLocation.errorMsg = this.getErrorMessage(error.code);
    // 保持默认坐标不变，地图仍可正常显示
  }
  return this.currentLocation;
}
```

**设计思路**：即使定位失败，也显示默认位置的地图，用户仍可手动浏览和搜索。

---

### Q8: 定位精度与功耗平衡

**问题**：定位有高精度和低功耗两种模式，你在项目中是怎么选择的？不同场景下有没有不同的策略？

**答：** 通过 `SingleLocationRequest` 配置定位策略：

```typescript
const request: geoLocationManager.SingleLocationRequest = {
  locatingPriority: geoLocationManager.LocatingPriority.PRIORITY_LOCATING_SPEED,
  locatingTimeoutMs: 10000  // 10秒超时
};
```

**策略选择**：
- `PRIORITY_ACCURACY`：高精度，适合导航、精确定位场景
- `PRIORITY_LOCATING_SPEED`：快速定位，适合本项目（只需大致位置搜索钓点）
- `PRIORITY_LOW_POWER`：低功耗，适合后台持续定位

本项目选择快速定位，因为钓点搜索范围是5公里，不需要米级精度。

---

## 四、数据持久化

### Q9: 存储方案选择

**问题**：HarmonyOS提供了Preferences和关系型数据库两种持久化方案，你在项目中是怎么选择的？什么情况用Preferences，什么情况用数据库？

**答：**

| 特性 | Preferences | 关系型数据库 |
|------|-------------|--------------|
| 数据量 | 小量键值对（<1MB） | 大量结构化数据 |
| 查询 | 简单读写 | 复杂SQL查询、索引 |
| 性能 | 快速，内存缓存 | 需要磁盘IO |
| 场景 | 配置、缓存、小列表 | 大量记录、复杂查询 |

**项目选择**：本项目数据量不大（几百条记录），使用Preferences + JSON序列化，简单高效。

```typescript
async saveLastSettings(): Promise<void> {
  const prefs = await preferences.getPreferences(this.context, 'fishing_settings');
  await prefs.put('last_location', this.location);
  await prefs.put('last_weather', this.weather);
  await prefs.flush();
}
```

---

### Q10: JSON序列化存储

**问题**：你说用Preferences存储记录列表，但Preferences只能存字符串，复杂对象怎么存？取出来怎么还原成对象？有没有类型安全问题？

**答：** 使用JSON序列化/反序列化：

```typescript
// 存储
async addRecord(record: FishingRecord): Promise<void> {
  const records = await this.getAllRecords();
  record.id = Date.now().toString();
  records.unshift(record);
  
  const prefs = await preferences.getPreferences(this.context, STORE_NAME);
  await prefs.put(RECORDS_KEY, JSON.stringify(records));
  await prefs.flush();
}

// 读取
async getAllRecords(): Promise<FishingRecord[]> {
  const prefs = await preferences.getPreferences(this.context, STORE_NAME);
  const data = await prefs.get(RECORDS_KEY, '[]') as string;
  return JSON.parse(data) as FishingRecord[];  // 类型断言
}
```

**类型安全**：通过TypeScript类型断言确保类型，但JSON.parse返回的是普通对象，没有类方法。如需方法，需要手动实例化。

---

## 五、媒体与文件处理

### Q11: SaveButton安全控件

**问题**：保存图片到相册需要写入权限，但我看你代码里没有申请WRITE_IMAGEVIDEO权限，图片是怎么保存成功的？

**答：** 使用系统安全控件 `SaveButton`，点击后自动获取临时写入权限，无需预先申请：

```typescript
SaveButton()
  .onClick(async (event: ClickEvent, result: SaveButtonOnClickResult) => {
    if (result === SaveButtonOnClickResult.SUCCESS) {
      // 点击成功后5秒内必须完成保存操作
      const helper = photoAccessHelper.getPhotoAccessHelper(context);
      const uri = await helper.createAsset(photoAccessHelper.PhotoType.IMAGE, 'jpg');
      const file = await fs.open(uri, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
      
      // 截图并保存
      const pixelMap = await componentSnapshot.get('victoryCard');
      const imagePacker = image.createImagePacker();
      await imagePacker.packToFile(pixelMap, file.fd, { format: 'image/jpeg', quality: 95 });
    }
  })
```

**优势**：用户体验更好，不会弹出权限申请弹窗；安全性更高，权限仅在用户主动点击时临时授予。

---

### Q12: 组件截图功能

**问题**：你的分享图功能是把页面上的卡片截图保存，这个截图是怎么实现的？能截取任意组件吗？有什么限制？

**答：** 使用 `componentSnapshot.get()` API：

```typescript
// 1. 给目标组件设置id
Column() { /* 卡片内容 */ }
  .id('victoryCard')

// 2. 截图
const snapshotOptions: componentSnapshot.SnapshotOptions = {
  waitUntilRenderFinished: true  // 等待渲染完成
};
const pixelMap = await componentSnapshot.get('victoryCard', snapshotOptions);

// 3. 保存为图片
const imagePacker = image.createImagePacker();
await imagePacker.packToFile(pixelMap, file.fd, { format: 'image/jpeg', quality: 95 });
```

**限制**：
- 组件必须设置id属性
- 截图是异步操作
- 组件必须在屏幕上可见（不能截取隐藏组件）
- 截图分辨率受设备屏幕影响

---

### Q13: 图片选择器

**问题**：用户选择自定义背景图时，你是怎么调起系统相册的？选择后怎么获取图片路径？

**答：** 使用 `PhotoViewPicker`：

```typescript
private async selectCustomBgImage(): Promise<void> {
  try {
    const photoPicker = new photoAccessHelper.PhotoViewPicker();
    const result = await photoPicker.select({
      MIMEType: photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE,  // 只选图片
      maxSelectNumber: 1  // 最多选1张
    });
    
    if (result.photoUris?.length > 0) {
      this.customBgImage = result.photoUris[0];  // 获取图片URI
      this.selectedStyle = this.cardStyles.length - 1;  // 自动切换到自定义样式
    }
  } catch (error) {
    console.error('选择背景图失败:', JSON.stringify(error));
  }
}
```

**返回的URI格式**：`file://media/Photo/xxx`，可直接用于Image组件显示。

---

## 六、语音识别（Speech Kit）

### Q14: 语音输入集成

**问题**：你的添加记录页面有语音输入功能，是怎么实现的？语音识别是在线还是离线？识别准确率怎么样？

**答：** 使用 Speech Kit 的语音识别引擎：

```typescript
// 初始化
private async initAsrEngine(): Promise<void> {
  const extraParams: Record<string, Object> = { 
    vadBegin: 2000,  // 开始说话检测时间
    vadEnd: 3000     // 停止说话检测时间
  };
  
  this.asrEngine = await speechRecognizer.createEngine({
    language: 'zh-CN',
    online: 1,  // 1=在线识别，0=离线
    extraParams: extraParams
  });
  
  // 设置回调
  this.asrEngine.setListener({
    onResult: (result: string) => {
      this.recordingText = result;  // 实时显示识别结果
    },
    onComplete: (finalResult: string) => {
      this.notes = finalResult;
      this.isRecording = false;
    },
    onError: (errorCode: number) => {
      console.error('语音识别错误:', errorCode);
    }
  });
}
```

**在线vs离线**：在线识别准确率更高，但需要网络；离线识别速度快但词汇量有限。本项目使用在线识别。

---

## 七、网络与缓存

### Q15: 天气服务缓存策略

**问题**：天气数据不需要实时更新，频繁请求API既浪费流量又影响性能。你是怎么设计缓存策略的？

**答：** 采用内存缓存 + 过期时间策略：

```typescript
let cachedWeather: WeatherData | null = null;
let cacheTime: number = 0;
const CACHE_DURATION = 30 * 60 * 1000; // 30分钟缓存

export function getCachedWeather(): WeatherData {
  // 检查缓存是否有效
  if (cachedWeather && Date.now() - cacheTime < CACHE_DURATION) {
    return { ...cachedWeather, isValid: true };
  }
  return { weatherText: '', isValid: false };
}

export async function fetchWeather(lat: number, lng: number): Promise<WeatherData> {
  // 优先使用缓存
  const cached = getCachedWeather();
  if (cached.isValid) return cached;
  
  // 请求新数据
  const response = await http.createHttp().request(url);
  cachedWeather = parseWeatherData(response);
  cacheTime = Date.now();
  return cachedWeather;
}
```

**设计考虑**：天气30分钟内变化不大，缓存30分钟既保证数据相对新鲜，又减少API调用。

---

## 八、路由与导航

### Q16: 统一路由管理

**问题**：项目有很多页面，页面跳转代码散落各处不好维护。你是怎么管理路由的？有没有封装？

**答：** 封装统一的Router工具类：

```typescript
// Router.ets
export type RouteParams = Record<string, Object>;

export class Router {
  static push(url: string, params?: RouteParams): void {
    router.pushUrl({ url, params });
  }
  
  static replace(url: string, params?: RouteParams): void {
    router.replaceUrl({ url, params });
  }
  
  static back(): void {
    router.back();
  }
  
  static getParams(): RouteParams | undefined {
    return router.getParams() as RouteParams;
  }
}

// 使用示例
Router.push('pages/VictorySharePage', { record: fishingRecord });
Router.back();
```

**好处**：统一管理、便于扩展（如添加路由拦截、埋点）、代码更简洁。

---

### Q17: 页面间传递复杂对象

**问题**：页面跳转时需要传递一个完整的记录对象，包含很多字段。这种复杂对象怎么传递？接收方怎么获取？

**答：**

```typescript
// 发送方 - 将对象放入params
const params: Record<string, FishingRecord> = { 'record': record };
Router.push('pages/VictorySharePage', params as RouteParams);

// 接收方 - 在aboutToAppear中获取
aboutToAppear(): void {
  const params = Router.getParams() as Record<string, Object>;
  if (params?.record) {
    this.record = params.record as FishingRecord;
    // 初始化其他状态...
    if (this.record.photos?.length > 0) {
      this.selectedPhoto = this.record.photos[0];
    }
  }
}
```

**注意**：传递的是对象引用，如果需要独立副本应使用深拷贝。

---

## 九、性能优化

### Q18: 防止重复提交

**问题**：用户快速点击保存按钮可能导致重复提交，你是怎么防止的？只禁用按钮够吗？

**答：** 采用多重防护策略：

```typescript
@State isSaving: boolean = false;  // 保存中状态
@State hasSaved: boolean = false;  // 已保存标记

private saveRecord(): void {
  // 1. 方法内双重检查
  if (this.isSaving || this.hasSaved) return;
  
  this.isSaving = true;
  
  fishingRecordService.addRecord(record).then(() => {
    this.isSaving = false;
    this.hasSaved = true;  // 2. 保存成功后永久标记
    this.showVictoryDialog(record);
  }).catch(() => {
    this.isSaving = false;  // 失败时允许重试
  });
}

// 3. UI层禁用 + 视觉反馈
Button('保存')
  .enabled(!this.isSaving && !this.hasSaved)
  .opacity(this.hasSaved ? 0.5 : 1)
```

**为什么需要hasSaved**：用户从分享页返回后，isSaving已经是false，如果没有hasSaved，按钮又可以点击了。

---

### Q19: ForEach的keyGenerator

**问题**：ForEach循环渲染列表时，第三个参数keyGenerator是干什么的？不写会怎样？用index做key有什么问题？

**答：** keyGenerator用于唯一标识列表项，影响：

1. **渲染性能**：正确的key让框架知道哪些项变化了，避免全量重渲染
2. **状态保持**：key变化会导致组件销毁重建，状态丢失
3. **动画效果**：列表增删动画依赖key来识别元素

```typescript
// ❌ 错误：使用index作为key
// 问题：删除第一项后，所有项的index都变了，导致全部重渲染
ForEach(this.list, (item, index) => { ... }, (_, index) => `${index}`)

// ✅ 正确：使用唯一标识
ForEach(this.fishingSpots, (spot: FishingSpot) => {
  SpotCard({ spot })
}, (spot: FishingSpot) => spot.id)
```

**最佳实践**：使用数据的唯一ID作为key，没有ID时可用内容hash。

---

### Q20: LazyForEach懒加载

**问题**：如果列表有几千条数据，ForEach一次性渲染会很卡。HarmonyOS有没有类似RecyclerView的懒加载方案？

**答：** 使用 `LazyForEach` 实现按需渲染：

| 特性 | ForEach | LazyForEach |
|------|---------|-------------|
| 渲染时机 | 一次性全部渲染 | 滚动到可视区域才渲染 |
| 内存占用 | 高（大列表） | 低，只保留可见项 |
| 适用场景 | 小列表（<100项） | 大列表、无限滚动 |
| 数据源 | 普通数组 | 需实现IDataSource接口 |

```typescript
// 实现数据源接口
class SpotDataSource implements IDataSource {
  private spots: FishingSpot[] = [];
  
  totalCount(): number { return this.spots.length; }
  getData(index: number): FishingSpot { return this.spots[index]; }
  registerDataChangeListener(listener: DataChangeListener): void { /* ... */ }
  unregisterDataChangeListener(listener: DataChangeListener): void { /* ... */ }
}

// 使用
LazyForEach(this.dataSource, (spot: FishingSpot) => {
  SpotCard({ spot })
}, (spot: FishingSpot) => spot.id)
```

---

## 十、UI组件与交互

### Q21: 自适应图片显示

**问题**：用户上传的图片尺寸各不相同，有横图有竖图。怎么让图片在固定区域内完整显示且不变形？

**答：** 使用 `fitOriginalSize` 和 `objectFit` 组合：

```typescript
Image(this.selectedPhoto)
  .width('100%')
  .fitOriginalSize(true)  // 保持原始宽高比
  .objectFit(ImageFit.Contain)  // 完整显示，不裁剪
  .borderRadius(10)
```

**objectFit选项对比**：
- `Cover`：填充容器，超出部分裁剪（适合头像、封面）
- `Contain`：完整显示，可能留白（适合预览、详情）
- `Fill`：拉伸填充，可能变形（一般不用）
- `ScaleDown`：缩小适应，不放大（适合小图展示）

---

### Q22: 半模态弹窗Sheet

**问题**：有些场景需要从底部弹出一个面板，但不是全屏遮挡，用户还能看到后面的内容。这种效果怎么实现？

**答：** 使用 `bindSheet` 绑定半模态面板：

```typescript
@State showSheet: boolean = false;

build() {
  Column() {
    Button('打开筛选').onClick(() => { this.showSheet = true })
  }
  .bindSheet($$this.showSheet, this.SheetContent(), {
    height: SheetSize.MEDIUM,  // 高度：LARGE/MEDIUM/FIT_CONTENT
    dragBar: true,             // 显示拖拽条
    showClose: true,           // 显示关闭按钮
    onDisappear: () => { this.showSheet = false }
  })
}

@Builder
SheetContent() {
  Column() {
    Text('筛选条件')
    // 筛选选项...
  }
  .padding(16)
}
```

**注意**：`$$this.showSheet` 是双向绑定语法，Sheet关闭时自动更新状态。

---

### Q23: 自定义遮罩弹窗

**问题**：系统弹窗样式有限，我想自定义一个带遮罩的弹窗，点击遮罩关闭。怎么实现？

**答：** 使用Stack布局叠加遮罩和内容：

```typescript
@State showDialog: boolean = false;

build() {
  Stack() {
    // 主页面内容
    Column() { /* ... */ }
    
    // 弹窗（条件渲染）
    if (this.showDialog) {
      this.CustomDialog()
    }
  }
}

@Builder
CustomDialog() {
  Stack() {
    // 遮罩层 - 点击关闭
    Column()
      .width('100%')
      .height('100%')
      .backgroundColor('rgba(0,0,0,0.5)')
      .onClick(() => { this.showDialog = false })
    
    // 弹窗内容 - 阻止点击穿透
    Column() {
      Text('弹窗标题')
      // 内容...
      Button('确定').onClick(() => { this.showDialog = false })
    }
    .width('80%')
    .padding(20)
    .backgroundColor(Color.White)
    .borderRadius(16)
  }
  .width('100%')
  .height('100%')
  .position({ x: 0, y: 0 })  // 覆盖整个页面
}
```

---

## 十一、主题与样式

### Q24: 统一主题色管理

**问题**：项目有统一的品牌色，很多地方都要用到。如果以后要换主题色，一个个改太麻烦了。你是怎么管理主题色的？

**答：** 封装主题常量类：

```typescript
// ThemeColors.ets
export class ThemeColors {
  // 品牌色
  static readonly PRIMARY = '#E8A849';
  static readonly PRIMARY_LIGHT = 'rgba(232,168,73,0.15)';
  static readonly PRIMARY_DARK = '#D4942F';
  
  // 背景色
  static readonly BG_PRIMARY = '#FAFAFA';
  static readonly BG_SECONDARY = '#FFFFFF';
  static readonly BG_CARD = '#FFFFFF';
  
  // 文字色
  static readonly TEXT_PRIMARY = '#1A1A1A';
  static readonly TEXT_SECONDARY = '#666666';
  static readonly TEXT_MUTED = '#999999';
  
  // 状态色
  static readonly SUCCESS = '#52C41A';
  static readonly ERROR = '#FF4D4F';
  static readonly WARNING = '#FAAD14';
}

// 使用
Text('标题')
  .fontColor(ThemeColors.TEXT_PRIMARY)
Button('确定')
  .backgroundColor(ThemeColors.PRIMARY)
```

**好处**：换主题只需修改一个文件，全局生效。

---

### Q25: 渐变背景实现

**问题**：分享卡片有渐变背景效果，还能自定义背景图。这两种背景是怎么实现的？能同时存在吗？

**答：**

```typescript
// 渐变背景
Column()
  .linearGradient({
    direction: GradientDirection.RightBottom,  // 渐变方向
    colors: [
      ['rgba(232,168,73,0.8)', 0],   // 起始色
      ['rgba(255,200,100,0.3)', 1]   // 结束色
    ]
  })

// 背景图
Column()
  .backgroundImage(this.customBgImage)
  .backgroundImageSize(ImageSize.Cover)

// 同时使用：背景图 + 半透明渐变遮罩
Column()
  .backgroundImage(this.customBgImage)
  .backgroundImageSize(ImageSize.Cover)
  .linearGradient({
    colors: [['rgba(0,0,0,0.5)', 0], ['rgba(0,0,0,0.3)', 1]]
  })
```

**项目实现**：根据是否选择自定义背景图，动态切换背景样式。

---

## 十二、错误处理与调试

### Q26: 类型安全的错误处理

**问题**：ArkTS是强类型语言，catch到的error是unknown类型，怎么安全地获取错误码和错误信息？

**答：** 使用类型断言：

```typescript
try {
  const result = await someAsyncOperation();
} catch (error) {
  // 类型断言为BusinessError
  const err = error as BusinessError;
  console.error(`错误码: ${err.code}, 信息: ${err.message}`);
  
  // 根据错误码分类处理
  switch (err.code) {
    case 201:
      promptAction.showToast({ message: '权限被拒绝' });
      break;
    case 401:
      promptAction.showToast({ message: '参数错误' });
      break;
    case 1002600003:
      promptAction.showToast({ message: 'AGC服务校验失败' });
      break;
    default:
      promptAction.showToast({ message: `操作失败: ${err.message}` });
  }
}
```

---

### Q27: 有效的日志输出

**问题**：调试时需要看日志，但日志太多又找不到关键信息。你是怎么组织日志的？有什么技巧？

**答：** 采用TAG + 分级 + 结构化日志：

```typescript
private TAG = 'MapPage';  // 每个文件定义TAG，便于过滤

// 分级日志
console.debug(this.TAG, '调试信息');      // 开发时用
console.info(this.TAG, '✅ 操作成功');    // 正常流程
console.warn(this.TAG, '⚠️ 警告信息');   // 潜在问题
console.error(this.TAG, '❌ 错误信息');   // 错误

// 结构化日志 - 关键流程加分隔符
console.info(this.TAG, `========== 地图初始化 ==========`);
console.info(this.TAG, `定位: lat=${lat}, lng=${lng}`);
console.info(this.TAG, `状态: valid=${isValid}, error=${errorMsg || '无'}`);
console.info(this.TAG, `========== 初始化完成 ==========`);

// 错误日志包含上下文
console.error(this.TAG, `❌ 地图初始化失败!`);
console.error(this.TAG, `错误码: ${errCode}`);
console.error(this.TAG, `错误信息: ${errMsg}`);
console.error(this.TAG, `提示: ${hint}`);
```

**调试技巧**：在HiLog中按TAG过滤，快速定位问题。

---

## 十三、架构设计

### Q28: 服务层单例模式

**问题**：项目中有很多Service类，比如LocationService、RecordService。这些Service是怎么设计的？为什么要用单例？

**答：** 两种单例实现方式：

```typescript
// 方式1：类静态方法（适合有状态的服务）
export class LocationService {
  private static instance: LocationService;
  static currentLocation: LocationInfo = { /* 默认值 */ };
  
  private constructor() {}  // 私有构造函数
  
  static getInstance(): LocationService {
    if (!LocationService.instance) {
      LocationService.instance = new LocationService();
    }
    return LocationService.instance;
  }
  
  async refreshLocation(): Promise<LocationInfo> { /* ... */ }
}

// 方式2：导出实例（更简洁，适合无状态服务）
class FishingRecordServiceImpl {
  async addRecord(record: FishingRecord): Promise<void> { /* ... */ }
  async getAllRecords(): Promise<FishingRecord[]> { /* ... */ }
}
export const fishingRecordService = new FishingRecordServiceImpl();
```

**为什么用单例**：
- 全局共享状态（如当前位置）
- 避免重复初始化（如数据库连接）
- 统一管理资源

---

### Q29: 配方推荐引擎设计

**问题**：你的智能配方推荐功能挺复杂的，要考虑鱼种、天气、季节等多个因素。这个引擎是怎么设计的？怎么保证可扩展性？

**答：** 采用策略模式 + 模块化设计：

```typescript
// 1. 上下文分析器 - 分析环境因素
class ContextAnalyzer {
  analyze(params: MatchParams): ContextResult {
    return {
      season: this.getSeason(params.date),
      timeSlot: this.getTimeSlot(params.time),
      weatherFactor: this.analyzeWeather(params.weather),
      waterCondition: this.analyzeWater(params.waterType)
    };
  }
}

// 2. 配料池 - 根据上下文筛选配料
class IngredientPool {
  getIngredients(context: ContextResult, targetFish: string[]): Ingredient[] {
    return this.allIngredients
      .filter(i => this.matchSeason(i, context.season))
      .filter(i => this.matchFish(i, targetFish))
      .sort((a, b) => this.calculateScore(b, context) - this.calculateScore(a, context));
  }
}

// 3. 变体管理器 - 生成配方变体
class VariantManager {
  generateVariants(baseRecipe: Recipe, context: ContextResult): Recipe[] {
    // 根据天气、时间等生成不同变体
  }
}

// 4. 引擎组合
class SmartRecipeEngine {
  private contextAnalyzer = new ContextAnalyzer();
  private ingredientPool = new IngredientPool();
  private variantManager = new VariantManager();
  
  generate(params: MatchParams): Recipe[] {
    const context = this.contextAnalyzer.analyze(params);
    const ingredients = this.ingredientPool.getIngredients(context, params.targetFish);
    const baseRecipe = this.buildRecipe(ingredients);
    return this.variantManager.generateVariants(baseRecipe, context);
  }
}
```

**可扩展性**：新增因素只需添加新的分析器模块，不影响现有逻辑。

---

### Q30: 项目代码结构

**问题**：一个完整的HarmonyOS项目，代码应该怎么组织？有没有推荐的目录结构？

**答：** 推荐分层架构：

```
entry/src/main/ets/
├── pages/              # 页面组件（路由入口）
│   ├── HomePage.ets
│   ├── MapPage.ets
│   ├── AddRecordPage.ets
│   └── VictorySharePage.ets
│
├── components/         # 可复用UI组件
│   ├── RecordCard.ets
│   ├── FilterSheet.ets
│   └── EmptyState.ets
│
├── services/           # 业务服务层
│   ├── LocationService.ets
│   ├── WeatherService.ets
│   ├── FishingRecordService.ets
│   └── engine/         # 核心算法引擎
│       ├── SmartRecipeEngine.ets
│       ├── ContextAnalyzer.ets
│       └── IngredientPool.ets
│
├── data/               # 静态数据、配置
│   ├── FishData.ets
│   ├── RecipeRules.ets
│   └── IngredientDatabase.ets
│
├── common/             # 公共类型定义
│   └── types/
│       ├── UserTypes.ets
│       └── RecipeTypes.ets
│
├── theme/              # 主题样式常量
│   ├── ThemeColors.ets
│   └── ThemeConstants.ets
│
├── router/             # 路由管理
│   └── Router.ets
│
└── entryability/       # 应用入口
    └── EntryAbility.ets
```

**分层原则**：
- **pages**：只负责UI展示和用户交互
- **services**：处理业务逻辑，与UI解耦
- **data**：静态数据独立管理，便于维护
- **common**：类型定义集中，避免循环依赖

---

## 总结

本文档基于「饵知道」钓鱼助手App的实际开发经验，涵盖了：

- **UI开发**：声明式UI、状态管理、组件复用
- **系统能力**：地图、定位、语音、媒体
- **数据处理**：持久化、缓存、序列化
- **架构设计**：服务层、路由、主题
- **性能优化**：防重复提交、懒加载、缓存策略
- **错误处理**：类型安全、日志调试

每个问题都包含完整的问题描述和详细解答，可作为鸿蒙开发面试准备或技术分享的参考材料。
