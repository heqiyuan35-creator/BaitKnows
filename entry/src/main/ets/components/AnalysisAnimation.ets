/**
 * åˆ†æè¿‡ç¨‹åŠ¨ç”»ç»„ä»¶
 * å±•ç¤ºç²¾ç¡®åŒ¹é…çš„5æ­¥åˆ†æè¿‡ç¨‹
 */
import { ThemeColors } from '../theme/ThemeColors';

interface AnalysisStepData {
  step: number;
  title: string;
  description: string;
  icon: string;
}

const ANALYSIS_STEPS: AnalysisStepData[] = [
  { step: 1, title: 'å‚æ•°è§£æ', description: 'è§£æé’“å†µå‚æ•°', icon: 'ğŸ“Š' },
  { step: 2, title: 'ä¹ æ€§åŒ¹é…', description: 'åŒ¹é…é±¼ç§ä¹ æ€§', icon: 'ğŸŸ' },
  { step: 3, title: 'åŸæ–™ç­›é€‰', description: 'æ™ºèƒ½ç­›é€‰åŸæ–™', icon: 'ğŸ£' },
  { step: 4, title: 'é…æ¯”ä¼˜åŒ–', description: 'è®¡ç®—æœ€ä¼˜é…æ¯”', icon: 'âš–ï¸' },
  { step: 5, title: 'æ–¹æ¡ˆç”Ÿæˆ', description: 'ç”Ÿæˆæœ€ä¼˜æ–¹æ¡ˆ', icon: 'âœ¨' }
];

@Component
export struct AnalysisAnimation {
  @Prop currentStep: number = 0;
  @Prop fishName: string = 'ç›®æ ‡é±¼';

  build() {
    Column({ space: 24 }) {
      // æ ‡é¢˜
      Column({ space: 8 }) {
        Text('æ­£åœ¨ç²¾ç¡®åˆ†æ')
          .fontSize(22)
          .fontWeight(FontWeight.Bold)
          .fontColor('#1A1A1A')

        Text(`ä¸ºæ‚¨åŒ¹é…æœ€é€‚åˆ${this.fishName}çš„é…æ–¹`)
          .fontSize(14)
          .fontColor('#666')
      }

      // è¿›åº¦æŒ‡ç¤ºå™¨
      Row({ space: 8 }) {
        ForEach([1, 2, 3, 4, 5], (step: number) => {
          Row()
            .width(this.currentStep >= step ? 24 : 8)
            .height(8)
            .borderRadius(4)
            .backgroundColor(this.currentStep >= step ? ThemeColors.PRIMARY : '#E0E0E0')
            .animation({
              duration: 300,
              curve: Curve.EaseOut
            })
        })
      }
      .margin({ top: 8, bottom: 16 })

      // æ­¥éª¤åˆ—è¡¨
      Column({ space: 12 }) {
        ForEach(ANALYSIS_STEPS, (stepData: AnalysisStepData) => {
          this.StepItem(stepData)
        })
      }
      .width('100%')
      .padding(20)
      .backgroundColor(Color.White)
      .borderRadius(16)
      .shadow({ radius: 10, color: 'rgba(0,0,0,0.05)', offsetY: 2 })
    }
    .width('100%')
    .padding(20)
  }

  @Builder
  StepItem(stepData: AnalysisStepData) {
    Row({ space: 14 }) {
      // æ­¥éª¤å›¾æ ‡
      Stack() {
        if (this.currentStep > stepData.step) {
          // å·²å®Œæˆ
          Row() {
            Text('âœ“').fontSize(14).fontColor(Color.White)
          }
          .width(36)
          .height(36)
          .borderRadius(18)
          .backgroundColor(ThemeColors.PRIMARY)
          .justifyContent(FlexAlign.Center)
        } else if (this.currentStep === stepData.step) {
          // è¿›è¡Œä¸­
          Row() {
            LoadingProgress()
              .width(20)
              .height(20)
              .color(Color.White)
          }
          .width(36)
          .height(36)
          .borderRadius(18)
          .backgroundColor(ThemeColors.PRIMARY)
          .justifyContent(FlexAlign.Center)
        } else {
          // æœªå¼€å§‹
          Row() {
            Text(stepData.icon).fontSize(16)
          }
          .width(36)
          .height(36)
          .borderRadius(18)
          .backgroundColor('#F5F5F5')
          .justifyContent(FlexAlign.Center)
        }
      }

      // æ­¥éª¤ä¿¡æ¯
      Column({ space: 4 }) {
        Text(stepData.title)
          .fontSize(15)
          .fontWeight(FontWeight.Medium)
          .fontColor(this.currentStep >= stepData.step ? '#1A1A1A' : '#999')

        Text(stepData.description)
          .fontSize(12)
          .fontColor('#999')
      }
      .alignItems(HorizontalAlign.Start)
      .layoutWeight(1)

      // çŠ¶æ€æ ‡ç­¾
      if (this.currentStep > stepData.step) {
        Text('å®Œæˆ')
          .fontSize(12)
          .fontColor(ThemeColors.PRIMARY)
          .padding({ left: 8, right: 8, top: 4, bottom: 4 })
          .backgroundColor('#FFF5E6')
          .borderRadius(10)
      } else if (this.currentStep === stepData.step) {
        Text('è¿›è¡Œä¸­')
          .fontSize(12)
          .fontColor(Color.White)
          .padding({ left: 8, right: 8, top: 4, bottom: 4 })
          .backgroundColor(ThemeColors.PRIMARY)
          .borderRadius(10)
      }
    }
    .width('100%')
    .padding({ top: 10, bottom: 10 })
    .opacity(this.currentStep >= stepData.step ? 1 : 0.5)
  }
}
