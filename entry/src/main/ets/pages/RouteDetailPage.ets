/**
 * è·¯çº¿è¯¦æƒ…é¡µ - æ˜¾ç¤ºåˆ°é’“ç‚¹çš„è·¯çº¿è§„åˆ’
 */
import { MapComponent, mapCommon, map, navi } from '@kit.MapKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
import { router } from '@kit.ArkUI';
import { ThemeColors } from '../theme/ThemeColors';
import { LocationService } from '../services/LocationService';
import { FishingSpotService } from '../services/FishingSpotService';
import { FishingSpot, WaterTypeNames, WaterTypeIcons } from '../data/FishingSpotData';

interface RouteParams {
  spotId: string;
}

interface RouteInfo {
  distance: number;
  duration: number;
  type: string;
}

@Entry
@Component
struct RouteDetailPage {
  private TAG = 'RouteDetailPage';
  private mapOptions?: mapCommon.MapOptions;
  private mapCallback?: AsyncCallback<map.MapComponentController>;
  private mapController?: map.MapComponentController;
  private currentPolyline?: map.MapPolyline;  // ä¿å­˜å½“å‰è·¯çº¿å¼•ç”¨

  @State spot: FishingSpot | null = null;
  @State isMapReady: boolean = false;
  @State isLoading: boolean = true;
  @State selectedRouteType: string = 'driving';
  @State routeInfo: RouteInfo | null = null;
  @State routeDistance: number = 0;
  @State routeDuration: number = 0;

  aboutToAppear(): void {
    const params = router.getParams() as RouteParams;
    if (params && params.spotId) {
      this.spot = FishingSpotService.cachedSpots.find(s => s.id === params.spotId) || null;
    }

    if (!this.spot) return;

    const userLocation = LocationService.currentLocation;
    const centerLat = (userLocation.latitude + this.spot.latitude) / 2;
    const centerLng = (userLocation.longitude + this.spot.longitude) / 2;

    this.mapOptions = {
      position: {
        target: { latitude: centerLat, longitude: centerLng },
        zoom: 13
      },
      scaleControlsEnabled: true,
      zoomControlsEnabled: true
    };

    this.mapCallback = async (err, mapController) => {
      if (!err) {
        this.mapController = mapController;
        this.isMapReady = true;

        const eventManager = this.mapController.getEventManager();
        eventManager.on('mapLoad', () => {
          this.addMarkers();
          this.calculateRoute();
        });
      }
    };
  }

  async addMarkers(): Promise<void> {
    if (!this.mapController || !this.spot) return;

    const userLocation = LocationService.currentLocation;

    await this.mapController.addMarker({
      position: { latitude: userLocation.latitude, longitude: userLocation.longitude },
      title: 'ğŸ“ æˆ‘çš„ä½ç½®',
      snippet: 'å‡ºå‘ç‚¹',
      clickable: true
    });

    await this.mapController.addMarker({
      position: { latitude: this.spot.latitude, longitude: this.spot.longitude },
      title: `ğŸ£ ${this.spot.name}`,
      snippet: 'ç›®çš„åœ°',
      clickable: true
    });
  }

  async calculateRoute(): Promise<void> {
    if (!this.spot) return;

    this.isLoading = true;
    const userLocation = LocationService.currentLocation;

    // æ¸…é™¤æ—§è·¯çº¿
    if (this.currentPolyline) {
      this.currentPolyline.remove();
      this.currentPolyline = undefined;
    }

    try {
      let result: navi.RouteResult;

      if (this.selectedRouteType === 'driving') {
        const params: navi.DrivingRouteParams = {
          origins: [{ latitude: userLocation.latitude, longitude: userLocation.longitude }],
          destination: { latitude: this.spot.latitude, longitude: this.spot.longitude },
          language: 'zh_CN'
        };
        result = await navi.getDrivingRoutes(params);
      } else if (this.selectedRouteType === 'walking') {
        const params: navi.RouteParams = {
          origins: [{ latitude: userLocation.latitude, longitude: userLocation.longitude }],
          destination: { latitude: this.spot.latitude, longitude: this.spot.longitude },
          language: 'zh_CN'
        };
        result = await navi.getWalkingRoutes(params);
      } else {
        const params: navi.RouteParams = {
          origins: [{ latitude: userLocation.latitude, longitude: userLocation.longitude }],
          destination: { latitude: this.spot.latitude, longitude: this.spot.longitude },
          language: 'zh_CN'
        };
        result = await navi.getCyclingRoutes(params);
      }

      // æ‰“å°å®Œæ•´ç»“æœæŸ¥çœ‹ç»“æ„
      console.info(this.TAG, `Route result: ${JSON.stringify(result)}`);

      // è§£æè·¯çº¿ç»“æœ
      if (result && result.routes && result.routes.length > 0) {
        const route = result.routes[0];
        console.info(this.TAG, `First route: ${JSON.stringify(route)}`);

        // ä»è·¯çº¿ä¸­æå–è·¯çº¿ç‚¹
        await this.parseRouteAndDraw(result);
      } else {
        console.warn(this.TAG, 'No routes found');
        await this.useEstimatedRoute();
      }
    } catch (error) {
      const err = error as BusinessError;
      console.error(this.TAG, `Route calculation failed: ${err.code}, ${err.message}`);
      await this.useEstimatedRoute();
    } finally {
      this.isLoading = false;
    }
  }

  // è§£æè·¯çº¿ç»“æœå¹¶ç»˜åˆ¶
  async parseRouteAndDraw(result: navi.RouteResult): Promise<void> {
    const routePoints: mapCommon.LatLng[] = [];

    try {
      const resultStr = JSON.stringify(result);

      // ä» polyline æ•°ç»„ä¸­æå–ç‚¹
      // ç»“æ„: routes[].steps[].roads[].polyline[{latitude, longitude}]
      const polylinePattern = /"polyline"\s*:\s*\[([\s\S]*?)\]/g;
      let polylineMatch: RegExpExecArray | null;

      while ((polylineMatch = polylinePattern.exec(resultStr)) !== null) {
        const polylineContent = polylineMatch[1];

        // ä»æ¯ä¸ª polyline ä¸­æå–ç»çº¬åº¦
        const pointPattern = /\{\s*"longitude"\s*:\s*([\d.]+)\s*,\s*"latitude"\s*:\s*([\d.]+)\s*\}/g;
        let pointMatch: RegExpExecArray | null;

        while ((pointMatch = pointPattern.exec(polylineContent)) !== null) {
          const lng = parseFloat(pointMatch[1]);
          const lat = parseFloat(pointMatch[2]);

          if (lat > 0 && lng > 0) {
            // é¿å…è¿ç»­é‡å¤ç‚¹
            const lastPoint = routePoints.length > 0 ? routePoints[routePoints.length - 1] : null;
            if (!lastPoint ||
              Math.abs(lastPoint.latitude - lat) > 0.000001 ||
              Math.abs(lastPoint.longitude - lng) > 0.000001) {
              routePoints.push({ latitude: lat, longitude: lng });
            }
          }
        }
      }

      console.info(this.TAG, `Extracted ${routePoints.length} route points`);

      // æå–æ€»è·ç¦»å’Œæ—¶é—´ï¼ˆä» roads ä¸­ç´¯åŠ ï¼‰
      let totalDistance = 0;
      let totalDuration = 0;

      const distancePattern = /"distance"\s*:\s*([\d.]+)/g;
      const durationPattern = /"duration"\s*:\s*(\d+)/g;

      let distMatch: RegExpExecArray | null;
      while ((distMatch = distancePattern.exec(resultStr)) !== null) {
        totalDistance += parseFloat(distMatch[1]);
      }

      let durMatch: RegExpExecArray | null;
      while ((durMatch = durationPattern.exec(resultStr)) !== null) {
        totalDuration += parseInt(durMatch[1]);
      }

      // è·ç¦»å¯èƒ½é‡å¤è®¡ç®—äº†ï¼Œå–åˆç†å€¼
      this.routeDistance = totalDistance > 0 ? Math.round(totalDistance / 2) : (this.spot?.distance || 0);
      this.routeDuration = totalDuration > 0 ? Math.round(totalDuration / 2) : this.estimateDuration(this.routeDistance);

      // å¦‚æœè·ç¦»å¤ªå¤§ï¼Œä½¿ç”¨ç›´çº¿è·ç¦»
      if (this.routeDistance > (this.spot?.distance || 0) * 3) {
        this.routeDistance = this.spot?.distance || 0;
        this.routeDuration = this.estimateDuration(this.routeDistance);
      }

      this.routeInfo = {
        distance: this.routeDistance,
        duration: this.routeDuration,
        type: this.selectedRouteType
      };

      // ç»˜åˆ¶è·¯çº¿
      if (routePoints.length >= 2) {
        console.info(this.TAG, `Drawing route with ${routePoints.length} points`);
        await this.drawPolyline(routePoints);
      } else {
        console.warn(this.TAG, 'Not enough points, drawing simple line');
        await this.drawSimpleLine();
      }
    } catch (e) {
      console.error(this.TAG, `Parse route error: ${e}`);
      await this.useEstimatedRoute();
    }
  }

  // ä½¿ç”¨ä¼°ç®—è·¯çº¿ï¼ˆç›´çº¿ï¼‰
  async useEstimatedRoute(): Promise<void> {
    this.routeDistance = this.spot?.distance || 0;
    this.routeDuration = this.estimateDuration(this.routeDistance);

    this.routeInfo = {
      distance: this.routeDistance,
      duration: this.routeDuration,
      type: this.selectedRouteType
    };

    await this.drawSimpleLine();
  }

  // ç»˜åˆ¶æŠ˜çº¿è·¯çº¿
  async drawPolyline(points: mapCommon.LatLng[]): Promise<void> {
    if (!this.mapController || points.length < 2) return;

    try {
      // æ¸…é™¤æ—§è·¯çº¿
      if (this.currentPolyline) {
        this.currentPolyline.remove();
      }

      const polylineOptions: mapCommon.MapPolylineOptions = {
        points: points,
        clickable: false,
        geodesic: false,
        width: 8,
        color: 0xFF4285F4
      };

      this.currentPolyline = await this.mapController.addPolyline(polylineOptions);

      // è°ƒæ•´è§†é‡æ˜¾ç¤ºæ•´æ¡è·¯çº¿
      this.fitBounds(points);
    } catch (e) {
      console.error(this.TAG, `Draw polyline error: ${e}`);
    }
  }

  // ç»˜åˆ¶ç®€å•ç›´çº¿
  async drawSimpleLine(): Promise<void> {
    if (!this.mapController || !this.spot) return;

    const userLocation = LocationService.currentLocation;
    const points: mapCommon.LatLng[] = [
      { latitude: userLocation.latitude, longitude: userLocation.longitude },
      { latitude: this.spot.latitude, longitude: this.spot.longitude }
    ];

    await this.drawPolyline(points);
  }

  // è°ƒæ•´åœ°å›¾è§†é‡
  fitBounds(points: mapCommon.LatLng[]): void {
    if (!this.mapController || points.length === 0) return;

    let minLat = points[0].latitude;
    let maxLat = points[0].latitude;
    let minLng = points[0].longitude;
    let maxLng = points[0].longitude;

    for (const p of points) {
      if (p.latitude < minLat) minLat = p.latitude;
      if (p.latitude > maxLat) maxLat = p.latitude;
      if (p.longitude < minLng) minLng = p.longitude;
      if (p.longitude > maxLng) maxLng = p.longitude;
    }

    const centerLat = (minLat + maxLat) / 2;
    const centerLng = (minLng + maxLng) / 2;

    // æ ¹æ®èŒƒå›´è®¡ç®—åˆé€‚çš„ç¼©æ”¾çº§åˆ«
    const latDiff = maxLat - minLat;
    const lngDiff = maxLng - minLng;
    const maxDiff = Math.max(latDiff, lngDiff);
    let zoom = 14;
    if (maxDiff > 0.1) zoom = 11;
    else if (maxDiff > 0.05) zoom = 12;
    else if (maxDiff > 0.02) zoom = 13;

    const cameraUpdate = map.newLatLng({ latitude: centerLat, longitude: centerLng }, zoom);
    this.mapController.animateCamera(cameraUpdate, 500);
  }

  // æ ¹æ®å‡ºè¡Œæ–¹å¼ä¼°ç®—æ—¶é—´ï¼ˆç§’ï¼‰
  estimateDuration(distanceMeters: number): number {
    let speedMps: number;
    if (this.selectedRouteType === 'driving') {
      speedMps = 40 * 1000 / 3600;
    } else if (this.selectedRouteType === 'cycling') {
      speedMps = 15 * 1000 / 3600;
    } else {
      speedMps = 5 * 1000 / 3600;
    }
    return Math.round(distanceMeters / speedMps);
  }

  formatDistance(meters: number): string {
    if (meters < 1000) return `${meters}ç±³`;
    return `${(meters / 1000).toFixed(1)}å…¬é‡Œ`;
  }

  formatDuration(seconds: number): string {
    if (seconds < 60) return `${seconds}ç§’`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}åˆ†é’Ÿ`;
    const hours = Math.floor(minutes / 60);
    const remainMinutes = minutes % 60;
    return `${hours}å°æ—¶${remainMinutes}åˆ†é’Ÿ`;
  }

  goBack(): void {
    router.back();
  }

  onPageShow(): void {
    if (this.mapController) this.mapController.show();
  }

  onPageHide(): void {
    if (this.mapController) this.mapController.hide();
  }

  build() {
    Column() {
      // é¡¶éƒ¨å¯¼èˆªæ ï¼ˆæ·»åŠ çŠ¶æ€æ é«˜åº¦ï¼‰
      Row() {
        Image($r('app.media.Left'))
          .width(24)
          .height(24)
          .onClick(() => this.goBack())

        Text('è·¯çº¿è§„åˆ’')
          .fontSize(18)
          .fontWeight(FontWeight.Bold)
          .fontColor(ThemeColors.TEXT_PRIMARY)
          .layoutWeight(1)
          .textAlign(TextAlign.Center)

        Blank().width(24)
      }
      .width('100%')
      .height(56)
      .padding({ left: 16, right: 16, top: 0 })
      .margin({ top: 44 })  // çŠ¶æ€æ é«˜åº¦
      .backgroundColor(ThemeColors.BG_SECONDARY)

      if (this.spot) {
        Row() {
          Text(WaterTypeIcons[this.spot.waterType])
            .fontSize(24)
            .margin({ right: 12 })

          Column() {
            Text(this.spot.name)
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
              .fontColor(ThemeColors.TEXT_PRIMARY)
            Text(`${WaterTypeNames[this.spot.waterType]} Â· ${FishingSpotService.formatDistance(this.spot.distance || 0)}`)
              .fontSize(12)
              .fontColor(ThemeColors.TEXT_SECONDARY)
          }
          .alignItems(HorizontalAlign.Start)
          .layoutWeight(1)
        }
        .width('100%')
        .padding(16)
        .backgroundColor(ThemeColors.BG_PRIMARY)
      }

      Row({ space: 12 }) {
        this.RouteTypeButton('ğŸš—', 'é©¾è½¦', 'driving')
        this.RouteTypeButton('ğŸš¶', 'æ­¥è¡Œ', 'walking')
        this.RouteTypeButton('ğŸš´', 'éª‘è¡Œ', 'cycling')
      }
      .width('100%')
      .padding(12)
      .backgroundColor(ThemeColors.BG_PRIMARY)
      .justifyContent(FlexAlign.Center)

      if (this.routeInfo) {
        Row() {
          Column() {
            Text(this.formatDistance(this.routeInfo.distance))
              .fontSize(20)
              .fontWeight(FontWeight.Bold)
              .fontColor(ThemeColors.PRIMARY)
            Text('æ€»è·ç¦»')
              .fontSize(12)
              .fontColor(ThemeColors.TEXT_SECONDARY)
          }
          .layoutWeight(1)

          Column() {
            Text(this.formatDuration(this.routeInfo.duration))
              .fontSize(20)
              .fontWeight(FontWeight.Bold)
              .fontColor(ThemeColors.PRIMARY)
            Text('é¢„è®¡æ—¶é—´')
              .fontSize(12)
              .fontColor(ThemeColors.TEXT_SECONDARY)
          }
          .layoutWeight(1)
        }
        .width('100%')
        .padding(16)
        .backgroundColor('#E8F5E9')
      }

      Stack() {
        if (this.mapOptions) {
          MapComponent({
            mapOptions: this.mapOptions,
            mapCallback: this.mapCallback
          })
            .width('100%')
            .height('100%')
        }

        if (this.isLoading) {
          Column() {
            LoadingProgress().width(48).height(48).color(ThemeColors.PRIMARY)
            Text('è®¡ç®—è·¯çº¿ä¸­...').fontSize(14).fontColor(ThemeColors.TEXT_SECONDARY).margin({ top: 12 })
          }
          .width('100%')
          .height('100%')
          .justifyContent(FlexAlign.Center)
          .backgroundColor('rgba(255,255,255,0.8)')
        }
      }
      .layoutWeight(1)
      .width('100%')
    }
    .width('100%')
    .height('100%')
    .backgroundColor(ThemeColors.BG_PRIMARY)
  }

  @Builder
  RouteTypeButton(icon: string, label: string, type: string) {
    Column() {
      Text(icon).fontSize(24)
      Text(label)
        .fontSize(12)
        .fontColor(this.selectedRouteType === type ? ThemeColors.PRIMARY : ThemeColors.TEXT_SECONDARY)
        .margin({ top: 4 })
    }
    .padding(12)
    .backgroundColor(this.selectedRouteType === type ? 'rgba(232, 168, 73, 0.15)' : ThemeColors.BG_SECONDARY)
    .borderRadius(8)
    .border({
      width: this.selectedRouteType === type ? 1 : 0,
      color: ThemeColors.PRIMARY
    })
    .onClick(() => {
      if (this.selectedRouteType !== type) {
        this.selectedRouteType = type;
        this.calculateRoute();
      }
    })
  }
}
