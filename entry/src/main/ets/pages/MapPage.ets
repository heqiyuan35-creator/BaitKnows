/**
 * é¥µçŸ¥é?- åœ°å›¾é¡µé¢ï¼ˆé«˜å¾·åœ°å›¾ç‰ˆï¼?
 * æ˜¾ç¤ºå‘¨è¾¹çœŸå®é’“ç‚¹ï¼Œç‚¹å‡»æ¨èé¥µæ–?
 */
import {
  AMap,
  MapView,
  MapViewComponent,
  MapViewManager,
  MapViewCreateCallback,
  CameraUpdateFactory,
  CameraUpdate,
  LatLng,
  LatLngBounds,
  Marker,
  MarkerOptions,
  Polyline,
  PolylineOptions,
  BitmapDescriptorFactory,
  BitmapDescriptor,
  MapType
} from '@amap/amap_lbs_map3d';
import {
  PoiSearch,
  PoiQuery,
  PoiResult,
  PoiItem,
  OnPoiSearchListener,
  LatLonPoint,
  AMapException,
  PoiSearchBound,
  GeocodeSearch,
  ReGeocodeQuery,
  ReGeocodeAddress,
  RouteSearch,
  DriveRouteQuery,
  DriveRouteResult,
  WalkRouteQuery,
  WalkRouteResult,
  RideRouteQuery,
  RideRouteResult,
  BusRouteResult,
  FromAndTo,
  OnRouteSearchListener,
  DrivePath,
  DriveStep,
  WalkPath,
  WalkStep,
  RidePath,
  RideStep
} from '@amap/amap_lbs_search';
import { ArrayList } from '@kit.ArkTS';
import { abilityAccessCtrl, common, PermissionRequestResult, Permissions } from '@kit.AbilityKit';
import { geoLocationManager } from '@kit.LocationKit';
import { router } from '@kit.ArkUI';
import { ThemeColors } from '../theme/ThemeColors';
import { FishingSpot, WaterType, WaterTypeNames, WaterTypeImages } from '../data/FishingSpotData';
import { RecipeService, Recipe } from '../services/RecipeService';
import { FishingSpotService } from '../services/FishingSpotService';

const MAP_VIEW_NAME: string = 'BaitKnowsMap';

// é’“ç‚¹æœç´¢å…³é”®è¯?- æ°´åŸŸç›¸å…³
const FISHING_KEYWORDS: string[] = ['æ¹?, 'æ²?, 'æ°´åº“', 'æ±?, 'å¡?, 'é’“é±¼', 'å‚é’“', 'å…¬å›­'];

// ç”¨æˆ·è‡ªå®šä¹‰é’“ç‚¹æ¥å?
interface UserCustomSpot {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
  note: string;
  createTime: number;
  waterType: WaterType;
}

// è·¯çº¿ç±»å‹
type RouteType = 'drive' | 'walk' | 'ride';

@Entry
@Component
struct MapPage {
  private TAG = 'MapPage';
  private mapView: MapView | undefined = undefined;
  private aMap: AMap | undefined = undefined;
  private poiSearch: PoiSearch | undefined = undefined;
  private geocodeSearch: GeocodeSearch | undefined = undefined;
  private routeSearch: RouteSearch | undefined = undefined;
  private locationMarker: Marker | undefined = undefined;
  private spotMarkers: Marker[] = [];
  private customSpotMarkers: Marker[] = [];
  private hooksIcon: BitmapDescriptor | undefined = undefined;
  private routePolyline: Polyline | undefined = undefined;
  private startMarker: Marker | undefined = undefined;
  private endMarker: Marker | undefined = undefined;

  @State isMapReady: boolean = false;
  @State isSearching: boolean = false;
  @State currentLocation: string = 'å®šä½ä¸?..';
  @State currentLatLng: LatLng | undefined = undefined;
  @State fishingSpots: FishingSpot[] = [];
  @State showBaitDialog: boolean = false;
  @State selectedSpot: FishingSpot | null = null;
  @State recommendedRecipes: Recipe[] = [];
  @State clickedLocationName: string = '';
  @State showMapTypePanel: boolean = false;
  @State currentMapType: number = 0; // 0:æ™®é€?1:å«æ˜Ÿ 2:å¤œé—´

  // å¯¼èˆªç›¸å…³çŠ¶æ€?
  @State showRoutePanel: boolean = false;
  @State selectedRouteType: RouteType = 'drive';
  @State isRouteSearching: boolean = false;
  @State routeDistance: number = 0;
  @State routeDuration: number = 0;
  @State routeInfo: string = '';

  // ç”¨æˆ·è‡ªå®šä¹‰æ‰“ç‚¹ç›¸å…³çŠ¶æ€?
  @State isAddingCustomSpot: boolean = false;
  @State showAddSpotDialog: boolean = false;
  @State pendingSpotLatLng: LatLng | undefined = undefined;
  @State pendingSpotAddress: string = '';
  @State customSpotName: string = '';
  @State customSpotNote: string = '';
  @State customSpotWaterType: WaterType = WaterType.POND;
  @State userCustomSpots: UserCustomSpot[] = [];
  @State showCustomSpotDetail: boolean = false;
  @State selectedCustomSpot: UserCustomSpot | null = null;
  @State showMySpotsList: boolean = false;

  // é»˜è®¤ä½ç½®ï¼ˆæ­¦æ±‰ï¼‰
  private defaultLat: number = 30.5928;
  private defaultLng: number = 114.3055;

  private mapViewCreateCallback: MapViewCreateCallback =
    (mapview: MapView | undefined, mapViewName: string | undefined): void => {
      if (!mapview || mapViewName !== MAP_VIEW_NAME) return;

      console.info(this.TAG, 'MapView created');
      this.mapView = mapview;
      this.mapView.onCreate();

      this.mapView.getMapAsync((map: AMap): void => {
        console.info(this.TAG, 'AMap ready');
        this.aMap = map;
        this.isMapReady = true;

        // åˆå§‹åŒ–åœ°å›¾ä½ç½?
        const defaultLocation: LatLng = new LatLng(this.defaultLat, this.defaultLng);
        const update: CameraUpdate = CameraUpdateFactory.newLatLngZoom(defaultLocation, 12);
        map.moveCamera(update);

        // å¯ç”¨åœ°å›¾æ§ä»¶
        map.getUiSettings()?.setZoomControlsEnabled(true);
        map.getUiSettings()?.setScaleControlsEnabled(true);

        // è¯·æ±‚å®šä½æƒé™
        this.requestLocationPermission();

        // åœ°å›¾ç‚¹å‡»äº‹ä»¶ - é€†åœ°ç†ç¼–ç æˆ–æ·»åŠ è‡ªå®šä¹‰é’“ç‚?
        map.setOnMapClickListener((point: LatLng): void => {
          if (this.isAddingCustomSpot) {
            this.onMapClickForCustomSpot(point);
          } else {
            this.onMapClick(point);
          }
        });

        // æ ‡è®°ç‚¹å‡»äº‹ä»¶
        map.setOnMarkerClickListener((marker: Marker): boolean => {
          this.onMarkerClick(marker);
          return true;
        });

        // åŠ è½½è‡ªå®šä¹‰æ ‡è®°å›¾æ ?
        this.loadCustomMarkerIcon();
      });
    };

  // POIæœç´¢ç›‘å¬å™?
  private currentKeywordIndex: number = 0;
  private tempSpots: FishingSpot[] = [];

  // è·¯çº¿æœç´¢ç›‘å¬å™?
  private routeSearchListener: OnRouteSearchListener = {
    onDriveRouteSearched: (result: DriveRouteResult | undefined, errorCode: number): void => {
      console.info(this.TAG, '========== é©¾è½¦è·¯çº¿å›è°ƒ ==========');
      console.info(this.TAG, `errorCode=${errorCode}, result=${!!result}`);
      this.isRouteSearching = false;
      if (errorCode === AMapException.CODE_AMAP_SUCCESS && result) {
        const paths = result.getPaths();
        console.info(this.TAG, `æ‰¾åˆ° ${paths?.length || 0} æ¡è·¯çº¿`);
        if (paths && paths.length > 0) {
          const path: DrivePath = paths[0];
          this.routeDistance = path.getDistance();
          this.routeDuration = path.getDuration();
          console.info(this.TAG, `è·ç¦»=${this.routeDistance}ç±? æ—¶é—´=${this.routeDuration}ç§’`);
          this.routeInfo = `é©¾è½¦ ${this.formatRouteDistance(this.routeDistance)} Â· ${this.formatRouteDuration(this.routeDuration)}`;
          this.drawDriveRoute(path);
        } else {
          this.routeInfo = 'æœªæ‰¾åˆ°é©¾è½¦è·¯çº?;
        }
      } else {
        console.error(this.TAG, `é©¾è½¦è·¯çº¿æŸ¥è¯¢å¤±è´¥: ${errorCode}`);
        this.routeInfo = this.getRouteErrorMessage(errorCode);
      }
    },

    onWalkRouteSearched: (result: WalkRouteResult | undefined, errorCode: number): void => {
      console.info(this.TAG, '========== æ­¥è¡Œè·¯çº¿å›è°ƒ ==========');
      console.info(this.TAG, `errorCode=${errorCode}, result=${!!result}`);
      this.isRouteSearching = false;
      if (errorCode === AMapException.CODE_AMAP_SUCCESS && result) {
        const paths = result.getPaths();
        console.info(this.TAG, `æ‰¾åˆ° ${paths?.length || 0} æ¡è·¯çº¿`);
        if (paths && paths.length > 0) {
          const path: WalkPath = paths[0];
          this.routeDistance = path.getDistance();
          this.routeDuration = path.getDuration();
          console.info(this.TAG, `è·ç¦»=${this.routeDistance}ç±? æ—¶é—´=${this.routeDuration}ç§’`);
          this.routeInfo = `æ­¥è¡Œ ${this.formatRouteDistance(this.routeDistance)} Â· ${this.formatRouteDuration(this.routeDuration)}`;
          this.drawWalkRoute(path);
        } else {
          this.routeInfo = 'æœªæ‰¾åˆ°æ­¥è¡Œè·¯çº?;
        }
      } else {
        console.error(this.TAG, `æ­¥è¡Œè·¯çº¿æŸ¥è¯¢å¤±è´¥: ${errorCode}`);
        this.routeInfo = this.getRouteErrorMessage(errorCode);
      }
    },

    onRideRouteSearched: (result: RideRouteResult | undefined, errorCode: number): void => {
      console.info(this.TAG, '========== éª‘è¡Œè·¯çº¿å›è°ƒ ==========');
      console.info(this.TAG, `errorCode=${errorCode}, result=${!!result}`);
      this.isRouteSearching = false;
      if (errorCode === AMapException.CODE_AMAP_SUCCESS && result) {
        const paths = result.getPaths();
        console.info(this.TAG, `æ‰¾åˆ° ${paths?.length || 0} æ¡è·¯çº¿`);
        if (paths && paths.length > 0) {
          const path: RidePath = paths[0];
          this.routeDistance = path.getDistance();
          this.routeDuration = path.getDuration();
          console.info(this.TAG, `è·ç¦»=${this.routeDistance}ç±? æ—¶é—´=${this.routeDuration}ç§’`);
          this.routeInfo = `éª‘è¡Œ ${this.formatRouteDistance(this.routeDistance)} Â· ${this.formatRouteDuration(this.routeDuration)}`;
          this.drawRideRoute(path);
        } else {
          this.routeInfo = 'æœªæ‰¾åˆ°éª‘è¡Œè·¯çº?;
        }
      } else {
        console.error(this.TAG, `éª‘è¡Œè·¯çº¿æŸ¥è¯¢å¤±è´¥: ${errorCode}`);
        this.routeInfo = this.getRouteErrorMessage(errorCode);
      }
    },

    onBusRouteSearched: (result: BusRouteResult | undefined, errorCode: number): void => {
      this.isRouteSearching = false;
    }
  };

  // è·å–è·¯çº¿é”™è¯¯ä¿¡æ¯
  private getRouteErrorMessage(errorCode: number): string {
    const errorMessages: Record<number, string> = {
      1001: 'è¯·æ±‚å‚æ•°éæ³•',
      1002: 'Keyä¸æ­£ç¡®æˆ–è¿‡æœŸ',
      1003: 'æ²¡æœ‰æƒé™ä½¿ç”¨ç›¸åº”çš„æœåŠ?,
      1008: 'èµ·ç‚¹æˆ–ç»ˆç‚¹ä¸åœ¨ä¸­å›½å¤§é™†èŒƒå›´å†…',
      1009: 'èµ·ç‚¹é™„è¿‘æ²¡æœ‰æ‰¾åˆ°é“è·¯',
      1010: 'ç»ˆç‚¹é™„è¿‘æ²¡æœ‰æ‰¾åˆ°é“è·¯',
      1011: 'èµ·ç‚¹å’Œç»ˆç‚¹è·ç¦»å¤ªè¿?,
      1012: 'èµ·ç‚¹å’Œç»ˆç‚¹è·ç¦»å¤ªè¿?,
      1200: 'æœåŠ¡å“åº”é”™è¯¯',
      1804: 'è·¯çº¿è®¡ç®—å¤±è´¥'
    };
    return errorMessages[errorCode] || `è·¯çº¿æŸ¥è¯¢å¤±è´¥(${errorCode})`;
  }

  private poiSearchListener: OnPoiSearchListener = {
    onPoiSearched: (result: PoiResult | undefined, errorCode: number): void => {
      console.info(this.TAG, `POIæœç´¢å›è°ƒ: errorCode=${errorCode}, keyword=${FISHING_KEYWORDS[this.currentKeywordIndex]}`);

      if (errorCode === AMapException.CODE_AMAP_SUCCESS && result) {
        const pois = result.getPois();
        console.info(this.TAG, `æ‰¾åˆ° ${pois?.length || 0} ä¸ªPOI`);

        if (pois && pois.length > 0) {
          pois.forEach((poi: PoiItem): void => {
            const point = poi.getLatLonPoint();
            if (point) {
              const name = poi.getTitle() || '';
              // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
              const exists = this.tempSpots.some(s =>
                Math.abs(s.latitude - point.getLatitude()) < 0.0001 &&
                Math.abs(s.longitude - point.getLongitude()) < 0.0001
              );
              if (!exists) {
                const waterType = this.detectWaterType(name);
                const distance = this.currentLatLng ?
                  this.calculateDistance(this.currentLatLng.latitude, this.currentLatLng.longitude,
                    point.getLatitude(), point.getLongitude()) : 0;

                this.tempSpots.push({
                  id: poi.getPoiId() || `spot_${this.tempSpots.length}`,
                  name: name,
                  latitude: point.getLatitude(),
                  longitude: point.getLongitude(),
                  waterType: waterType,
                  description: poi.getSnippet() || this.getSpotDescription(waterType),
                  distance: Math.round(distance)
                });
                console.info(this.TAG, `æ·»åŠ é’“ç‚¹: ${name} (${point.getLatitude()}, ${point.getLongitude()})`);
              }
            }
          });
        }
      } else {
        console.error(this.TAG, `POIæœç´¢å¤±è´¥: ${errorCode}`);
      }

      // ç»§ç»­æœç´¢ä¸‹ä¸€ä¸ªå…³é”®è¯
      this.currentKeywordIndex++;
      if (this.currentKeywordIndex < FISHING_KEYWORDS.length) {
        this.searchNextKeyword();
      } else {
        // æœç´¢å®Œæˆ
        console.info(this.TAG, `æ‰€æœ‰å…³é”®è¯æœç´¢å®Œæˆï¼Œå…±æ‰¾åˆ° ${this.tempSpots.length} ä¸ªé’“ç‚¹`);
        this.finishSearch();
      }
    },
    onPoiItemSearched: (): void => {}
  };

  // å¯¼èˆªå‚æ•°
  private navigateToSpotOnLoad: boolean = false;
  private pendingNavigateSpot: FishingSpot | null = null;

  aboutToAppear(): void {
    console.info(this.TAG, 'MapPage aboutToAppear');
    MapViewManager.getInstance().registerMapViewCreatedCallback(this.mapViewCreateCallback);

    const context: Context = getContext(this);
    this.poiSearch = new PoiSearch(context, undefined);
    this.poiSearch.setOnPoiSearchListener(this.poiSearchListener);
    this.geocodeSearch = new GeocodeSearch(context);
    
    // åˆå§‹åŒ–è·¯çº¿æœç´?
    this.routeSearch = new RouteSearch(context);
    this.routeSearch.setRouteSearchListener(this.routeSearchListener);

    // æ£€æŸ¥æ˜¯å¦æœ‰å¯¼èˆªå‚æ•°
    this.checkNavigationParams();
  }

  // æ£€æŸ¥å¯¼èˆªå‚æ•?
  private checkNavigationParams(): void {
    const params = router.getParams() as Record<string, Object> | undefined;
    if (params && params['navigateToSpot'] === true) {
      console.info(this.TAG, 'æ”¶åˆ°å¯¼èˆªå‚æ•°');
      this.navigateToSpotOnLoad = true;
      this.pendingNavigateSpot = {
        id: params['spotId'] as string || '',
        name: params['spotName'] as string || 'é’“ç‚¹',
        latitude: params['spotLat'] as number || 0,
        longitude: params['spotLng'] as number || 0,
        waterType: params['spotWaterType'] as WaterType || WaterType.POND,
        distance: params['spotDistance'] as number || 0,
        description: ''
      };
      console.info(this.TAG, `å¾…å¯¼èˆªé’“ç‚? ${this.pendingNavigateSpot.name}`);
    }
  }

  aboutToDisappear(): void {
    console.info(this.TAG, 'MapPage aboutToDisappear');
    this.clearSpotMarkers();
    MapViewManager.getInstance().unregisterMapViewCreatedCallback(this.mapViewCreateCallback);
    if (this.mapView) {
      this.mapView.onDestroy();
      this.mapView = undefined;
      this.aMap = undefined;
    }
  }

  onPageShow(): void {
    if (this.mapView) {
      this.mapView.onResume();
    }
  }

  onPageHide(): void {
    if (this.mapView) {
      this.mapView.onPause();
    }
  }

  // è¯·æ±‚å®šä½æƒé™
  private async requestLocationPermission(): Promise<void> {
    try {
      const permissions: Permissions[] = [
        'ohos.permission.APPROXIMATELY_LOCATION',
        'ohos.permission.LOCATION'
      ];

      const context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
      const atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();
      const result: PermissionRequestResult = await atManager.requestPermissionsFromUser(context, permissions);

      const allGranted: boolean = result.authResults.every((status: number): boolean => status === 0);
      if (allGranted) {
        this.startLocation();
      } else {
        this.currentLocation = 'æœªæˆæƒå®šä½ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®';
        this.currentLatLng = new LatLng(this.defaultLat, this.defaultLng);
        this.addLocationMarker();
        this.searchNearbySpots();
      }
    } catch (error) {
      console.error(this.TAG, `Permission request failed: ${error}`);
      this.currentLatLng = new LatLng(this.defaultLat, this.defaultLng);
      this.addLocationMarker();
      this.searchNearbySpots();
    }
  }

  // å¼€å§‹å®šä½?
  private startLocation(): void {
    this.currentLocation = 'æ­£åœ¨å®šä½...';

    const request: geoLocationManager.CurrentLocationRequest = {
      priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
      scenario: geoLocationManager.LocationRequestScenario.UNSET
    };

    geoLocationManager.getCurrentLocation(request)
      .then(async (location: geoLocationManager.Location): Promise<void> => {
        console.info(this.TAG, `Location: ${location.latitude}, ${location.longitude}`);
        this.currentLatLng = new LatLng(location.latitude, location.longitude);
        this.currentLocation = 'å·²å®šä½?;

        // ç§»åŠ¨åœ°å›¾åˆ°å½“å‰ä½ç½?
        if (this.aMap) {
          const update: CameraUpdate = CameraUpdateFactory.newLatLngZoom(this.currentLatLng, 13);
          this.aMap.animateCamera(update);
        }

        // æ·»åŠ ä½ç½®æ ‡è®°
        await this.addLocationMarker();

        // è·å–åœ°å€
        this.getAddressFromLocation(location.latitude, location.longitude);

        // æœç´¢é™„è¿‘é’“ç‚¹
        this.searchNearbySpots();
      })
      .catch((error: Error): void => {
        console.error(this.TAG, `Location failed: ${error}`);
        this.currentLocation = 'å®šä½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä½ç½?;
        this.currentLatLng = new LatLng(this.defaultLat, this.defaultLng);
        this.addLocationMarker();
        this.searchNearbySpots();
      });
  }

  // æ·»åŠ å½“å‰ä½ç½®æ ‡è®° - ä½¿ç”¨é†’ç›®çš„çº¢è‰²å¤§æ ‡è®°
  private async addLocationMarker(): Promise<void> {
    if (!this.aMap || !this.currentLatLng) return;

    if (this.locationMarker) {
      this.locationMarker.remove();
    }

    const options: MarkerOptions = new MarkerOptions();
    options.setPosition(this.currentLatLng);
    options.setTitle('ğŸ¯ æˆ‘çš„ä½ç½®');
    options.setSnippet('ç‚¹å‡»å®šä½åˆ°æ­¤å¤?);

    // ä½¿ç”¨çº¢è‰²æ ‡è®°ï¼Œæ›´é†’ç›®
    options.setIcon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED));
    options.setAnchor(0.5, 1.0);
    options.setZIndex(999); // æœ€é«˜å±‚çº§ï¼Œç¡®ä¿åœ¨æœ€ä¸Šé¢

    this.locationMarker = this.aMap.addMarker(options);

    // é»˜è®¤æ˜¾ç¤ºä¿¡æ¯çª—å£ï¼Œè®©ç”¨æˆ·ä¸€çœ¼çœ‹åˆ?
    if (this.locationMarker) {
      this.locationMarker.showInfoWindow();
    }
  }

  // æœç´¢é™„è¿‘é’“ç‚¹
  private searchNearbySpots(): void {
    if (!this.poiSearch || !this.currentLatLng) {
      console.error(this.TAG, 'æ— æ³•æœç´¢ï¼špoiSearchæˆ–ä½ç½®æœªåˆå§‹åŒ?);
      return;
    }

    // å¦‚æœæ˜¯å¯¼èˆªæ¨¡å¼ï¼Œè·³è¿‡ POI æœç´¢ï¼Œç›´æ¥å¼€å§‹å¯¼èˆ?
    if (this.navigateToSpotOnLoad && this.pendingNavigateSpot) {
      console.info(this.TAG, `å¯¼èˆªæ¨¡å¼ï¼šè·³è¿‡POIæœç´¢ï¼Œç›´æ¥å¯¼èˆªåˆ° ${this.pendingNavigateSpot.name}`);
      this.navigateToSpotOnLoad = false;
      this.currentLocation = `å¯¼èˆªåˆ? ${this.pendingNavigateSpot.name}`;
      
      setTimeout(() => {
        if (this.pendingNavigateSpot) {
          this.startNavigation(this.pendingNavigateSpot);
          this.pendingNavigateSpot = null;
        }
      }, 300);
      return;
    }

    this.isSearching = true;
    this.currentLocation = 'æœç´¢é’“ç‚¹ä¸?..';
    this.currentKeywordIndex = 0;
    this.tempSpots = [];

    this.searchNextKeyword();
  }

  // æœç´¢ä¸‹ä¸€ä¸ªå…³é”®è¯ - åŸºäºç”¨æˆ·ä½ç½®çš„å‘¨è¾¹æœç´?
  private searchNextKeyword(): void {
    if (!this.poiSearch || !this.currentLatLng) return;

    const keyword = FISHING_KEYWORDS[this.currentKeywordIndex];
    console.info(this.TAG, `æœç´¢å…³é”®è¯? ${keyword}, ä½ç½®: (${this.currentLatLng.latitude}, ${this.currentLatLng.longitude})`);

    // åˆ›å»ºæŸ¥è¯¢
    const query: PoiQuery = new PoiQuery(keyword, '', '');
    query.setPageSize(20);
    query.setPageNum(0);

    // åŸºäºç”¨æˆ·å½“å‰ä½ç½®åˆ›å»ºå‘¨è¾¹æœç´¢èŒƒå›´ï¼?0å…¬é‡Œï¼?
    const centerPoint: LatLonPoint = new LatLonPoint(
      this.currentLatLng.latitude,
      this.currentLatLng.longitude
    );
    const searchBound: PoiSearchBound = PoiSearchBound.createCircleSearchBound(centerPoint, 10000);

    this.poiSearch.setQuery(query);
    this.poiSearch.setBound(searchBound);
    this.poiSearch.searchPOIAsyn();
  }

  // å®Œæˆæœç´¢
  private finishSearch(): void {
    // æŒ‰è·ç¦»æ’åº?
    this.tempSpots.sort((a, b) => (a.distance || 0) - (b.distance || 0));
    this.fishingSpots = this.tempSpots.slice(0, 20);

    console.info(this.TAG, `æœç´¢å®Œæˆï¼Œæ‰¾åˆ?${this.fishingSpots.length} ä¸ªé’“ç‚¹`);

    this.isSearching = false;

    // å¦‚æœæ˜¯å¯¼èˆªæ¨¡å¼ï¼Œä¸æ·»åŠ å…¶ä»–é’“ç‚¹ï¼Œåªå¤„ç†ç›®æ ‡é’“ç‚?
    if (this.navigateToSpotOnLoad && this.pendingNavigateSpot) {
      console.info(this.TAG, `å¯¼èˆªæ¨¡å¼ï¼šç›´æ¥å¯¼èˆªåˆ° ${this.pendingNavigateSpot.name}`);
      this.navigateToSpotOnLoad = false;
      this.currentLocation = `å¯¼èˆªåˆ? ${this.pendingNavigateSpot.name}`;
      
      // æ›´æ–°ç¼“å­˜
      FishingSpotService.updateCachedSpots(this.fishingSpots);
      
      // å»¶è¿Ÿæ‰§è¡Œå¯¼èˆª
      setTimeout(() => {
        if (this.pendingNavigateSpot) {
          this.startNavigation(this.pendingNavigateSpot);
          this.pendingNavigateSpot = null;
        }
      }, 300);
      return;
    }

    // å¦‚æœæ²¡æœ‰æœç´¢åˆ°é’“ç‚¹ï¼Œæ·»åŠ é™„è¿‘çš„æ¨¡æ‹Ÿé’“ç‚¹ï¼ˆåŸºäºå½“å‰ä½ç½®ï¼?
    if (this.fishingSpots.length === 0 && this.currentLatLng) {
      this.addNearbyMockSpots();
    }

    // æ›´æ–°ç¼“å­˜ï¼Œè®©é¦–é¡µä¹Ÿèƒ½è·å–åˆ°é’“ç‚¹æ•°æ?
    FishingSpotService.updateCachedSpots(this.fishingSpots);

    if (this.fishingSpots.length > 0) {
      this.currentLocation = `å‘ç° ${this.fishingSpots.length} ä¸ªé’“ç‚¹`;
    } else {
      this.currentLocation = 'é™„è¿‘æš‚æ— é’“ç‚¹';
    }

    // æ·»åŠ é’“ç‚¹æ ‡è®°
    this.addSpotMarkers();
  }

  // æ·»åŠ é™„è¿‘çœŸå®é’“ç‚¹ï¼ˆæ­¦æ±‰åœ°åŒºçƒ­é—¨é’“ç‚¹ï¼‰
  private addNearbyMockSpots(): void {
    if (!this.currentLatLng) return;

    const userLat = this.currentLatLng.latitude;
    const userLng = this.currentLatLng.longitude;

    // æ­¦æ±‰çœŸå®é’“ç‚¹æ•°æ®
    const realSpots: FishingSpot[] = [
      // ä¸œæ¹–åŒºåŸŸ
      {
        id: 'spot_1',
        name: 'ä¸œæ¹–è½é›æ™¯åŒº',
        latitude: 30.5547,
        longitude: 114.4283,
        waterType: WaterType.RESERVOIR,
        description: 'ä¸œæ¹–æœ€å¤§çš„æ¹–æ±Šï¼Œæ°´è´¨å¥½ï¼Œé±¼ç§ä¸°å¯?,
        distance: 0
      },
      {
        id: 'spot_2',
        name: 'ä¸œæ¹–ç£¨å±±æ™¯åŒº',
        latitude: 30.5489,
        longitude: 114.4089,
        waterType: WaterType.RESERVOIR,
        description: 'é£æ™¯ä¼˜ç¾ï¼Œé€‚åˆä¼‘é—²å‚é’“',
        distance: 0
      },
      {
        id: 'spot_3',
        name: 'ä¸œæ¹–å¬æ¶›æ™¯åŒº',
        latitude: 30.5612,
        longitude: 114.3856,
        waterType: WaterType.RESERVOIR,
        description: 'äº¤é€šä¾¿åˆ©ï¼Œå²¸è¾¹é’“ä½å¤?,
        distance: 0
      },
      // æ²™æ¹–åŒºåŸŸ
      {
        id: 'spot_4',
        name: 'æ²™æ¹–å…¬å›­',
        latitude: 30.5734,
        longitude: 114.3412,
        waterType: WaterType.POND,
        description: 'å¸‚åŒºå†…é’“åœºï¼Œé€‚åˆä¼‘é—²',
        distance: 0
      },
      // æ±¤é€Šæ¹–åŒºåŸŸ
      {
        id: 'spot_5',
        name: 'æ±¤é€Šæ¹–',
        latitude: 30.4523,
        longitude: 114.3678,
        waterType: WaterType.RESERVOIR,
        description: 'æ­¦æ±‰æœ€å¤§åŸä¸­æ¹–ï¼Œå¤§ç‰©é¢‘å‡?,
        distance: 0
      },
      // é•¿æ±ŸåŒºåŸŸ
      {
        id: 'spot_6',
        name: 'æ±‰å£æ±Ÿæ»©',
        latitude: 30.5912,
        longitude: 114.2934,
        waterType: WaterType.RIVER,
        description: 'é•¿æ±Ÿé’“åœºï¼Œé±¼å£æ´»è·?,
        distance: 0
      },
      {
        id: 'spot_7',
        name: 'æ­¦æ˜Œæ±Ÿæ»©',
        latitude: 30.5523,
        longitude: 114.3123,
        waterType: WaterType.RIVER,
        description: 'æ±Ÿè¾¹é’“ä½ï¼Œæ³¨æ„å®‰å…?,
        distance: 0
      },
      // å…¶ä»–æ¹–æ³Š
      {
        id: 'spot_8',
        name: 'å¢¨æ°´æ¹?,
        latitude: 30.5234,
        longitude: 114.2156,
        waterType: WaterType.POND,
        description: 'æ±‰é˜³åŒºé’“åœºï¼Œé²«é±¼å¤?,
        distance: 0
      },
      {
        id: 'spot_9',
        name: 'å—æ¹–',
        latitude: 30.5089,
        longitude: 114.3534,
        waterType: WaterType.POND,
        description: 'æ´ªå±±åŒºæ¹–æ³Šï¼Œç¯å¢ƒä¼˜ç¾',
        distance: 0
      },
      {
        id: 'spot_10',
        name: 'åå®˜æ¹?,
        latitude: 30.4912,
        longitude: 114.1234,
        waterType: WaterType.RESERVOIR,
        description: 'è”¡ç”¸åŒºå¤§å‹æ°´åº“ï¼Œé±¼ç§å¤?,
        distance: 0
      },
      {
        id: 'spot_11',
        name: 'ä¸¥è¥¿æ¹?,
        latitude: 30.5234,
        longitude: 114.4789,
        waterType: WaterType.RESERVOIR,
        description: 'å…‰è°·é™„è¿‘ï¼Œæ°´è´¨æ¸…æ¾?,
        distance: 0
      },
      {
        id: 'spot_12',
        name: 'æ¢å­æ¹?,
        latitude: 30.2567,
        longitude: 114.5234,
        waterType: WaterType.RESERVOIR,
        description: 'æ­¦æ±‰æœ€å¤§æ·¡æ°´æ¹–ï¼Œé‡é’“åœ£åœ?,
        distance: 0
      }
    ];

    // è®¡ç®—æ¯ä¸ªé’“ç‚¹åˆ°ç”¨æˆ·çš„è·ç¦»
    realSpots.forEach(spot => {
      spot.distance = Math.round(this.calculateDistance(userLat, userLng, spot.latitude, spot.longitude));
    });

    // æŒ‰è·ç¦»æ’åºï¼Œå–æœ€è¿‘çš„10ä¸?
    realSpots.sort((a, b) => (a.distance || 0) - (b.distance || 0));
    this.fishingSpots = realSpots.slice(0, 10);

    console.info(this.TAG, `æ·»åŠ äº?${this.fishingSpots.length} ä¸ªçœŸå®é’“ç‚¹`);
  }

  // æ·»åŠ é’“ç‚¹æ ‡è®° - æŒ‰ç…§é«˜å¾·åœ°å›¾æ–‡æ¡£æ–¹å¼æ·»åŠ 
  private addSpotMarkers(): void {
    if (!this.aMap) {
      console.error(this.TAG, 'åœ°å›¾æœªåˆå§‹åŒ–ï¼Œæ— æ³•æ·»åŠ æ ‡è®?);
      return;
    }

    this.clearSpotMarkers();
    console.info(this.TAG, `å¼€å§‹æ·»åŠ?${this.fishingSpots.length} ä¸ªé’“ç‚¹æ ‡è®°`);

    for (let i = 0; i < this.fishingSpots.length; i++) {
      const spot = this.fishingSpots[i];

      // æŒ‰ç…§é«˜å¾·æ–‡æ¡£æ–¹å¼åˆ›å»º Marker
      let options: MarkerOptions = new MarkerOptions();
      options.setPosition(new LatLng(spot.latitude, spot.longitude));
      options.setTitle(spot.name);
      options.setSnippet(`${WaterTypeNames[spot.waterType]} Â· ${this.formatDistance(spot.distance || 0)}`);

      // å‰?ä¸ªç”¨æ©™è‰²ï¼ˆæ¨èï¼‰ï¼Œå…¶ä»–ç”¨ç»¿è‰²
      const hue = i < 3 ? BitmapDescriptorFactory.HUE_ORANGE : BitmapDescriptorFactory.HUE_GREEN;
      options.setIcon(BitmapDescriptorFactory.defaultMarker(hue));
      options.setAnchor(0.5, 1.0);

      let marker = this.aMap.addMarker(options);
      if (marker) {
        this.spotMarkers.push(marker);
        console.info(this.TAG, `æ·»åŠ é’“ç‚¹æ ‡è®°: ${spot.name} at (${spot.latitude}, ${spot.longitude})`);
      }
    }

    console.info(this.TAG, `æˆåŠŸæ·»åŠ  ${this.spotMarkers.length} ä¸ªæ ‡è®°`);
  }

  // æ¸…é™¤é’“ç‚¹æ ‡è®°
  private clearSpotMarkers(): void {
    for (const marker of this.spotMarkers) {
      marker.remove();
    }
    this.spotMarkers = [];
  }

  // æ ‡è®°ç‚¹å‡»äº‹ä»¶
  private onMarkerClick(marker: Marker): void {
    const position = marker.getPosition();

    // å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå®šä¹‰é’“ç‚?
    const customSpot = this.userCustomSpots.find(s =>
      Math.abs(s.latitude - position.latitude) < 0.0001 &&
      Math.abs(s.longitude - position.longitude) < 0.0001
    );

    if (customSpot) {
      this.onCustomSpotClick(customSpot);
      return;
    }

    // æŸ¥æ‰¾å¯¹åº”çš„POIé’“ç‚¹
    const spot = this.fishingSpots.find(s =>
      Math.abs(s.latitude - position.latitude) < 0.0001 &&
      Math.abs(s.longitude - position.longitude) < 0.0001
    );

    if (spot) {
      this.onSpotClick(spot);
    }
  }

  // ç‚¹å‡»é’“ç‚¹
  private onSpotClick(spot: FishingSpot): void {
    this.selectedSpot = spot;
    this.recommendedRecipes = this.recommendRecipes(spot.waterType);
    this.showBaitDialog = true;
  }

  // åœ°å›¾ç‚¹å‡»äº‹ä»¶ - é€†åœ°ç†ç¼–ç ?
  private async onMapClick(point: LatLng): Promise<void> {
    if (!this.geocodeSearch) return;

    this.clickedLocationName = 'æŸ¥è¯¢ä¸?..';

    try {
      const latLonPoint: LatLonPoint = new LatLonPoint(point.latitude, point.longitude);
      const query: ReGeocodeQuery = new ReGeocodeQuery(latLonPoint, 200, GeocodeSearch.AMAP);
      const address: ReGeocodeAddress | undefined = await this.geocodeSearch.getFromLocation(query);

      if (address) {
        const formatAddress = address.getFormatAddress();
        if (formatAddress) {
          // ç®€åŒ–åœ°å€æ˜¾ç¤º
          const district = address.getDistrict() || '';
          const township = address.getTownship() || '';
          this.clickedLocationName = `${district}${township}` || formatAddress;
        } else {
          this.clickedLocationName = `${point.latitude.toFixed(4)}, ${point.longitude.toFixed(4)}`;
        }
      } else {
        this.clickedLocationName = `${point.latitude.toFixed(4)}, ${point.longitude.toFixed(4)}`;
      }
    } catch (error) {
      console.error(this.TAG, `Reverse geocode failed: ${error}`);
      this.clickedLocationName = `${point.latitude.toFixed(4)}, ${point.longitude.toFixed(4)}`;
    }
  }

  // è·å–å½“å‰ä½ç½®åœ°å€
  private async getAddressFromLocation(lat: number, lng: number): Promise<void> {
    if (!this.geocodeSearch) return;

    try {
      const point: LatLonPoint = new LatLonPoint(lat, lng);
      const query: ReGeocodeQuery = new ReGeocodeQuery(point, 200, GeocodeSearch.AMAP);
      const address: ReGeocodeAddress | undefined = await this.geocodeSearch.getFromLocation(query);

      if (address) {
        const city = address.getCity() || '';
        const district = address.getDistrict() || '';
        if (city) {
          this.currentLocation = `${city} ${district}`.trim();
        }
      }
    } catch (error) {
      console.error(this.TAG, `Get address failed: ${error}`);
    }
  }

  // åˆ·æ–°ä½ç½®
  private refreshLocation(): void {
    this.startLocation();
  }

  // ç§»åŠ¨åˆ°å½“å‰ä½ç½?
  private moveToCurrentLocation(): void {
    if (!this.aMap || !this.currentLatLng) return;
    const update: CameraUpdate = CameraUpdateFactory.newLatLngZoom(this.currentLatLng, 14);
    this.aMap.animateCamera(update);
  }

  // è¿”å›
  private goBack(): void {
    router.back();
  }

  // åˆ‡æ¢åœ°å›¾ç±»å‹
  private switchMapType(type: number): void {
    if (!this.aMap) return;
    this.currentMapType = type;
    switch (type) {
      case 0: // æ™®é€šåœ°å›?
        this.aMap.setMapType(MapType.MAP_TYPE_NORMAL);
        break;
      case 1: // å«æ˜Ÿåœ°å›¾
        this.aMap.setMapType(MapType.MAP_TYPE_SATELLITE);
        break;
      case 2: // å¤œé—´æ¨¡å¼
        this.aMap.setMapType(MapType.MAP_TYPE_NIGHT);
        break;
    }
    this.showMapTypePanel = false;
  }

  // è·å–åœ°å›¾ç±»å‹åç§°
  private getMapTypeName(): string {
    const names = ['æ™®é€?, 'å«æ˜Ÿ', 'å¤œé—´'];
    return names[this.currentMapType] || 'æ™®é€?;
  }

  // åˆ¤æ–­æ˜¯å¦ä¸ºæ°´åŸŸç›¸å…?
  private isWaterRelated(name: string): boolean {
    const excludeKeywords = ['å•æ‰€', 'å«ç”Ÿé—?, 'ç«é”…', 'é¤å…', 'é¥­åº—', 'è¶…å¸‚', 'å•†åœº', 'åŒ»é™¢', 'å­¦æ ¡',
      'åœè½¦åœ?, 'åŠ æ²¹ç«?, 'é“¶è¡Œ', 'è¯åº—', 'ç¾å®¹', 'ç¾å‘', 'é…’åº—', 'å®¾é¦†', 'å…¬å¸', 'åº?];
    for (const exclude of excludeKeywords) {
      if (name.includes(exclude)) return false;
    }

    const waterKeywords = ['å‚é’“', 'é’“åœº', 'é’“é±¼', 'æ¸”åœº', 'é±¼å¡˜', 'é±¼æ± ', 'é’“å›­',
      'æ±Ÿæ»©', 'æ²³æ»©', 'æ¹–æ»©', 'æ°´åº“', 'æ¹¿åœ°å…¬å›­', 'æ¹¿åœ°', 'æ¹?, 'æ²?, 'æ±?, 'æ½?, 'å¡?, 'æº?, 'æ¸?, 'æ¸¡å£'];
    for (const keyword of waterKeywords) {
      if (name.includes(keyword)) return true;
    }
    return false;
  }

  // æ£€æµ‹æ°´åŸŸç±»å?
  private detectWaterType(name: string): WaterType {
    if (name.includes('æ¹?) || name.includes('æ½?)) {
      return WaterType.LAKE;
    }
    if (name.includes('æ±?) || name.includes('æ²?) || name.includes('æº?) ||
        name.includes('æ¸?) || name.includes('ç å¤´') || name.includes('æ¸¡å£')) {
      return WaterType.RIVER;
    }
    if (name.includes('æ°´åº“')) {
      return WaterType.RESERVOIR;
    }
    return WaterType.POND;
  }

  // è·å–é’“ç‚¹æè¿°
  private getSpotDescription(type: WaterType): string {
    const descriptions: Record<string, string> = {
      [WaterType.POND]: 'é€‚åˆä¼‘é—²å‚é’“',
      [WaterType.RESERVOIR]: 'æ°´åŸŸå¼€é˜”ï¼Œé€‚åˆå®ˆé’“',
      [WaterType.RIVER]: 'æµæ°´é’“åœºï¼Œé±¼å£æ´»è·?,
      [WaterType.LAKE]: 'æ¹–æ³Šé’“åœºï¼Œé±¼ç§ä¸°å¯?
    };
    return descriptions[type] || 'é’“ç‚¹ç¯å¢ƒè‰¯å¥½';
  }

  // è®¡ç®—è·ç¦»
  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
    const R = 6371000;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLng / 2) * Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  // æ ¼å¼åŒ–è·ç¦?
  private formatDistance(meters: number): string {
    if (meters < 1000) return `${meters}ç±³`;
    return `${(meters / 1000).toFixed(1)}å…¬é‡Œ`;
  }

  // æ ¼å¼åŒ–è·¯çº¿è·ç¦?
  private formatRouteDistance(meters: number): string {
    if (meters < 1000) return `${meters}ç±³`;
    return `${(meters / 1000).toFixed(1)}å…¬é‡Œ`;
  }

  // æ ¼å¼åŒ–è·¯çº¿æ—¶é—?
  private formatRouteDuration(seconds: number): string {
    if (seconds < 60) return `${seconds}ç§’`;
    const minutes: number = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}åˆ†é’Ÿ`;
    const hours: number = Math.floor(minutes / 60);
    return `${hours}å°æ—¶${minutes % 60}åˆ†é’Ÿ`;
  }

  // ==================== è·¯çº¿è§„åˆ’åŠŸèƒ½ ====================

  // å¼€å§‹å¯¼èˆªåˆ°é’“ç‚¹
  private startNavigation(spot: FishingSpot): void {
    if (!this.currentLatLng) {
      this.routeInfo = 'è¯·å…ˆè·å–å½“å‰ä½ç½®';
      return;
    }
    
    this.selectedSpot = spot;
    this.showBaitDialog = false;
    this.showRoutePanel = true;
    this.searchRoute();
  }

  // æœç´¢è·¯çº¿
  private searchRoute(): void {
    if (!this.routeSearch || !this.currentLatLng || !this.selectedSpot) {
      console.error(this.TAG, 'æ— æ³•æœç´¢è·¯çº¿ï¼šå‚æ•°ä¸å®Œæ•´');
      console.error(this.TAG, `routeSearch=${!!this.routeSearch}, currentLatLng=${!!this.currentLatLng}, selectedSpot=${!!this.selectedSpot}`);
      this.routeInfo = 'å‚æ•°ä¸å®Œæ•´ï¼Œæ— æ³•è§„åˆ’è·¯çº¿';
      return;
    }

    this.isRouteSearching = true;
    this.routeInfo = 'æ­£åœ¨è§„åˆ’è·¯çº¿...';
    this.clearRouteLine();

    const startLat = this.currentLatLng.latitude;
    const startLng = this.currentLatLng.longitude;
    const endLat = this.selectedSpot.latitude;
    const endLng = this.selectedSpot.longitude;

    // è¯¦ç»†æ—¥å¿—
    console.info(this.TAG, '========== è·¯çº¿è§„åˆ’è°ƒè¯• ==========');
    console.info(this.TAG, `èµ·ç‚¹: lat=${startLat}, lng=${startLng}`);
    console.info(this.TAG, `ç»ˆç‚¹: lat=${endLat}, lng=${endLng}`);
    console.info(this.TAG, `é’“ç‚¹åç§°: ${this.selectedSpot.name}`);
    console.info(this.TAG, `å‡ºè¡Œæ–¹å¼: ${this.selectedRouteType}`);

    // åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºåæ ‡ä¿¡æ¯ç”¨äºè°ƒè¯•
    this.routeInfo = `èµ·ç‚¹:(${startLat.toFixed(4)},${startLng.toFixed(4)}) ç»ˆç‚¹:(${endLat.toFixed(4)},${endLng.toFixed(4)})`;

    // éªŒè¯åæ ‡æœ‰æ•ˆæ€?
    if (startLat === 0 || startLng === 0) {
      this.routeInfo = 'å½“å‰ä½ç½®æ— æ•ˆ(0,0)ï¼Œè¯·é‡æ–°å®šä½';
      this.isRouteSearching = false;
      console.error(this.TAG, 'èµ·ç‚¹åæ ‡ä¸?');
      return;
    }

    if (endLat === 0 || endLng === 0) {
      this.routeInfo = 'é’“ç‚¹ä½ç½®æ— æ•ˆ(0,0)';
      this.isRouteSearching = false;
      console.error(this.TAG, 'ç»ˆç‚¹åæ ‡ä¸?');
      return;
    }

    // æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨ä¸­å›½èŒƒå›´å†?(å¤§è‡´èŒƒå›´: çº¬åº¦3-54, ç»åº¦73-136)
    const isStartInChina = startLat >= 3 && startLat <= 54 && startLng >= 73 && startLng <= 136;
    const isEndInChina = endLat >= 3 && endLat <= 54 && endLng >= 73 && endLng <= 136;
    
    console.info(this.TAG, `èµ·ç‚¹åœ¨ä¸­å›½èŒƒå›? ${isStartInChina}, ç»ˆç‚¹åœ¨ä¸­å›½èŒƒå›? ${isEndInChina}`);

    if (!isStartInChina) {
      this.routeInfo = `èµ·ç‚¹ä¸åœ¨ä¸­å›½èŒƒå›´:(${startLat.toFixed(4)},${startLng.toFixed(4)})`;
      this.isRouteSearching = false;
      return;
    }

    if (!isEndInChina) {
      this.routeInfo = `ç»ˆç‚¹ä¸åœ¨ä¸­å›½èŒƒå›´:(${endLat.toFixed(4)},${endLng.toFixed(4)})`;
      this.isRouteSearching = false;
      return;
    }

    const startPoint: LatLonPoint = new LatLonPoint(startLat, startLng);
    const endPoint: LatLonPoint = new LatLonPoint(endLat, endLng);
    
    console.info(this.TAG, `LatLonPoint èµ·ç‚¹: ${startPoint.getLatitude()}, ${startPoint.getLongitude()}`);
    console.info(this.TAG, `LatLonPoint ç»ˆç‚¹: ${endPoint.getLatitude()}, ${endPoint.getLongitude()}`);
    
    const fromAndTo: FromAndTo = new FromAndTo(startPoint, endPoint);

    // æ·»åŠ èµ·ç»ˆç‚¹æ ‡è®?
    this.addRouteMarkers(startPoint, endPoint);

    console.info(this.TAG, `å¼€å§‹æœç´?{this.selectedRouteType}è·¯çº¿...`);
    this.routeInfo = `æœç´¢${this.selectedRouteType === 'drive' ? 'é©¾è½¦' : this.selectedRouteType === 'walk' ? 'æ­¥è¡Œ' : 'éª‘è¡Œ'}è·¯çº¿ä¸?..`;

    if (this.selectedRouteType === 'drive') {
      const query: DriveRouteQuery = new DriveRouteQuery(fromAndTo, RouteSearch.DrivingDefault, undefined, undefined, '');
      console.info(this.TAG, 'å‘èµ·é©¾è½¦è·¯çº¿æŸ¥è¯¢');
      this.routeSearch.calculateDriveRouteAsyn(query);
    } else if (this.selectedRouteType === 'walk') {
      const query: WalkRouteQuery = new WalkRouteQuery(fromAndTo);
      console.info(this.TAG, 'å‘èµ·æ­¥è¡Œè·¯çº¿æŸ¥è¯¢');
      this.routeSearch.calculateWalkRouteAsyn(query);
    } else {
      const query: RideRouteQuery = new RideRouteQuery(fromAndTo);
      console.info(this.TAG, 'å‘èµ·éª‘è¡Œè·¯çº¿æŸ¥è¯¢');
      this.routeSearch.calculateRideRouteAsyn(query);
    }
  }

  // æ·»åŠ èµ·ç»ˆç‚¹æ ‡è®?
  private addRouteMarkers(start: LatLonPoint, end: LatLonPoint): void {
    if (!this.aMap) return;

    // æ¸…é™¤æ—§æ ‡è®?
    if (this.startMarker) {
      this.startMarker.remove();
      this.startMarker = undefined;
    }
    if (this.endMarker) {
      this.endMarker.remove();
      this.endMarker = undefined;
    }

    // èµ·ç‚¹æ ‡è®° - ç»¿è‰²
    const startOptions: MarkerOptions = new MarkerOptions();
    startOptions.setPosition(new LatLng(start.getLatitude(), start.getLongitude()));
    startOptions.setTitle('èµ·ç‚¹');
    startOptions.setSnippet('æˆ‘çš„ä½ç½®');
    startOptions.setIcon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_GREEN));
    startOptions.setAnchor(0.5, 1.0);
    startOptions.setZIndex(200);
    this.startMarker = this.aMap.addMarker(startOptions);

    // ç»ˆç‚¹æ ‡è®° - çº¢è‰²
    const endOptions: MarkerOptions = new MarkerOptions();
    endOptions.setPosition(new LatLng(end.getLatitude(), end.getLongitude()));
    endOptions.setTitle('ç»ˆç‚¹');
    endOptions.setSnippet(this.selectedSpot?.name || 'é’“ç‚¹');
    endOptions.setIcon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED));
    endOptions.setAnchor(0.5, 1.0);
    endOptions.setZIndex(200);
    this.endMarker = this.aMap.addMarker(endOptions);
  }

  // ç»˜åˆ¶é©¾è½¦è·¯çº¿
  private drawDriveRoute(path: DrivePath): void {
    if (!this.aMap) return;

    const steps = path.getSteps();
    if (!steps) return;

    const pointList: ArrayList<LatLng> = new ArrayList<LatLng>();

    steps.forEach((step: DriveStep): void => {
      const polyline = step.getPolyline();
      if (polyline) {
        polyline.forEach((point: LatLonPoint): void => {
          pointList.add(new LatLng(point.getLatitude(), point.getLongitude()));
        });
      }
    });

    if (pointList.length > 0) {
      this.drawRoutePolyline(pointList, 0xFF4CAF50); // ç»¿è‰²
    }
  }

  // ç»˜åˆ¶æ­¥è¡Œè·¯çº¿
  private drawWalkRoute(path: WalkPath): void {
    if (!this.aMap) return;

    const steps = path.getSteps();
    if (!steps) return;

    const pointList: ArrayList<LatLng> = new ArrayList<LatLng>();

    steps.forEach((step: WalkStep): void => {
      const polyline = step.getPolyline();
      if (polyline) {
        polyline.forEach((point: LatLonPoint): void => {
          pointList.add(new LatLng(point.getLatitude(), point.getLongitude()));
        });
      }
    });

    if (pointList.length > 0) {
      this.drawRoutePolyline(pointList, 0xFF2196F3); // è“è‰²
    }
  }

  // ç»˜åˆ¶éª‘è¡Œè·¯çº¿
  private drawRideRoute(path: RidePath): void {
    if (!this.aMap) return;

    const steps = path.getSteps();
    if (!steps) return;

    const pointList: ArrayList<LatLng> = new ArrayList<LatLng>();

    steps.forEach((step: RideStep): void => {
      const polyline = step.getPolyline();
      if (polyline) {
        polyline.forEach((point: LatLonPoint): void => {
          pointList.add(new LatLng(point.getLatitude(), point.getLongitude()));
        });
      }
    });

    if (pointList.length > 0) {
      this.drawRoutePolyline(pointList, 0xFFFF9800); // æ©™è‰²
    }
  }

  // ç»˜åˆ¶è·¯çº¿æŠ˜çº¿
  private drawRoutePolyline(points: ArrayList<LatLng>, color: number): void {
    if (!this.aMap) return;

    this.clearRouteLine();

    const options: PolylineOptions = new PolylineOptions();
    options.setPoints(points);
    options.setWidth(14);
    options.setColor(color);
    this.routePolyline = this.aMap.addPolyline(options);

    // è°ƒæ•´è§†é‡æ˜¾ç¤ºæ•´æ¡è·¯çº¿
    this.fitRouteBounds(points);
  }

  // æ¸…é™¤è·¯çº¿
  private clearRouteLine(): void {
    if (this.routePolyline) {
      this.routePolyline.remove();
      this.routePolyline = undefined;
    }
  }

  // å…³é—­å¯¼èˆªé¢æ¿
  private closeRoutePanel(): void {
    this.showRoutePanel = false;
    this.clearRouteLine();
    
    // æ¸…é™¤èµ·ç»ˆç‚¹æ ‡è®?
    if (this.startMarker) {
      this.startMarker.remove();
      this.startMarker = undefined;
    }
    if (this.endMarker) {
      this.endMarker.remove();
      this.endMarker = undefined;
    }
    
    this.routeInfo = '';
    this.routeDistance = 0;
    this.routeDuration = 0;
  }

  // è°ƒæ•´åœ°å›¾è§†é‡ä»¥æ˜¾ç¤ºæ•´æ¡è·¯çº?
  private fitRouteBounds(points: ArrayList<LatLng>): void {
    if (!this.aMap || points.length === 0) return;

    let minLat: number = 90;
    let maxLat: number = -90;
    let minLng: number = 180;
    let maxLng: number = -180;

    points.forEach((point: LatLng): void => {
      minLat = Math.min(minLat, point.latitude);
      maxLat = Math.max(maxLat, point.latitude);
      minLng = Math.min(minLng, point.longitude);
      maxLng = Math.max(maxLng, point.longitude);
    });

    const bounds: LatLngBounds = new LatLngBounds(
      new LatLng(minLat, minLng),
      new LatLng(maxLat, maxLng)
    );

    const update: CameraUpdate = CameraUpdateFactory.newLatLngBounds(bounds, 100);
    this.aMap.animateCamera(update);
  }

  // æ¨èé…æ–¹ - ä½¿ç”¨çœŸå®é…æ–¹åº?
  private recommendRecipes(waterType: WaterType): Recipe[] {
    // æ°´åŸŸç±»å‹æ˜ å°„: pondâ†’æ± å¡? reservoirâ†’æ°´åº? riverâ†’æ²³æµ? lakeâ†’æ¹–æ³?
    const waterTypeMap: Record<string, string> = {
      [WaterType.POND]: 'æ± å¡˜',
      [WaterType.RESERVOIR]: 'æ°´åº“',
      [WaterType.RIVER]: 'æ²³æµ',
      [WaterType.LAKE]: 'æ¹–æ³Š'
    };
    
    const chineseWaterType = waterTypeMap[waterType] || 'æ± å¡˜';
    const recipeService = RecipeService.getInstance();
    const allRecipes = recipeService.getRecipesByWaterType(chineseWaterType);
    
    if (allRecipes.length === 0) {
      // å¦‚æœæ²¡æœ‰åŒ¹é…çš„é…æ–¹ï¼Œè¿”å›æ‰€æœ‰é…æ–¹ä¸­éšæœºå‡ ä¸ª
      const all = recipeService.getAllRecipes();
      const shuffled = [...all].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, 3);
    }
    
    // éšæœºé€‰æ‹©2-4ä¸ªé…æ–?
    const shuffled = [...allRecipes].sort(() => Math.random() - 0.5);
    const count = Math.min(Math.floor(Math.random() * 3) + 2, shuffled.length);
    return shuffled.slice(0, count);
  }

  // ==================== ç”¨æˆ·è‡ªå®šä¹‰æ‰“ç‚¹åŠŸèƒ?====================

  // åŠ è½½è‡ªå®šä¹‰æ ‡è®°å›¾æ ?
  private async loadCustomMarkerIcon(): Promise<void> {
    try {
      const context = getContext(this);
      // ä»?rawfile ç›®å½•åŠ è½½ hooks.png
      this.hooksIcon = await BitmapDescriptorFactory.fromRawfilePath(context, 'hooks.png');
      console.info(this.TAG, 'è‡ªå®šä¹‰æ ‡è®°å›¾æ ‡åŠ è½½æˆåŠ?);
    } catch (error) {
      console.error(this.TAG, `åŠ è½½è‡ªå®šä¹‰å›¾æ ‡å¤±è´? ${error}`);
    }
  }

  // å¼€å?å…³é—­æ‰“ç‚¹æ¨¡å¼
  private toggleAddSpotMode(): void {
    this.isAddingCustomSpot = !this.isAddingCustomSpot;
    if (this.isAddingCustomSpot) {
      this.currentLocation = 'ğŸ‘† ç‚¹å‡»åœ°å›¾é€‰æ‹©é’“ç‚¹ä½ç½®';
    } else {
      this.currentLocation = this.fishingSpots.length > 0 
        ? `å‘ç° ${this.fishingSpots.length} ä¸ªé’“ç‚¹` 
        : 'é™„è¿‘æš‚æ— é’“ç‚¹';
    }
  }

  // åœ°å›¾ç‚¹å‡»æ·»åŠ è‡ªå®šä¹‰é’“ç‚?
  private async onMapClickForCustomSpot(point: LatLng): Promise<void> {
    // æ£€æŸ¥é™„è¿?000ç±³å†…æ˜¯å¦å·²æœ‰é’“ç‚¹
    const nearbySpot = this.findNearbySpot(point, 1000);
    if (nearbySpot) {
      this.currentLocation = `é™„è¿‘å·²æœ‰é’“ç‚¹: ${nearbySpot.name}`;
      this.isAddingCustomSpot = false;
      // é«˜äº®æ˜¾ç¤ºé™„è¿‘çš„é’“ç‚?
      if (this.aMap) {
        const update: CameraUpdate = CameraUpdateFactory.newLatLngZoom(
          new LatLng(nearbySpot.latitude, nearbySpot.longitude), 15
        );
        this.aMap.animateCamera(update);
      }
      return;
    }

    // æ£€æŸ¥é™„è¿?000ç±³å†…æ˜¯å¦å·²æœ‰è‡ªå®šä¹‰é’“ç‚?
    const nearbyCustomSpot = this.findNearbyCustomSpot(point, 1000);
    if (nearbyCustomSpot) {
      this.currentLocation = `é™„è¿‘å·²æœ‰é’“ç‚¹: ${nearbyCustomSpot.name}`;
      this.isAddingCustomSpot = false;
      if (this.aMap) {
        const update: CameraUpdate = CameraUpdateFactory.newLatLngZoom(
          new LatLng(nearbyCustomSpot.latitude, nearbyCustomSpot.longitude), 15
        );
        this.aMap.animateCamera(update);
      }
      return;
    }

    this.pendingSpotLatLng = point;
    this.pendingSpotAddress = 'è·å–åœ°å€ä¸?..';
    
    // è·å–ç‚¹å‡»ä½ç½®çš„åœ°å€
    if (this.geocodeSearch) {
      try {
        const latLonPoint: LatLonPoint = new LatLonPoint(point.latitude, point.longitude);
        const query: ReGeocodeQuery = new ReGeocodeQuery(latLonPoint, 200, GeocodeSearch.AMAP);
        const address: ReGeocodeAddress | undefined = await this.geocodeSearch.getFromLocation(query);
        
        if (address) {
          const district = address.getDistrict() || '';
          const township = address.getTownship() || '';
          const street = address.getStreetNumber()?.getStreet() || '';
          this.pendingSpotAddress = `${district}${township}${street}`.trim() || 
            `${point.latitude.toFixed(4)}, ${point.longitude.toFixed(4)}`;
        } else {
          this.pendingSpotAddress = `${point.latitude.toFixed(4)}, ${point.longitude.toFixed(4)}`;
        }
      } catch (error) {
        this.pendingSpotAddress = `${point.latitude.toFixed(4)}, ${point.longitude.toFixed(4)}`;
      }
    }
    
    // é‡ç½®è¡¨å•
    this.customSpotName = '';
    this.customSpotNote = '';
    this.customSpotWaterType = WaterType.POND;
    
    // æ˜¾ç¤ºæ·»åŠ é’“ç‚¹å¼¹çª—
    this.showAddSpotDialog = true;
    this.isAddingCustomSpot = false;
    this.currentLocation = this.fishingSpots.length > 0 
      ? `å‘ç° ${this.fishingSpots.length} ä¸ªé’“ç‚¹` 
      : 'é™„è¿‘æš‚æ— é’“ç‚¹';
  }

  // æŸ¥æ‰¾é™„è¿‘çš„POIé’“ç‚¹
  private findNearbySpot(point: LatLng, radiusMeters: number): FishingSpot | null {
    for (const spot of this.fishingSpots) {
      const distance = this.calculateDistance(point.latitude, point.longitude, spot.latitude, spot.longitude);
      if (distance <= radiusMeters) {
        return spot;
      }
    }
    return null;
  }

  // æŸ¥æ‰¾é™„è¿‘çš„è‡ªå®šä¹‰é’“ç‚¹
  private findNearbyCustomSpot(point: LatLng, radiusMeters: number): UserCustomSpot | null {
    for (const spot of this.userCustomSpots) {
      const distance = this.calculateDistance(point.latitude, point.longitude, spot.latitude, spot.longitude);
      if (distance <= radiusMeters) {
        return spot;
      }
    }
    return null;
  }

  // ä¿å­˜è‡ªå®šä¹‰é’“ç‚?
  private saveCustomSpot(): void {
    if (!this.pendingSpotLatLng) return;
    
    const newSpot: UserCustomSpot = {
      id: `custom_${Date.now()}`,
      name: this.customSpotName || `æˆ‘çš„é’“ç‚¹${this.userCustomSpots.length + 1}`,
      latitude: this.pendingSpotLatLng.latitude,
      longitude: this.pendingSpotLatLng.longitude,
      note: this.customSpotNote,
      createTime: Date.now(),
      waterType: this.customSpotWaterType
    };
    
    this.userCustomSpots.push(newSpot);
    this.addCustomSpotMarker(newSpot);
    
    // å…³é—­å¼¹çª—
    this.showAddSpotDialog = false;
    this.pendingSpotLatLng = undefined;
    
    console.info(this.TAG, `ä¿å­˜è‡ªå®šä¹‰é’“ç‚? ${newSpot.name}`);
  }

  // æ·»åŠ è‡ªå®šä¹‰é’“ç‚¹æ ‡è®?
  private addCustomSpotMarker(spot: UserCustomSpot): void {
    if (!this.aMap) return;
    
    const options: MarkerOptions = new MarkerOptions();
    options.setPosition(new LatLng(spot.latitude, spot.longitude));
    options.setTitle(`ğŸ£ ${spot.name}`);
    options.setSnippet(spot.note || WaterTypeNames[spot.waterType]);
    
    // ä½¿ç”¨ hooks.png å›¾æ ‡
    if (this.hooksIcon) {
      options.setIcon(this.hooksIcon);
    } else {
      // å¤‡ç”¨ï¼šä½¿ç”¨ç´«è‰²æ ‡è®?
      options.setIcon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_VIOLET));
    }
    options.setAnchor(0.5, 1.0);
    options.setZIndex(100);
    
    const marker = this.aMap.addMarker(options);
    if (marker) {
      this.customSpotMarkers.push(marker);
    }
  }

  // åˆ·æ–°æ‰€æœ‰è‡ªå®šä¹‰é’“ç‚¹æ ‡è®°
  private refreshCustomSpotMarkers(): void {
    // æ¸…é™¤ç°æœ‰æ ‡è®°
    for (const marker of this.customSpotMarkers) {
      marker.remove();
    }
    this.customSpotMarkers = [];
    
    // é‡æ–°æ·»åŠ 
    for (const spot of this.userCustomSpots) {
      this.addCustomSpotMarker(spot);
    }
  }

  // åˆ é™¤è‡ªå®šä¹‰é’“ç‚?
  private deleteCustomSpot(spotId: string): void {
    const index = this.userCustomSpots.findIndex(s => s.id === spotId);
    if (index > -1) {
      this.userCustomSpots.splice(index, 1);
      this.refreshCustomSpotMarkers();
      this.showCustomSpotDetail = false;
      this.selectedCustomSpot = null;
    }
  }

  // ç‚¹å‡»è‡ªå®šä¹‰é’“ç‚?
  private onCustomSpotClick(spot: UserCustomSpot): void {
    this.selectedCustomSpot = spot;
    this.showCustomSpotDetail = true;
    
    // ç§»åŠ¨åœ°å›¾åˆ°è¯¥ä½ç½®
    if (this.aMap) {
      const update: CameraUpdate = CameraUpdateFactory.newLatLngZoom(
        new LatLng(spot.latitude, spot.longitude), 15
      );
      this.aMap.animateCamera(update);
    }
  }

  // æ ¼å¼åŒ–æ—¶é—?
  private formatTime(timestamp: number): string {
    const date = new Date(timestamp);
    return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
  }

  build() {
    Stack() {
      Column() {
        // é¡¶éƒ¨å¯¼èˆªæ ?
        Row() {
          Image($r('app.media.Left'))
            .width(24)
            .height(24)
            .onClick(() => this.goBack())

          Text('é’“ç‚¹åœ°å›¾')
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor(ThemeColors.TEXT_PRIMARY)
            .layoutWeight(1)
            .textAlign(TextAlign.Center)

          // æˆ‘çš„é’“ç‚¹åˆ—è¡¨æŒ‰é’®
          Text('ğŸ“‹')
            .fontSize(20)
            .margin({ right: 12 })
            .onClick(() => { this.showMySpotsList = true })

          Text('ğŸ“')
            .fontSize(20)
            .onClick(() => this.moveToCurrentLocation())
        }
        .width('100%')
        .height(56)
        .padding({ left: 16, right: 16 })
        .margin({ top: 44 })
        .backgroundColor(ThemeColors.BG_SECONDARY)

        // çŠ¶æ€æç¤?
        Row() {
          Text(this.currentLocation)
            .fontSize(12)
            .fontColor(ThemeColors.TEXT_SECONDARY)
          if (this.isSearching) {
            LoadingProgress()
              .width(16)
              .height(16)
              .margin({ left: 8 })
          }
          Blank()
          Text('ğŸ”„')
            .fontSize(16)
            .onClick(() => this.refreshLocation())
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 8, bottom: 8 })
        .backgroundColor(ThemeColors.BG_PRIMARY)

        // ç‚¹å‡»ä½ç½®åç§°æ˜¾ç¤º
        if (this.clickedLocationName) {
          Row() {
            Text('ğŸ“ ç‚¹å‡»ä½ç½®: ')
              .fontSize(12)
              .fontColor(ThemeColors.TEXT_SECONDARY)
            Text(this.clickedLocationName)
              .fontSize(12)
              .fontColor(ThemeColors.PRIMARY_DARK)
              .fontWeight(FontWeight.Medium)
              .layoutWeight(1)
            Text('âœ?)
              .fontSize(14)
              .fontColor(ThemeColors.TEXT_SECONDARY)
              .onClick(() => { this.clickedLocationName = '' })
          }
          .width('100%')
          .padding({ left: 16, right: 16, top: 6, bottom: 6 })
          .backgroundColor('#E3F2FD')
        }

        // é«˜å¾·åœ°å›¾
        Stack() {
          MapViewComponent({ mapViewName: MAP_VIEW_NAME })
            .width('100%')
            .height('100%')

          if (!this.isMapReady) {
            Column() {
              LoadingProgress().width(48).height(48).color(ThemeColors.PRIMARY)
              Text('åœ°å›¾åŠ è½½ä¸?..').fontSize(14).fontColor(ThemeColors.TEXT_SECONDARY).margin({ top: 12 })
            }
            .width('100%')
            .height('100%')
            .justifyContent(FlexAlign.Center)
            .backgroundColor(ThemeColors.BG_PRIMARY)
          }

          // åœ°å›¾ç±»å‹åˆ‡æ¢æŒ‰é’®
          if (this.isMapReady) {
            Column() {
              Text('ğŸ—ºï¸?)
                .fontSize(20)
                .padding(10)
                .backgroundColor('rgba(255,255,255,0.95)')
                .borderRadius(8)
                .shadow({ radius: 4, color: 'rgba(0,0,0,0.15)' })
                .onClick(() => { this.showMapTypePanel = !this.showMapTypePanel })
            }
            .position({ x: 16, y: 16 })

            // æ·»åŠ é’“ç‚¹æŒ‰é’®
            Column() {
              Row() {
                Image($r('app.media.hooks'))
                  .width(24)
                  .height(24)
                Text(this.isAddingCustomSpot ? 'å–æ¶ˆ' : 'æ‰“ç‚¹')
                  .fontSize(13)
                  .fontColor(this.isAddingCustomSpot ? '#F44336' : ThemeColors.PRIMARY)
                  .margin({ left: 4 })
              }
              .padding({ left: 12, right: 12, top: 8, bottom: 8 })
              .backgroundColor(this.isAddingCustomSpot ? '#FFEBEE' : 'rgba(255,255,255,0.95)')
              .borderRadius(20)
              .shadow({ radius: 4, color: 'rgba(0,0,0,0.15)' })
              .onClick(() => this.toggleAddSpotMode())
            }
            .position({ x: 16, y: 70 })
          }

          // åœ°å›¾ç±»å‹é€‰æ‹©é¢æ¿
          if (this.showMapTypePanel) {
            Column({ space: 8 }) {
              this.MapTypeButton('ğŸ—ºï¸?, 'æ™®é€?, 0)
              this.MapTypeButton('ğŸ›°ï¸?, 'å«æ˜Ÿ', 1)
              this.MapTypeButton('ğŸŒ™', 'å¤œé—´', 2)
            }
            .padding(12)
            .backgroundColor('rgba(255,255,255,0.98)')
            .borderRadius(12)
            .shadow({ radius: 8, color: 'rgba(0,0,0,0.2)' })
            .position({ x: 16, y: 120 })
          }
        }
        .layoutWeight(1)
        .width('100%')
      }
      .width('100%')
      .height('100%')

      // é¥µæ–™æ¨èå¼¹çª—
      if (this.showBaitDialog && this.selectedSpot) {
        this.BaitRecommendDialog()
      }

      // æ·»åŠ è‡ªå®šä¹‰é’“ç‚¹å¼¹çª?
      if (this.showAddSpotDialog) {
        this.AddCustomSpotDialog()
      }

      // è‡ªå®šä¹‰é’“ç‚¹è¯¦æƒ…å¼¹çª?
      if (this.showCustomSpotDetail && this.selectedCustomSpot) {
        this.CustomSpotDetailDialog()
      }

      // æˆ‘çš„é’“ç‚¹åˆ—è¡¨å¼¹çª—
      if (this.showMySpotsList) {
        this.MySpotListDialog()
      }

      // è·¯çº¿è§„åˆ’é¢æ¿
      if (this.showRoutePanel) {
        this.RoutePlanPanel()
      }
    }
    .width('100%')
    .height('100%')
  }

  // è·¯çº¿è§„åˆ’é¢æ¿
  @Builder
  RoutePlanPanel() {
    Column() {
      // é¡¶éƒ¨ä¿¡æ¯æ ?
      Row() {
        Column() {
          Text(this.selectedSpot?.name || 'é’“ç‚¹')
            .fontSize(16)
            .fontWeight(FontWeight.Bold)
            .fontColor(ThemeColors.TEXT_PRIMARY)
          if (this.routeInfo) {
            Text(this.routeInfo)
              .fontSize(13)
              .fontColor(ThemeColors.PRIMARY_DARK)
              .margin({ top: 4 })
          }
        }
        .alignItems(HorizontalAlign.Start)
        .layoutWeight(1)

        Text('âœ?)
          .fontSize(22)
          .fontColor(ThemeColors.TEXT_SECONDARY)
          .padding(8)
          .onClick(() => this.closeRoutePanel())
      }
      .width('100%')
      .padding({ left: 16, right: 16, top: 12, bottom: 12 })
      .backgroundColor(ThemeColors.BG_PRIMARY)

      // å‡ºè¡Œæ–¹å¼é€‰æ‹©
      Row({ space: 12 }) {
        this.RouteTypeButton('ğŸš—', 'é©¾è½¦', 'drive')
        this.RouteTypeButton('ğŸš¶', 'æ­¥è¡Œ', 'walk')
        this.RouteTypeButton('ğŸš´', 'éª‘è¡Œ', 'ride')
      }
      .width('100%')
      .padding({ left: 16, right: 16, top: 8, bottom: 12 })
      .backgroundColor(ThemeColors.BG_PRIMARY)
      .justifyContent(FlexAlign.Center)

      // è·¯çº¿ä¿¡æ¯
      if (this.routeDistance > 0) {
        Row() {
          Column() {
            Text(this.formatRouteDistance(this.routeDistance))
              .fontSize(20)
              .fontWeight(FontWeight.Bold)
              .fontColor(ThemeColors.PRIMARY_DARK)
            Text('æ€»è·ç¦?)
              .fontSize(12)
              .fontColor(ThemeColors.TEXT_SECONDARY)
          }
          .layoutWeight(1)

          Column() {
            Text(this.formatRouteDuration(this.routeDuration))
              .fontSize(20)
              .fontWeight(FontWeight.Bold)
              .fontColor(ThemeColors.PRIMARY_DARK)
            Text('é¢„è®¡æ—¶é—´')
              .fontSize(12)
              .fontColor(ThemeColors.TEXT_SECONDARY)
          }
          .layoutWeight(1)
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 16, bottom: 24 })
        .backgroundColor('#E8F5E9')
      }

      // åŠ è½½ä¸­æç¤?
      if (this.isRouteSearching) {
        Row() {
          LoadingProgress()
            .width(20)
            .height(20)
            .color(ThemeColors.PRIMARY)
          Text('æ­£åœ¨è§„åˆ’è·¯çº¿...')
            .fontSize(13)
            .fontColor(ThemeColors.TEXT_SECONDARY)
            .margin({ left: 8 })
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 12, bottom: 24 })
        .justifyContent(FlexAlign.Center)
      }
    }
    .width('100%')
    .backgroundColor(ThemeColors.BG_PRIMARY)
    .shadow({ radius: 8, color: 'rgba(0,0,0,0.15)', offsetY: -2 })
    .position({ x: 0, y: '100%' })
    .translate({ y: -260 })
  }

  @Builder
  RouteTypeButton(icon: string, label: string, type: RouteType) {
    Column() {
      Text(icon).fontSize(24)
      Text(label)
        .fontSize(12)
        .fontColor(this.selectedRouteType === type ? ThemeColors.PRIMARY : ThemeColors.TEXT_SECONDARY)
        .margin({ top: 4 })
    }
    .padding(12)
    .backgroundColor(this.selectedRouteType === type ? 'rgba(232, 168, 73, 0.15)' : ThemeColors.BG_SECONDARY)
    .borderRadius(8)
    .border({
      width: this.selectedRouteType === type ? 1 : 0,
      color: ThemeColors.PRIMARY
    })
    .onClick(() => {
      if (this.selectedRouteType !== type) {
        this.selectedRouteType = type;
        this.searchRoute();
      }
    })
  }

  @Builder
  MapTypeButton(icon: string, label: string, type: number) {
    Row() {
      Text(icon)
        .fontSize(18)
        .margin({ right: 8 })
      Text(label)
        .fontSize(14)
        .fontColor(this.currentMapType === type ? ThemeColors.PRIMARY : ThemeColors.TEXT_PRIMARY)
        .fontWeight(this.currentMapType === type ? FontWeight.Bold : FontWeight.Normal)
      if (this.currentMapType === type) {
        Text('âœ?)
          .fontSize(14)
          .fontColor(ThemeColors.PRIMARY_DARK)
          .margin({ left: 8 })
      }
    }
    .width(100)
    .height(40)
    .padding({ left: 12, right: 12 })
    .backgroundColor(this.currentMapType === type ? '#E3F2FD' : '#f5f5f5')
    .borderRadius(8)
    .onClick(() => this.switchMapType(type))
  }

  @Builder
  BaitRecommendDialog() {
    Stack() {
      // é®ç½©
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor('rgba(0,0,0,0.5)')
        .onClick(() => { this.showBaitDialog = false })

      // å¼¹çª—å†…å®¹
      Column() {
        // æ ‡é¢˜
        Row() {
          Image(WaterTypeImages[this.selectedSpot!.waterType].active)
            .width(24)
            .height(24)
            .margin({ right: 8 })
          Text(this.selectedSpot!.name)
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor(ThemeColors.TEXT_PRIMARY)
            .layoutWeight(1)
          Text('âœ?)
            .fontSize(20)
            .fontColor(ThemeColors.TEXT_SECONDARY)
            .onClick(() => { this.showBaitDialog = false })
        }
        .width('100%')
        .margin({ bottom: 8 })

        Text(`${WaterTypeNames[this.selectedSpot!.waterType]} Â· ${this.selectedSpot!.description}`)
          .fontSize(13)
          .fontColor(ThemeColors.TEXT_SECONDARY)
          .margin({ bottom: 8 })

        if (this.selectedSpot!.distance) {
          Text(`è·æ‚¨ ${this.formatDistance(this.selectedSpot!.distance)}`)
            .fontSize(12)
            .fontColor(ThemeColors.PRIMARY_DARK)
            .margin({ bottom: 16 })
        }

        Divider().color('#eee').margin({ bottom: 16 })

        Text('ğŸ£ æ¨èé…æ–¹')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
          .fontColor(ThemeColors.TEXT_PRIMARY)
          .margin({ bottom: 12 })

        // é…æ–¹åˆ—è¡¨ - å¯æ»šåŠ?
        Scroll() {
          Column({ space: 12 }) {
            ForEach(this.recommendedRecipes, (recipe: Recipe) => {
              Column() {
                // é…æ–¹åç§°å’Œè¯„åˆ?
                Row() {
                  Text(recipe.name)
                    .fontSize(15)
                    .fontWeight(FontWeight.Bold)
                    .fontColor(ThemeColors.TEXT_PRIMARY)
                    .layoutWeight(1)
                  Row() {
                    Text('â­?)
                      .fontSize(12)
                    Text(recipe.rating.toFixed(1))
                      .fontSize(12)
                      .fontColor('#FF9800')
                      .fontWeight(FontWeight.Medium)
                  }
                }
                .width('100%')
                .margin({ bottom: 6 })

                // ç›®æ ‡é±¼ç§å’Œéš¾åº?
                Row() {
                  Text(`ğŸŸ ${recipe.targetFish.join('ã€?)}`)
                    .fontSize(11)
                    .fontColor(ThemeColors.PRIMARY_DARK)
                  Blank()
                  Text(`éš¾åº¦: ${recipe.difficulty}`)
                    .fontSize(11)
                    .fontColor('#999')
                  Text(` Â· ${recipe.prepTime}`)
                    .fontSize(11)
                    .fontColor('#999')
                }
                .width('100%')
                .margin({ bottom: 8 })

                // ææ–™
                Text('ğŸ“¦ ææ–™:')
                  .fontSize(12)
                  .fontWeight(FontWeight.Medium)
                  .fontColor(ThemeColors.TEXT_PRIMARY)
                  .margin({ bottom: 4 })
                Text(recipe.ingredients.map(i => `${i.name}${i.amount}${i.unit}`).join('ã€?))
                  .fontSize(11)
                  .fontColor(ThemeColors.TEXT_SECONDARY)
                  .maxLines(2)
                  .textOverflow({ overflow: TextOverflow.Ellipsis })
                  .margin({ bottom: 8 })

                // æ­¥éª¤æ‘˜è¦
                Text('ğŸ“ æ­¥éª¤:')
                  .fontSize(12)
                  .fontWeight(FontWeight.Medium)
                  .fontColor(ThemeColors.TEXT_PRIMARY)
                  .margin({ bottom: 4 })
                Text(recipe.steps.slice(0, 2).join(' â†?') + (recipe.steps.length > 2 ? '...' : ''))
                  .fontSize(11)
                  .fontColor(ThemeColors.TEXT_SECONDARY)
                  .maxLines(2)
                  .textOverflow({ overflow: TextOverflow.Ellipsis })
                  .margin({ bottom: 8 })

                // å°è´´å£?
                if (recipe.tips.length > 0) {
                  Text('ğŸ’¡ ' + recipe.tips[0])
                    .fontSize(11)
                    .fontColor('#FF9800')
                    .fontStyle(FontStyle.Italic)
                    .maxLines(1)
                    .textOverflow({ overflow: TextOverflow.Ellipsis })
                }

                // å­£èŠ‚æ ‡ç­¾
                Row({ space: 4 }) {
                  ForEach(recipe.seasons, (season: string) => {
                    Text(season)
                      .fontSize(10)
                      .fontColor('#666')
                      .padding({ left: 6, right: 6, top: 2, bottom: 2 })
                      .backgroundColor('#f0f0f0')
                      .borderRadius(4)
                  })
                }
                .width('100%')
                .margin({ top: 8 })
              }
              .width('100%')
              .padding(12)
              .backgroundColor(ThemeColors.BG_SECONDARY)
              .borderRadius(10)
            })
          }
        }
        .height(320)
        .scrollBar(BarState.Auto)

        Button('æ¢ä¸€æ‰¹æ¨è?)
          .width('100%')
          .height(44)
          .fontSize(14)
          .backgroundColor(ThemeColors.PRIMARY)
          .fontColor(Color.White)
          .margin({ top: 12 })
          .onClick(() => {
            this.recommendedRecipes = this.recommendRecipes(this.selectedSpot!.waterType);
          })

        // å¯¼èˆªæŒ‰é’®
        Button('ğŸ§­ å¯¼èˆªå‰å¾€')
          .width('100%')
          .height(44)
          .fontSize(14)
          .backgroundColor('#4CAF50')
          .fontColor(Color.White)
          .margin({ top: 8 })
          .onClick(() => {
            this.startNavigation(this.selectedSpot!);
          })
      }
      .width('90%')
      .padding(20)
      .backgroundColor(ThemeColors.BG_PRIMARY)
      .borderRadius(16)
    }
    .width('100%')
    .height('100%')
    .position({ x: 0, y: 0 })
  }

  // æ·»åŠ è‡ªå®šä¹‰é’“ç‚¹å¼¹çª?
  @Builder
  AddCustomSpotDialog() {
    Stack() {
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor('rgba(0,0,0,0.5)')
        .onClick(() => { this.showAddSpotDialog = false })

      Column() {
        // æ ‡é¢˜
        Row() {
          Image($r('app.media.hooks'))
            .width(24)
            .height(24)
          Text('æ·»åŠ æˆ‘çš„é’“ç‚¹')
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor(ThemeColors.TEXT_PRIMARY)
            .margin({ left: 8 })
            .layoutWeight(1)
          Text('âœ?)
            .fontSize(20)
            .fontColor(ThemeColors.TEXT_SECONDARY)
            .onClick(() => { this.showAddSpotDialog = false })
        }
        .width('100%')
        .margin({ bottom: 16 })

        // ä½ç½®ä¿¡æ¯
        Row() {
          Text('ğŸ“')
            .fontSize(16)
          Text(this.pendingSpotAddress)
            .fontSize(13)
            .fontColor(ThemeColors.TEXT_SECONDARY)
            .margin({ left: 8 })
            .layoutWeight(1)
        }
        .width('100%')
        .padding(12)
        .backgroundColor('#f5f5f5')
        .borderRadius(8)
        .margin({ bottom: 16 })

        // é’“ç‚¹åç§°
        Text('é’“ç‚¹åç§°')
          .fontSize(14)
          .fontColor(ThemeColors.TEXT_PRIMARY)
          .fontWeight(FontWeight.Medium)
          .margin({ bottom: 8 })
        TextInput({ placeholder: 'ç»™è¿™ä¸ªé’“ç‚¹èµ·ä¸ªåå­?, text: this.customSpotName })
          .width('100%')
          .height(44)
          .fontSize(14)
          .backgroundColor('#f5f5f5')
          .borderRadius(8)
          .padding({ left: 12, right: 12 })
          .onChange((value: string) => { this.customSpotName = value })
          .margin({ bottom: 16 })

        // æ°´åŸŸç±»å‹é€‰æ‹©
        Text('æ°´åŸŸç±»å‹')
          .fontSize(14)
          .fontColor(ThemeColors.TEXT_PRIMARY)
          .fontWeight(FontWeight.Medium)
          .margin({ bottom: 8 })
        Row({ space: 8 }) {
          this.WaterTypeChip(WaterType.POND, 'æ± å¡˜', $r('app.media.Pond'), $r('app.media.Ponds'))
          this.WaterTypeChip(WaterType.RESERVOIR, 'æ°´åº“', $r('app.media.Reservoir'), $r('app.media.Reservoirs'))
          this.WaterTypeChip(WaterType.RIVER, 'æ²³æµ', $r('app.media.River'), $r('app.media.Rivers'))
          this.WaterTypeChip(WaterType.LAKE, 'æ¹–æ³Š', $r('app.media.Lake'), $r('app.media.Lakes'))
        }
        .width('100%')
        .margin({ bottom: 16 })

        // å¤‡æ³¨
        Text('å¤‡æ³¨ä¿¡æ¯')
          .fontSize(14)
          .fontColor(ThemeColors.TEXT_PRIMARY)
          .fontWeight(FontWeight.Medium)
          .margin({ bottom: 8 })
        TextArea({ placeholder: 'è®°å½•é±¼æƒ…ã€é’“ä½ã€æ”¶è´¹ç­‰ä¿¡æ¯...', text: this.customSpotNote })
          .width('100%')
          .height(80)
          .fontSize(14)
          .backgroundColor('#f5f5f5')
          .borderRadius(8)
          .padding(12)
          .onChange((value: string) => { this.customSpotNote = value })
          .margin({ bottom: 20 })

        // ä¿å­˜æŒ‰é’®
        Button('ä¿å­˜é’“ç‚¹')
          .width('100%')
          .height(48)
          .fontSize(16)
          .backgroundColor(ThemeColors.PRIMARY)
          .fontColor(Color.White)
          .onClick(() => this.saveCustomSpot())
      }
      .width('90%')
      .padding(20)
      .backgroundColor(ThemeColors.BG_PRIMARY)
      .borderRadius(16)
    }
    .width('100%')
    .height('100%')
    .position({ x: 0, y: 0 })
  }

  @Builder
  WaterTypeChip(type: WaterType, label: string, normalIcon: Resource, activeIcon: Resource) {
    Row() {
      Image(this.customSpotWaterType === type ? activeIcon : normalIcon)
        .width(18)
        .height(18)
        .margin({ right: 4 })
      Text(label)
        .fontSize(12)
        .fontColor(this.customSpotWaterType === type ? Color.White : ThemeColors.TEXT_PRIMARY)
    }
    .padding({ left: 8, right: 10, top: 6, bottom: 6 })
    .backgroundColor(this.customSpotWaterType === type ? ThemeColors.PRIMARY : '#f0f0f0')
    .borderRadius(16)
    .onClick(() => { this.customSpotWaterType = type })
  }

  // è‡ªå®šä¹‰é’“ç‚¹è¯¦æƒ…å¼¹çª?
  @Builder
  CustomSpotDetailDialog() {
    Stack() {
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor('rgba(0,0,0,0.5)')
        .onClick(() => { this.showCustomSpotDetail = false })

      Column() {
        // æ ‡é¢˜
        Row() {
          Image($r('app.media.hooks'))
            .width(28)
            .height(28)
          Text(this.selectedCustomSpot!.name)
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor(ThemeColors.TEXT_PRIMARY)
            .margin({ left: 8 })
            .layoutWeight(1)
          Text('âœ?)
            .fontSize(20)
            .fontColor(ThemeColors.TEXT_SECONDARY)
            .onClick(() => { this.showCustomSpotDetail = false })
        }
        .width('100%')
        .margin({ bottom: 16 })

        // æ°´åŸŸç±»å‹
        Row() {
          Image(WaterTypeImages[this.selectedCustomSpot!.waterType].active)
            .width(20)
            .height(20)
          Text(WaterTypeNames[this.selectedCustomSpot!.waterType])
            .fontSize(14)
            .fontColor(ThemeColors.PRIMARY_DARK)
            .margin({ left: 6 })
        }
        .margin({ bottom: 12 })

        // åæ ‡
        Row() {
          Text('ğŸ“ åæ ‡: ')
            .fontSize(13)
            .fontColor(ThemeColors.TEXT_SECONDARY)
          Text(`${this.selectedCustomSpot!.latitude.toFixed(6)}, ${this.selectedCustomSpot!.longitude.toFixed(6)}`)
            .fontSize(13)
            .fontColor(ThemeColors.TEXT_PRIMARY)
        }
        .width('100%')
        .margin({ bottom: 8 })

        // åˆ›å»ºæ—¶é—´
        Row() {
          Text('ğŸ• æ·»åŠ æ—¶é—´: ')
            .fontSize(13)
            .fontColor(ThemeColors.TEXT_SECONDARY)
          Text(this.formatTime(this.selectedCustomSpot!.createTime))
            .fontSize(13)
            .fontColor(ThemeColors.TEXT_PRIMARY)
        }
        .width('100%')
        .margin({ bottom: 16 })

        // å¤‡æ³¨
        if (this.selectedCustomSpot!.note) {
          Text('ğŸ“ å¤‡æ³¨')
            .fontSize(14)
            .fontWeight(FontWeight.Medium)
            .fontColor(ThemeColors.TEXT_PRIMARY)
            .margin({ bottom: 8 })
          Text(this.selectedCustomSpot!.note)
            .fontSize(14)
            .fontColor(ThemeColors.TEXT_SECONDARY)
            .width('100%')
            .padding(12)
            .backgroundColor('#f5f5f5')
            .borderRadius(8)
            .margin({ bottom: 16 })
        }

        Divider().color('#eee').margin({ bottom: 16 })

        // æ“ä½œæŒ‰é’®
        Row({ space: 12 }) {
          Button('æŸ¥çœ‹é…æ–¹æ¨è')
            .layoutWeight(1)
            .height(44)
            .fontSize(14)
            .backgroundColor(ThemeColors.PRIMARY)
            .fontColor(Color.White)
            .onClick(() => {
              // è½¬æ¢ä¸?FishingSpot æ ¼å¼å¹¶æ˜¾ç¤ºé…æ–?
              const spot: FishingSpot = {
                id: this.selectedCustomSpot!.id,
                name: this.selectedCustomSpot!.name,
                latitude: this.selectedCustomSpot!.latitude,
                longitude: this.selectedCustomSpot!.longitude,
                waterType: this.selectedCustomSpot!.waterType,
                description: this.selectedCustomSpot!.note || WaterTypeNames[this.selectedCustomSpot!.waterType]
              };
              this.selectedSpot = spot;
              this.recommendedRecipes = this.recommendRecipes(spot.waterType);
              this.showCustomSpotDetail = false;
              this.showBaitDialog = true;
            })

          Button('åˆ é™¤')
            .width(80)
            .height(44)
            .fontSize(14)
            .backgroundColor('#FFEBEE')
            .fontColor('#F44336')
            .onClick(() => {
              this.deleteCustomSpot(this.selectedCustomSpot!.id);
            })
        }
        .width('100%')
      }
      .width('90%')
      .padding(20)
      .backgroundColor(ThemeColors.BG_PRIMARY)
      .borderRadius(16)
    }
    .width('100%')
    .height('100%')
    .position({ x: 0, y: 0 })
  }

  // æˆ‘çš„é’“ç‚¹åˆ—è¡¨å¼¹çª—
  @Builder
  MySpotListDialog() {
    Stack() {
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor('rgba(0,0,0,0.5)')
        .onClick(() => { this.showMySpotsList = false })

      Column() {
        // æ ‡é¢˜
        Row() {
          Image($r('app.media.hooks'))
            .width(24)
            .height(24)
          Text('æˆ‘çš„é’“ç‚¹')
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor(ThemeColors.TEXT_PRIMARY)
            .margin({ left: 8 })
            .layoutWeight(1)
          Text(`å…?${this.userCustomSpots.length} ä¸ª`)
            .fontSize(13)
            .fontColor(ThemeColors.TEXT_SECONDARY)
            .margin({ right: 12 })
          Text('âœ?)
            .fontSize(20)
            .fontColor(ThemeColors.TEXT_SECONDARY)
            .onClick(() => { this.showMySpotsList = false })
        }
        .width('100%')
        .margin({ bottom: 16 })

        if (this.userCustomSpots.length === 0) {
          // ç©ºçŠ¶æ€?
          Column() {
            Text('ğŸ£')
              .fontSize(48)
              .margin({ bottom: 12 })
            Text('è¿˜æ²¡æœ‰æ·»åŠ é’“ç‚?)
              .fontSize(15)
              .fontColor(ThemeColors.TEXT_SECONDARY)
            Text('ç‚¹å‡»åœ°å›¾ä¸Šçš„"æ‰“ç‚¹"æŒ‰é’®æ·»åŠ ')
              .fontSize(13)
              .fontColor('#999')
              .margin({ top: 8 })
          }
          .width('100%')
          .height(200)
          .justifyContent(FlexAlign.Center)
        } else {
          // é’“ç‚¹åˆ—è¡¨
          Scroll() {
            Column({ space: 10 }) {
              ForEach(this.userCustomSpots, (spot: UserCustomSpot) => {
                Row() {
                  Image($r('app.media.hooks'))
                    .width(36)
                    .height(36)
                    .margin({ right: 12 })

                  Column() {
                    Text(spot.name)
                      .fontSize(15)
                      .fontWeight(FontWeight.Medium)
                      .fontColor(ThemeColors.TEXT_PRIMARY)
                    Row() {
                      Image(WaterTypeImages[spot.waterType].normal)
                        .width(14)
                        .height(14)
                      Text(WaterTypeNames[spot.waterType])
                        .fontSize(12)
                        .fontColor(ThemeColors.TEXT_SECONDARY)
                        .margin({ left: 4 })
                      if (spot.note) {
                        Text(' Â· ')
                          .fontSize(12)
                          .fontColor('#ccc')
                        Text(spot.note)
                          .fontSize(12)
                          .fontColor(ThemeColors.TEXT_SECONDARY)
                          .maxLines(1)
                          .textOverflow({ overflow: TextOverflow.Ellipsis })
                          .layoutWeight(1)
                      }
                    }
                    .margin({ top: 4 })
                  }
                  .alignItems(HorizontalAlign.Start)
                  .layoutWeight(1)

                  Text('â€?)
                    .fontSize(20)
                    .fontColor('#ccc')
                }
                .width('100%')
                .padding(12)
                .backgroundColor(ThemeColors.BG_SECONDARY)
                .borderRadius(10)
                .onClick(() => {
                  this.showMySpotsList = false;
                  this.onCustomSpotClick(spot);
                })
              })
            }
          }
          .height(300)
          .scrollBar(BarState.Auto)
        }

        // æ·»åŠ é’“ç‚¹æŒ‰é’®
        Button('+ æ·»åŠ æ–°é’“ç‚?)
          .width('100%')
          .height(48)
          .fontSize(15)
          .backgroundColor(ThemeColors.PRIMARY)
          .fontColor(Color.White)
          .margin({ top: 16 })
          .onClick(() => {
            this.showMySpotsList = false;
            this.toggleAddSpotMode();
          })
      }
      .width('90%')
      .padding(20)
      .backgroundColor(ThemeColors.BG_PRIMARY)
      .borderRadius(16)
    }
    .width('100%')
    .height('100%')
    .position({ x: 0, y: 0 })
  }
}
