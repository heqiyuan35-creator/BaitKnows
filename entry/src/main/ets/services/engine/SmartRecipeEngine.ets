/**
 * æ™ºèƒ½é…æ–¹å¼•æ“
 * æ•´åˆç¯å¢ƒåˆ†æã€åŸæ–™åŒ¹é…ã€å˜ä½“ç®¡ç†ï¼Œæä¾›ç»Ÿä¸€çš„é…æ–¹ç”Ÿæˆæ¥å?
 */
import {
  GenerateRecipeInput, GeneratedRecipe, RecipeIngredient,
  FlavorDescription, StateProfile, UsageSuggestion, GenerateReason,
  RecipeSeason
} from '../../common/types/RecipeTypes';
import { getContextAnalyzer, AnalysisResult, FlavorWeights, StateWeights } from './ContextAnalyzer';
import { getIngredientPool, ScoredIngredient } from './IngredientPool';
import { getVariantManager, RecipeVariant } from './VariantManager';
import { getPreferenceLearner } from './PreferenceLearner';
import { getIngredientById, Ingredient } from '../../data/IngredientDatabase';
import {
  getTempReasonTemplate, getWaterReasonTemplate, getFishReasonTemplate,
  getDensityReasonTemplate, getActivityReasonTemplate, getModeReasonTemplate
} from '../../data/RecipeRules';

// å¼•æ“é…ç½®
export class EngineConfig {
  totalWeight: number = 500;           // é»˜è®¤æ€»é‡é‡?
  mainRatio: number = 45;              // ä¸»é¥µå æ¯”
  auxRatio: number = 25;               // è¾…é¥µå æ¯”
  stateRatio: number = 18;             // çŠ¶æ€é¥µå æ¯”
  additiveRatio: number = 12;          // æ·»åŠ å‰‚å æ¯?
  maxVariantAttempts: number = 10;     // æœ€å¤§å˜ä½“å°è¯•æ¬¡æ•?
  minDifferenceScore: number = 25;     // æœ€å°å·®å¼‚åº¦

  constructor() {}
}

// æ™ºèƒ½é…æ–¹å¼•æ“
export class SmartRecipeEngine {
  private static instance: SmartRecipeEngine | null = null;
  private config: EngineConfig = new EngineConfig();
  private currentAnalysis: AnalysisResult | null = null;
  private currentInput: GenerateRecipeInput | null = null;
  private variantAttemptIndex: number = 0;

  private constructor() {}

  static getInstance(): SmartRecipeEngine {
    if (SmartRecipeEngine.instance === null) {
      SmartRecipeEngine.instance = new SmartRecipeEngine();
    }
    return SmartRecipeEngine.instance;
  }

  /**
   * ç”Ÿæˆé…æ–¹ (ä¸»å…¥å?
   */
  generate(input: GenerateRecipeInput): GeneratedRecipe {
    // ä¿å­˜å½“å‰è¾“å…¥
    this.currentInput = input;
    this.variantAttemptIndex = 0;

    // 1. ç¯å¢ƒåˆ†æ
    const analyzer = getContextAnalyzer();
    this.currentAnalysis = analyzer.analyze(input);

    // 2. ç”Ÿæˆé…æ–¹
    const recipe = this.buildRecipe(input, this.currentAnalysis, null);

    // 3. è®°å½•åˆ°å˜ä½“ç®¡ç†å™¨
    const variantManager = getVariantManager();
    const conditionHash = variantManager.hashConditions(input);
    variantManager.recordShownRecipe(conditionHash, recipe);

    // 4. è®°å½•åˆ°åå¥½å­¦ä¹ å™¨
    const prefLearner = getPreferenceLearner();
    if (prefLearner.isLoaded()) {
      prefLearner.recordGenerate(recipe);
    }

    return recipe;
  }

  /**
   * è·å–ä¸‹ä¸€ä¸ªå˜ä½?(æ¢ä¸€æ?
   */
  getNextVariant(): GeneratedRecipe | null {
    if (this.currentInput === null || this.currentAnalysis === null) {
      return null;
    }

    const variantManager = getVariantManager();
    const conditionHash = variantManager.hashConditions(this.currentInput);

    // æ£€æŸ¥æ˜¯å¦å·²ç»å°è¯•å¤ªå¤šæ¬¡
    if (this.variantAttemptIndex >= this.config.maxVariantAttempts) {
      // é‡ç½®å°è¯•è®¡æ•°ï¼Œä½†ä¿ç•™å†å²è®°å½•
      this.variantAttemptIndex = 0;
    }

    // å°è¯•ç”Ÿæˆä¸é‡å¤çš„å˜ä½“
    let attempts = 0;
    while (attempts < this.config.maxVariantAttempts) {
      this.variantAttemptIndex++;
      attempts++;

      // ç”Ÿæˆå˜ä½“å‚æ•°
      const variantParams = variantManager.generateVariantParams(
        this.buildRecipe(this.currentInput, this.currentAnalysis, null),
        this.currentAnalysis,
        this.variantAttemptIndex
      );

      // ä½¿ç”¨å˜ä½“å‚æ•°ç”Ÿæˆæ–°é…æ–?
      const newRecipe = this.buildRecipe(this.currentInput, this.currentAnalysis, variantParams);

      // æ£€æŸ¥æ˜¯å¦ä¸å†å²é…æ–¹é‡å¤
      if (!variantManager.isDuplicateRecipe(newRecipe)) {
        // è®°å½•æ–°é…æ–?
        variantManager.recordShownRecipe(conditionHash, newRecipe);
        return newRecipe;
      }
    }

    // å¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼Œå¼ºåˆ¶ç”Ÿæˆä¸€ä¸ªï¼ˆå³ä½¿å¯èƒ½æœ‰äº›ç›¸ä¼¼ï¼?
    const forcedVariant = variantManager.generateVariantParams(
      this.buildRecipe(this.currentInput, this.currentAnalysis, null),
      this.currentAnalysis,
      Date.now() % 100  // ä½¿ç”¨æ—¶é—´æˆ³å¢åŠ éšæœºæ€?
    );

    const forcedRecipe = this.buildRecipe(this.currentInput, this.currentAnalysis, forcedVariant);
    variantManager.recordShownRecipe(conditionHash, forcedRecipe);
    return forcedRecipe;
  }


  /**
   * æ„å»ºé…æ–¹
   */
  private buildRecipe(
    input: GenerateRecipeInput,
    analysis: AnalysisResult,
    variant: RecipeVariant | null
  ): GeneratedRecipe {
    const recipe = new GeneratedRecipe();
    recipe.id = this.generateId();
    recipe.createTime = Date.now();
    recipe.mode = input.mode;
    recipe.conditions = input;
    recipe.totalWeight = this.config.totalWeight;

    // åº”ç”¨å˜ä½“è°ƒæ•´åˆ°åˆ†æç»“æ?
    let adjustedAnalysis = analysis;
    if (variant !== null) {
      adjustedAnalysis = this.applyVariantToAnalysis(analysis, variant);
    }

    // 1. åŒ¹é…åŸæ–™
    const ingredients = this.matchIngredients(input, adjustedAnalysis, variant);
    recipe.ingredients = ingredients;

    // 2. ç”Ÿæˆé…æ–¹åç§°
    recipe.name = this.generateRecipeName(input, analysis, variant);

    // 3. ç”Ÿæˆå‘³å‹è¯´æ˜
    recipe.flavorProfile = this.generateFlavorProfile(adjustedAnalysis.flavorWeights, input);

    // 4. ç”ŸæˆçŠ¶æ€ç‰¹æ€?
    recipe.stateProfile = this.generateStateProfile(adjustedAnalysis.stateWeights);

    // 5. ç”Ÿæˆä½¿ç”¨å»ºè®®
    recipe.usage = this.generateUsage(input, adjustedAnalysis.stateWeights);

    // 6. ç”Ÿæˆæ¨èç†ç”±
    recipe.reasons = this.generateReasons(input, analysis, variant);

    return recipe;
  }

  /**
   * åº”ç”¨å˜ä½“è°ƒæ•´åˆ°åˆ†æç»“æ?
   */
  private applyVariantToAnalysis(analysis: AnalysisResult, variant: RecipeVariant): AnalysisResult {
    // å…‹éš†åˆ†æç»“æœ
    const adjusted = new AnalysisResult();
    adjusted.flavorWeights = analysis.flavorWeights.clone();
    adjusted.stateWeights = analysis.stateWeights.clone();
    adjusted.fishRule = analysis.fishRule;
    adjusted.specialScenarios = analysis.specialScenarios.slice();
    adjusted.priorityFactors = analysis.priorityFactors.slice();
    adjusted.analysisNotes = analysis.analysisNotes.slice();

    // åº”ç”¨å‘³å‹åç§»
    if (variant.flavorShift !== null) {
      const shift = variant.flavorShift;
      switch (shift.primaryShift) {
        case 'increase_fishy':
          adjusted.flavorWeights.fishy += shift.intensityChange;
          adjusted.flavorWeights.fragrant -= Math.round(shift.intensityChange * 0.3);
          break;
        case 'increase_fragrant':
          adjusted.flavorWeights.fragrant += shift.intensityChange;
          adjusted.flavorWeights.fishy -= Math.round(shift.intensityChange * 0.3);
          break;
        case 'increase_sweet':
          adjusted.flavorWeights.sweet += shift.intensityChange;
          break;
        case 'increase_sour':
          adjusted.flavorWeights.sour += shift.intensityChange;
          adjusted.flavorWeights.sweet -= Math.round(shift.intensityChange * 0.3);
          break;
        case 'decrease_intensity':
          const scale = 1 + shift.intensityChange / 100;
          adjusted.flavorWeights.fishy = Math.round(adjusted.flavorWeights.fishy * scale);
          adjusted.flavorWeights.fragrant = Math.round(adjusted.flavorWeights.fragrant * scale);
          adjusted.flavorWeights.sweet = Math.round(adjusted.flavorWeights.sweet * scale);
          break;
        case 'more_atomization':
          adjusted.stateWeights.atomization += 20;
          adjusted.stateWeights.viscosity -= 10;
          break;
        case 'more_viscosity':
          adjusted.stateWeights.viscosity += 20;
          adjusted.stateWeights.atomization -= 10;
          break;
        case 'lighter':
          adjusted.stateWeights.weight -= 15;
          adjusted.stateWeights.atomization += 10;
          break;
        case 'heavier':
          adjusted.stateWeights.weight += 15;
          adjusted.stateWeights.atomization -= 10;
          break;
      }

      // å½’ä¸€åŒ?
      adjusted.flavorWeights.fishy = Math.min(100, Math.max(0, adjusted.flavorWeights.fishy));
      adjusted.flavorWeights.fragrant = Math.min(100, Math.max(0, adjusted.flavorWeights.fragrant));
      adjusted.flavorWeights.sweet = Math.min(100, Math.max(0, adjusted.flavorWeights.sweet));
      adjusted.flavorWeights.sour = Math.min(100, Math.max(0, adjusted.flavorWeights.sour));
      adjusted.stateWeights.atomization = Math.min(100, Math.max(0, adjusted.stateWeights.atomization));
      adjusted.stateWeights.viscosity = Math.min(100, Math.max(0, adjusted.stateWeights.viscosity));
      adjusted.stateWeights.weight = Math.min(100, Math.max(0, adjusted.stateWeights.weight));
    }

    return adjusted;
  }

  /**
   * åŒ¹é…åŸæ–™
   */
  private matchIngredients(
    input: GenerateRecipeInput,
    analysis: AnalysisResult,
    variant: RecipeVariant | null
  ): RecipeIngredient[] {
    const pool = getIngredientPool();
    const result: RecipeIngredient[] = [];
    const selectedIds: string[] = [];

    // è·å–é±¼ç§æ¨èåŸæ–™
    const fishRule = analysis.fishRule;
    if (fishRule === null) {
      return this.getDefaultIngredients();
    }

    // ç”¨æˆ·å¯ç”¨åŸæ–™è¿‡æ»¤
    const available = input.availableBaits || [];
    const filterAvailable = (ids: string[]): string[] => {
      if (available.length === 0) return ids;
      const filtered: string[] = [];
      for (let i = 0; i < ids.length; i++) {
        for (let j = 0; j < available.length; j++) {
          if (ids[i] === available[j]) {
            filtered.push(ids[i]);
            break;
          }
        }
      }
      return filtered.length > 0 ? filtered : ids;
    };

    // 1. é€‰ä¸»é¥?(1-2ç§?
    let mainCandidates = filterAvailable(fishRule.recommendedIngredients.main);
    // åº”ç”¨å˜ä½“æ›¿æ¢
    if (variant !== null && variant.ingredientSwaps.length > 0) {
      mainCandidates = this.applySwapsToCandidate(mainCandidates, variant, 'main');
    }
    const mainSelected = pool.matchByFlavor(analysis.flavorWeights, mainCandidates, 2, selectedIds);
    for (let i = 0; i < mainSelected.length; i++) {
      selectedIds.push(mainSelected[i].ingredient.id);
      result.push(this.createRecipeIngredient(mainSelected[i], 'main', this.config.mainRatio / mainSelected.length));
    }

    // 2. é€‰è¾…é¥?(1ç§?
    let auxCandidates = filterAvailable(fishRule.recommendedIngredients.auxiliary);
    if (variant !== null && variant.ingredientSwaps.length > 0) {
      auxCandidates = this.applySwapsToCandidate(auxCandidates, variant, 'auxiliary');
    }
    const auxSelected = pool.matchByFlavor(analysis.flavorWeights, auxCandidates, 1, selectedIds);
    for (let i = 0; i < auxSelected.length; i++) {
      selectedIds.push(auxSelected[i].ingredient.id);
      result.push(this.createRecipeIngredient(auxSelected[i], 'auxiliary', this.config.auxRatio));
    }

    // 3. é€‰çŠ¶æ€é¥µ (1ç§?
    let stateCandidates = filterAvailable(fishRule.recommendedIngredients.state);
    if (variant !== null && variant.ingredientSwaps.length > 0) {
      stateCandidates = this.applySwapsToCandidate(stateCandidates, variant, 'state');
    }
    const stateSelected = pool.matchByState(analysis.stateWeights, stateCandidates, input.fishingMethod, 1, selectedIds);
    for (let i = 0; i < stateSelected.length; i++) {
      selectedIds.push(stateSelected[i].ingredient.id);
      result.push(this.createRecipeIngredient(stateSelected[i], 'state', this.config.stateRatio));
    }

    // 4. é€‰æ·»åŠ å‰‚ (1ç§?
    let addCandidates = filterAvailable(fishRule.recommendedIngredients.additive);
    if (variant !== null && variant.ingredientSwaps.length > 0) {
      addCandidates = this.applySwapsToCandidate(addCandidates, variant, 'additive');
    }
    const addSelected = pool.matchByFlavor(analysis.flavorWeights, addCandidates, 1, selectedIds);
    for (let i = 0; i < addSelected.length; i++) {
      selectedIds.push(addSelected[i].ingredient.id);
      result.push(this.createRecipeIngredient(addSelected[i], 'additive', this.config.additiveRatio));
    }

    // 5. åº”ç”¨é…æ¯”è°ƒæ•´
    if (variant !== null && variant.ratioAdjustments.length > 0) {
      this.applyRatioAdjustments(result, variant);
    }

    // 6. ç¡®ä¿æ€»æ¯”ä¾‹ä¸º100%
    this.normalizeRatios(result);

    return result;
  }

  /**
   * åº”ç”¨åŸæ–™æ›¿æ¢åˆ°å€™é€‰åˆ—è¡?
   */
  private applySwapsToCandidate(candidates: string[], variant: RecipeVariant, category: string): string[] {
    const result: string[] = [];

    for (let i = 0; i < candidates.length; i++) {
      let swapped = false;
      for (let j = 0; j < variant.ingredientSwaps.length; j++) {
        const swap = variant.ingredientSwaps[j];
        if (swap.originalId === candidates[i]) {
          // å°†æ›¿æ¢åŸæ–™æ”¾åœ¨å‰é¢ï¼ˆä¼˜å…ˆé€‰æ‹©ï¼?
          result.unshift(swap.replacementId);
          swapped = true;
          break;
        }
      }
      if (!swapped) {
        result.push(candidates[i]);
      }
    }

    return result;
  }

  /**
   * åº”ç”¨é…æ¯”è°ƒæ•´
   */
  private applyRatioAdjustments(ingredients: RecipeIngredient[], variant: RecipeVariant): void {
    for (let i = 0; i < variant.ratioAdjustments.length; i++) {
      const adj = variant.ratioAdjustments[i];
      for (let j = 0; j < ingredients.length; j++) {
        if (ingredients[j].id === adj.ingredientId) {
          ingredients[j].percentage = adj.newRatio;
          break;
        }
      }
    }
  }

  /**
   * å½’ä¸€åŒ–é…æ¯?
   */
  private normalizeRatios(ingredients: RecipeIngredient[]): void {
    let total = 0;
    for (let i = 0; i < ingredients.length; i++) {
      total += ingredients[i].percentage;
    }

    if (total === 0) return;

    const scale = 100 / total;
    for (let i = 0; i < ingredients.length; i++) {
      ingredients[i].percentage = Math.round(ingredients[i].percentage * scale);
      ingredients[i].weight = Math.round(this.config.totalWeight * ingredients[i].percentage / 100);
    }
  }

  /**
   * åˆ›å»ºé…æ–¹åŸæ–™
   */
  private createRecipeIngredient(scored: ScoredIngredient, category: string, percentage: number): RecipeIngredient {
    const ing = new RecipeIngredient();
    ing.id = scored.ingredient.id;
    ing.name = scored.ingredient.name;
    ing.category = category as 'main' | 'auxiliary' | 'state' | 'additive';
    ing.percentage = Math.round(percentage);
    ing.weight = Math.round(this.config.totalWeight * percentage / 100);
    ing.purpose = this.getIngredientPurpose(category, scored.matchReasons);
    return ing;
  }

  /**
   * è·å–åŸæ–™ç”¨é€”è¯´æ˜?
   */
  private getIngredientPurpose(category: string, reasons: string[]): string {
    let base = '';
    if (category === 'main') base = 'ä¸»é¥µï¼Œæä¾›åŸºç¡€å‘³å‹';
    else if (category === 'auxiliary') base = 'è¾…é¥µï¼Œå¢å¼ºè¯±é±¼æ•ˆæ?;
    else if (category === 'state') base = 'çŠ¶æ€ç²‰ï¼Œè°ƒèŠ‚é›¾åŒ–ç²˜åº?;
    else if (category === 'additive') base = 'æ·»åŠ å‰‚ï¼Œæå‡å‘³å‹æµ“åº¦';

    if (reasons.length > 0) {
      base += 'ï¼? + reasons.join('ã€?);
    }
    return base;
  }

  /**
   * è·å–é»˜è®¤åŸæ–™
   */
  private getDefaultIngredients(): RecipeIngredient[] {
    const result: RecipeIngredient[] = [];

    const main = new RecipeIngredient();
    main.id = 'corn_flour'; main.name = 'ç‰ç±³ç²?; main.category = 'main';
    main.percentage = 45; main.weight = 225; main.purpose = 'ä¸»é¥µï¼Œæä¾›åŸºç¡€å‘³å‹';
    result.push(main);

    const aux = new RecipeIngredient();
    aux.id = 'fish_meal'; aux.name = 'é±¼ç²‰'; aux.category = 'auxiliary';
    aux.percentage = 25; aux.weight = 125; aux.purpose = 'è¾…é¥µï¼Œå¢å¼ºè¯±é±¼æ•ˆæ?;
    result.push(aux);

    const state = new RecipeIngredient();
    state.id = 'drawing_powder'; state.name = 'æ‹‰ä¸ç²?; state.category = 'state';
    state.percentage = 18; state.weight = 90; state.purpose = 'çŠ¶æ€ç²‰ï¼Œè°ƒèŠ‚é›¾åŒ–ç²˜åº?;
    result.push(state);

    const add = new RecipeIngredient();
    add.id = 'dmpt'; add.name = 'DMPTè¯±é£Ÿå‰?; add.category = 'additive';
    add.percentage = 12; add.weight = 60; add.purpose = 'æ·»åŠ å‰‚ï¼Œæå‡å‘³å‹æµ“åº¦';
    result.push(add);

    return result;
  }


  /**
   * ç”Ÿæˆé…æ–¹åç§°
   */
  private generateRecipeName(input: GenerateRecipeInput, analysis: AnalysisResult, variant: RecipeVariant | null): string {
    let season = '';
    if (input.season === 'spring') season = 'æ˜¥å­£';
    else if (input.season === 'summer') season = 'å¤å­£';
    else if (input.season === 'autumn') season = 'ç§‹å­£';
    else if (input.season === 'winter') season = 'å†¬å­£';

    let water = '';
    if (input.waterType === 'river') water = 'é‡æ²³';
    else if (input.waterType === 'pond') water = 'é»‘å‘';
    else if (input.waterType === 'reservoir') water = 'æ°´åº“';
    else if (input.waterType === 'wild_pond') water = 'é‡å¡˜';

    const fishName = analysis.fishRule ? analysis.fishRule.fishName : 'ç›®æ ‡é±?;

    let suffix = '';
    if (input.mode === 'conservative') suffix = 'ç¨?;
    else if (input.mode === 'aggressive') suffix = 'çŒ?;
    else suffix = 'è¡?;

    // æ·»åŠ å˜ä½“æ ‡è¯†
    if (variant !== null) {
      const variantSuffix = this.getVariantSuffix(variant);
      return `${season}${water}${fishName}-${suffix}${variantSuffix}`;
    }

    return `${season}${water}${fishName}-${suffix}`;
  }

  /**
   * è·å–å˜ä½“åç¼€
   */
  private getVariantSuffix(variant: RecipeVariant): string {
    switch (variant.strategy) {
      case 'flavor_shift':
        if (variant.flavorShift?.primaryShift === 'increase_fishy') return 'Â·è…?;
        if (variant.flavorShift?.primaryShift === 'increase_fragrant') return 'Â·é¦?;
        if (variant.flavorShift?.primaryShift === 'increase_sweet') return 'Â·ç”?;
        if (variant.flavorShift?.primaryShift === 'increase_sour') return 'Â·é…?;
        if (variant.flavorShift?.primaryShift === 'decrease_intensity') return 'Â·æ·?;
        return 'Â·å?;
      case 'ingredient_swap':
        return 'Â·æ?;
      case 'additive_change':
        return 'Â·è?;
      case 'ratio_adjust':
        return 'Â·è°?;
      case 'state_change':
        return 'Â·æ€?;
      default:
        return '';
    }
  }

  /**
   * ç”Ÿæˆå‘³å‹è¯´æ˜
   */
  private generateFlavorProfile(weights: FlavorWeights, input: GenerateRecipeInput): FlavorDescription {
    const profile = new FlavorDescription();

    profile.primary = weights.getPrimaryFlavor();
    profile.secondary = weights.getSecondaryFlavor();

    // è®¡ç®—æµ“åº¦ (1-10)
    const avgIntensity = weights.getTotalIntensity() / 5;
    profile.intensity = Math.min(10, Math.max(1, Math.round(avgIntensity / 10)));

    // é€‚ç”¨æ°´æ¸©
    if (input.temperature < 10) {
      profile.suitableTemp = '5-15Â°C';
    } else if (input.temperature < 20) {
      profile.suitableTemp = '10-20Â°C';
    } else if (input.temperature < 28) {
      profile.suitableTemp = '18-28Â°C';
    } else {
      profile.suitableTemp = '25-35Â°C';
    }

    return profile;
  }

  /**
   * ç”ŸæˆçŠ¶æ€ç‰¹æ€?
   */
  private generateStateProfile(weights: StateWeights): StateProfile {
    const profile = new StateProfile();

    // è½¬æ¢ä¸?-5æ˜Ÿçº§ï¼ŒåŸºäºå®é™…æƒé‡å€?
    profile.atomization = Math.min(5, Math.max(1, this.toStarRating(weights.atomization)));
    profile.viscosity = Math.min(5, Math.max(1, this.toStarRating(weights.viscosity)));
    profile.hookHolding = Math.min(5, Math.max(1, Math.round((weights.viscosity + 20) / 24)));  // ç²˜åº¦è¶Šé«˜é™„é’©æ€§è¶Šå¥?
    profile.weight = Math.min(5, Math.max(1, this.toStarRating(weights.weight)));

    return profile;
  }

  /**
   * ç”Ÿæˆä½¿ç”¨å»ºè®®
   */
  private generateUsage(input: GenerateRecipeInput, stateWeights: StateWeights): UsageSuggestion {
    const usage = new UsageSuggestion();

    // æ°´æ¯” - æ ¹æ®é›¾åŒ–å’Œç²˜åº¦ç»¼åˆåˆ¤æ–?
    if (stateWeights.atomization > 70) {
      usage.waterRatio = '1:0.7';
    } else if (stateWeights.atomization > 60) {
      usage.waterRatio = '1:0.8';
    } else if (stateWeights.atomization > 40) {
      usage.waterRatio = '1:0.9';
    } else if (stateWeights.viscosity > 60) {
      usage.waterRatio = '1:1.1';
    } else {
      usage.waterRatio = '1:1';
    }

    // é™ç½®æ—¶é—´ - æ ¹æ®ç²˜åº¦å’Œé›¾åŒ?
    if (stateWeights.viscosity > 70) {
      usage.restTime = '15-20åˆ†é’Ÿ';
    } else if (stateWeights.viscosity > 60) {
      usage.restTime = '10-15åˆ†é’Ÿ';
    } else if (stateWeights.viscosity > 40) {
      usage.restTime = '5-10åˆ†é’Ÿ';
    } else if (stateWeights.atomization > 60) {
      usage.restTime = '3-5åˆ†é’Ÿ';
    } else {
      usage.restTime = '5-8åˆ†é’Ÿ';
    }

    // é¦–é’“å»ºè®® - æ ¹æ®é’“æ³•å’ŒçŠ¶æ€ç»¼åˆåˆ¤æ–?
    if (input.fishingMethod === 'rub') {
      if (stateWeights.weight > 60) {
        usage.firstCast = 'æ“å¤§é¥µå¿«é€Ÿæ‰¾åº•ï¼Œç¡®å®šæ°´æ·±åæ”¹å°é¥µ';
      } else if (stateWeights.atomization > 60) {
        usage.firstCast = 'æ“é¥µæŠ½çªï¼Œå½¢æˆé›¾åŒ–å¸¦åæ”¹å°é¥µ';
      } else {
        usage.firstCast = 'æ“å¤§é¥µæ‰¾é±¼å±‚ï¼Œæœ‰å£åæ”¹å°é¥?;
      }
    } else if (input.fishingMethod === 'pull') {
      if (stateWeights.atomization > 60) {
        usage.firstCast = 'æ‹‰å°é¥µå¿«é¢‘ç‡ï¼Œè¾¹è¯±è¾¹é’?;
      } else {
        usage.firstCast = 'æ‹‰é¥µæ‰¾å£ï¼Œæ³¨æ„æ§åˆ¶é¥µå›¢å¤§å°?;
      }
    } else if (input.fishingMethod === 'scatter') {
      if (stateWeights.weight > 60) {
        usage.firstCast = 'æ•£ç‚®åˆ°åº•è¯±é±¼ï¼Œæ“é¥µé’“åº?;
      } else {
        usage.firstCast = 'å…ˆæ‰“æ•£ç‚®è¯±é±¼ï¼Œå†æ“é¥µé’?;
      }
    } else if (input.fishingMethod === 'wrap') {
      usage.firstCast = 'å¤–å±‚é›¾åŒ–è¯±é±¼ï¼Œå†…å±‚ç•™é±?;
    } else {
      if (stateWeights.atomization > 50) {
        usage.firstCast = 'å‰å‡ ç«¿åŠ å¤§é¥µå›¢å¿«é€Ÿè¯±é±?;
      } else {
        usage.firstCast = 'æ“å¤§é¥µè¯•é±¼å±‚ï¼Œæ‰¾åˆ°é±¼å±‚åè°ƒæ•´';
      }
    }

    // æ‰“çªå»ºè®® - æ ¹æ®æ°´åŸŸå’ŒçŠ¶æ€?
    if (input.waterType === 'river') {
      if (stateWeights.viscosity > 60) {
        usage.nestSuggestion = 'é…’ç±³+é¢—ç²’æ‰“åº•ï¼Œç²˜é¥µå¸¦çª?;
      } else {
        usage.nestSuggestion = 'é…’ç±³+é¢—ç²’ï¼Œå°‘é‡å¤šæ¬¡è¡¥çª?;
      }
    } else if (input.waterType === 'pond') {
      if (stateWeights.atomization > 60) {
        usage.nestSuggestion = 'æ•£ç‚®å¸¦çªï¼Œé«˜é¢‘ç‡æŠ½ç«¿';
      } else {
        usage.nestSuggestion = 'æ•£ç‚®å¸¦çªï¼Œè¾¹é’“è¾¹è¯?;
      }
    } else if (input.waterType === 'reservoir') {
      if (stateWeights.weight > 60) {
        usage.nestSuggestion = 'å¤§çªå®ˆé’“ï¼Œç‰ç±?é¢—ç²’+é…’ç±³';
      } else {
        usage.nestSuggestion = 'æå‰æ‰“çªï¼Œè€å¿ƒå®ˆé’“';
      }
    } else {
      if (stateWeights.atomization > 50) {
        usage.nestSuggestion = 'é…’ç±³æ‰“åº•ï¼Œæ•£ç‚®è¯±é±?;
      } else {
        usage.nestSuggestion = 'é…’ç±³æ‰“åº•ï¼Œé€‚é‡è¡¥çª';
      }
    }

    return usage;
  }

  /**
   * ç”Ÿæˆæ¨èç†ç”±
   */
  private generateReasons(input: GenerateRecipeInput, analysis: AnalysisResult, variant: RecipeVariant | null): GenerateReason[] {
    const reasons: GenerateReason[] = [];

    // æ¸©åº¦ç†ç”± - æ ¹æ®å…·ä½“æ¸©åº¦ç”Ÿæˆæ›´è¯¦ç»†çš„ç†ç”±
    const tempReason = new GenerateReason();
    if (input.temperature < 5) {
      tempReason.condition = `æ°´æ¸©æä½(${input.temperature}Â°C)`;
      tempReason.decision = 'æµ“è…¥æµ“é¦™ï¼Œæ…¢é›¾åŒ–ç•™é±¼';
      tempReason.icon = 'â„ï¸';
    } else if (input.temperature < 10) {
      tempReason.condition = `æ°´æ¸©è¾ƒä½(${input.temperature}Â°C)`;
      tempReason.decision = 'è…¥é¦™ä¸ºä¸»ï¼Œå¢åŠ ç²˜åº?;
      tempReason.icon = 'ğŸŒ¡ï¸?;
    } else if (input.temperature < 15) {
      tempReason.condition = `æ°´æ¸©åä½(${input.temperature}Â°C)`;
      tempReason.decision = 'è…¥é¦™å…¼é¡¾ï¼ŒçŠ¶æ€åè½?;
      tempReason.icon = 'ğŸŒ¡ï¸?;
    } else if (input.temperature < 25) {
      tempReason.condition = `æ°´æ¸©é€‚å®œ(${input.temperature}Â°C)`;
      tempReason.decision = 'é¦™ç”œä¸ºä¸»ï¼ŒçŠ¶æ€é€‚ä¸­';
      tempReason.icon = 'â˜€ï¸?;
    } else if (input.temperature < 30) {
      tempReason.condition = `æ°´æ¸©åé«˜(${input.temperature}Â°C)`;
      tempReason.decision = 'æ¸…æ·¡æœé¦™ï¼Œå¿«é›¾åŒ–';
      tempReason.icon = 'ğŸŒ¤ï¸?;
    } else {
      tempReason.condition = `æ°´æ¸©è¾ƒé«˜(${input.temperature}Â°C)`;
      tempReason.decision = 'æœ¬å‘³æ¸…æ·¡ï¼ŒåŠ æœé…¸';
      tempReason.icon = 'ğŸ”¥';
    }
    reasons.push(tempReason);

    // æ°´åŸŸç†ç”± - æ›´è¯¦ç»†çš„æè¿°
    const waterReason = new GenerateReason();
    if (input.waterType === 'river') {
      waterReason.condition = 'é‡æ²³æµæ°´ç¯å¢ƒ';
      waterReason.decision = 'é™ä½é›¾åŒ–ï¼Œå¢åŠ ç²˜åº?;
    } else if (input.waterType === 'pond') {
      waterReason.condition = 'é»‘å‘ç«æŠ€ç¯å¢ƒ';
      waterReason.decision = 'å¿«é›¾åŒ–è¯±é±¼ï¼Œå‘³å‹çªå‡º';
    } else if (input.waterType === 'reservoir') {
      waterReason.condition = 'æ°´åº“å¤§æ°´é?;
      waterReason.decision = 'é‡æ¯”é‡åˆ°åº•ï¼ŒæŒä¹…ç•™é±¼';
    } else {
      waterReason.condition = 'é‡å¡˜è‡ªç„¶ç¯å¢ƒ';
      waterReason.decision = 'æœ¬å‘³ä¸ºä¸»ï¼ŒçŠ¶æ€è‡ªç„?;
    }
    waterReason.icon = 'ğŸŒŠ';
    reasons.push(waterReason);

    // é±¼ç§ç†ç”±
    const fishTemplate = getFishReasonTemplate(input.targetFishId);
    const fishReason = new GenerateReason();
    fishReason.condition = fishTemplate.condition;
    fishReason.decision = fishTemplate.decision;
    fishReason.icon = fishTemplate.icon;
    reasons.push(fishReason);

    // å˜ä½“ç†ç”± - å¦‚æœæ˜¯æ¢ä¸€æ¢ç”Ÿæˆçš„
    if (variant !== null && variant.description) {
      const variantReason = new GenerateReason();
      variantReason.condition = 'é…æ–¹è°ƒæ•´';
      // æ ¹æ®å˜ä½“ç­–ç•¥ç”Ÿæˆæ›´å…·ä½“çš„ç†ç”±
      switch (variant.strategy) {
        case 'flavor_shift':
          if (variant.flavorShift?.primaryShift === 'increase_fishy') {
            variantReason.decision = 'å¢åŠ è…¥å‘³æ¯”ä¾‹ï¼Œæå‡è¯±é±¼æ•ˆæ?;
          } else if (variant.flavorShift?.primaryShift === 'increase_fragrant') {
            variantReason.decision = 'å¢åŠ é¦™å‘³æ¯”ä¾‹ï¼Œé€‚åˆæ»‘å£é±?;
          } else if (variant.flavorShift?.primaryShift === 'increase_sweet') {
            variantReason.decision = 'å¢åŠ ç”œå‘³ï¼Œæå‡é€‚å£æ€?;
          } else if (variant.flavorShift?.primaryShift === 'decrease_intensity') {
            variantReason.decision = 'æ•´ä½“å‡æ·¡ï¼Œé€‚åˆè­¦æƒ•æ€§é«˜çš„é±¼';
          } else if (variant.flavorShift?.primaryShift === 'more_atomization') {
            variantReason.decision = 'å¢åŠ é›¾åŒ–ï¼ŒåŠ å¿«è¯±é±¼é€Ÿåº¦';
          } else if (variant.flavorShift?.primaryShift === 'more_viscosity') {
            variantReason.decision = 'å¢åŠ ç²˜åº¦ï¼Œæå‡é™„é’©æ€?;
          } else if (variant.flavorShift?.primaryShift === 'lighter') {
            variantReason.decision = 'å‡è½»æ¯”é‡ï¼Œé€‚åˆé’“æµ®æˆ–ç¦»åº?;
          } else if (variant.flavorShift?.primaryShift === 'heavier') {
            variantReason.decision = 'å¢åŠ æ¯”é‡ï¼Œå¿«é€Ÿåˆ°åº•å®ˆå¤§é±¼';
          } else {
            variantReason.decision = variant.description;
          }
          break;
        case 'ingredient_swap':
          variantReason.decision = 'æ›´æ¢åŸæ–™ç»„åˆï¼Œå°è¯•ä¸åŒæ•ˆæ?;
          break;
        case 'additive_change':
          variantReason.decision = 'æ›´æ¢æ·»åŠ å‰‚ï¼Œè°ƒæ•´å‘³å‹æ–¹å‘';
          break;
        case 'ratio_adjust':
          variantReason.decision = 'è°ƒæ•´é…æ¯”ï¼Œä¼˜åŒ–é¥µæ–™çŠ¶æ€?;
          break;
        case 'state_change':
          variantReason.decision = 'æ”¹å˜çŠ¶æ€ç‰¹æ€§ï¼Œé€‚åº”ä¸åŒé±¼æƒ…';
          break;
        default:
          variantReason.decision = variant.description;
      }
      variantReason.icon = 'ğŸ”„';
      reasons.push(variantReason);
    }

    // é±¼æƒ…ç†ç”±
    const densityTemplate = getDensityReasonTemplate(input.fishDensity);
    if (densityTemplate !== null) {
      const r = new GenerateReason();
      r.condition = densityTemplate.condition;
      r.decision = densityTemplate.decision;
      r.icon = densityTemplate.icon;
      reasons.push(r);
    }

    // å¼€å£ç†ç”?
    const activityTemplate = getActivityReasonTemplate(input.fishActivity);
    if (activityTemplate !== null) {
      const r = new GenerateReason();
      r.condition = activityTemplate.condition;
      r.decision = activityTemplate.decision;
      r.icon = activityTemplate.icon;
      reasons.push(r);
    }

    // æ¨¡å¼ç†ç”±
    const modeTemplate = getModeReasonTemplate(input.mode);
    if (modeTemplate !== null) {
      const r = new GenerateReason();
      r.condition = modeTemplate.condition;
      r.decision = modeTemplate.decision;
      r.icon = modeTemplate.icon;
      reasons.push(r);
    }

    // ç‰¹æ®Šåœºæ™¯ç†ç”±
    for (let i = 0; i < analysis.specialScenarios.length; i++) {
      const scenario = analysis.specialScenarios[i];
      const scenarioReason = this.getScenarioReason(scenario);
      if (scenarioReason !== null) {
        reasons.push(scenarioReason);
      }
    }

    return reasons;
  }

  /**
   * è·å–ç‰¹æ®Šåœºæ™¯ç†ç”±
   */
  private getScenarioReason(scenario: string): GenerateReason | null {
    const r = new GenerateReason();

    switch (scenario) {
      case 'extreme_cold':
        r.condition = 'æå¯’å¤©æ°”';
        r.decision = 'é«˜è…¥é«˜è›‹ç™½é…æ–?;
        r.icon = 'â„ï¸';
        return r;
      case 'extreme_hot':
        r.condition = 'é«˜æ¸©å¤©æ°”';
        r.decision = 'æ¸…æ·¡æœé…¸é…æ–¹';
        r.icon = 'ğŸ”¥';
        return r;
      case 'carnivore_fish':
        r.condition = 'è‚‰é£Ÿæ€§é±¼ç±?;
        r.decision = 'æµ“è…¥å‘³å‹ä¸ºä¸»';
        r.icon = 'ğŸ¦ˆ';
        return r;
      case 'black_pit_new':
        r.condition = 'é»‘å‘æ–°æ”¾é±?;
        r.decision = 'å¯é€‚å½“åŠ å°è?;
        r.icon = 'ğŸ†•';
        return r;
      case 'black_pit_old':
        r.condition = 'é»‘å‘è€é±¼';
        r.decision = 'æœ¬å‘³ä¸ºä¸»ï¼Œå‡å°‘åˆºæ¿€';
        r.icon = 'ğŸ¢';
        return r;
      case 'flowing_water':
        r.condition = 'æµæ°´ç¯å¢ƒ';
        r.decision = 'å¢åŠ ç²˜åº¦å’Œæ¯”é‡?;
        r.icon = 'ğŸŒŠ';
        return r;
      case 'deep_water':
        r.condition = 'æ·±æ°´åŒºåŸŸ';
        r.decision = 'é‡æ¯”é‡å¿«åˆ°åº•';
        r.icon = 'ğŸ”ï¸?;
        return r;
      default:
        return null;
    }
  }

  /**
   * è½¬æ¢ä¸ºæ˜Ÿçº§è¯„åˆ?
   */
  private toStarRating(value: number): number {
    return Math.min(5, Math.max(1, Math.round(value / 20)));
  }

  /**
   * ç”Ÿæˆå”¯ä¸€ID
   */
  private generateId(): string {
    return `recipe_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }

  /**
   * é‡ç½®å˜ä½“å†å²
   */
  resetVariantHistory(): void {
    getVariantManager().resetShownHistory();
    this.variantAttemptIndex = 0;
  }

  /**
   * è·å–å½“å‰å­£èŠ‚
   */
  getCurrentSeason(): RecipeSeason {
    const month = new Date().getMonth() + 1;
    if (month >= 3 && month <= 5) return 'spring';
    if (month >= 6 && month <= 8) return 'summer';
    if (month >= 9 && month <= 11) return 'autumn';
    return 'winter';
  }

  /**
   * è·å–é…ç½®
   */
  getConfig(): EngineConfig {
    return this.config;
  }

  /**
   * è®¾ç½®æ€»é‡é‡?
   */
  setTotalWeight(weight: number): void {
    this.config.totalWeight = Math.max(100, Math.min(2000, weight));
  }
}

// å¯¼å‡ºå•ä¾‹è·å–å‡½æ•°
export function getSmartRecipeEngine(): SmartRecipeEngine {
  return SmartRecipeEngine.getInstance();
}

// å¯¼å‡ºä¾¿æ·å‡½æ•°
export function generateSmartRecipe(input: GenerateRecipeInput): GeneratedRecipe {
  return getSmartRecipeEngine().generate(input);
}

export function getNextRecipeVariant(): GeneratedRecipe | null {
  return getSmartRecipeEngine().getNextVariant();
}

export function resetRecipeVariantHistory(): void {
  getSmartRecipeEngine().resetVariantHistory();
}

// è®°å½•é…æ–¹ä¿å­˜ï¼ˆä¾›å¤–éƒ¨è°ƒç”¨ï¼?
export function recordRecipeSave(recipe: GeneratedRecipe): void {
  const prefLearner = getPreferenceLearner();
  if (prefLearner.isLoaded()) {
    prefLearner.recordSave(recipe);
  }
}

// è®°å½•é…æ–¹åé¦ˆï¼ˆä¾›å¤–éƒ¨è°ƒç”¨ï¼?
export function recordRecipeFeedback(recipeId: string, rating: 'good' | 'normal' | 'bad', note: string): void {
  const prefLearner = getPreferenceLearner();
  if (prefLearner.isLoaded()) {
    prefLearner.recordFeedback(recipeId, rating, note);
  }
}
