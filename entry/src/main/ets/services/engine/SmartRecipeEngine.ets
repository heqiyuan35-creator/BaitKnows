/**
 * æ™ºèƒ½é…æ–¹å¼•æ“
 * æ•´åˆç¯å¢ƒåˆ†æã€åŸæ–™åŒ¹é…ã€å˜ä½“ç®¡ç†ï¼Œæä¾›ç»Ÿä¸€çš„é…æ–¹ç”Ÿæˆæ¥å£
 */
import {
  GenerateRecipeInput, GeneratedRecipe, RecipeIngredient,
  FlavorDescription, StateProfile, UsageSuggestion, GenerateReason,
  RecipeSeason
} from '../../common/types/RecipeTypes';
import { getContextAnalyzer, AnalysisResult, FlavorWeights, StateWeights } from './ContextAnalyzer';
import { getIngredientPool, ScoredIngredient } from './IngredientPool';
import { getVariantManager, RecipeVariant } from './VariantManager';
import { getPreferenceLearner } from './PreferenceLearner';
import { getIngredientById, Ingredient } from '../../data/IngredientDatabase';
import {
  getTempReasonTemplate, getWaterReasonTemplate, getFishReasonTemplate,
  getDensityReasonTemplate, getActivityReasonTemplate, getModeReasonTemplate
} from '../../data/RecipeRules';

// å¼•æ“é…ç½®
export class EngineConfig {
  totalWeight: number = 500;           // é»˜è®¤æ€»é‡é‡
  mainRatio: number = 45;              // ä¸»é¥µå æ¯”
  auxRatio: number = 25;               // è¾…é¥µå æ¯”
  stateRatio: number = 18;             // çŠ¶æ€é¥µå æ¯”
  additiveRatio: number = 12;          // æ·»åŠ å‰‚å æ¯”
  maxVariantAttempts: number = 10;     // æœ€å¤§å˜ä½“å°è¯•æ¬¡æ•°
  minDifferenceScore: number = 25;     // æœ€å°å·®å¼‚åº¦

  constructor() {}
}

// æ™ºèƒ½é…æ–¹å¼•æ“
export class SmartRecipeEngine {
  private static instance: SmartRecipeEngine | null = null;
  private config: EngineConfig = new EngineConfig();
  private currentAnalysis: AnalysisResult | null = null;
  private currentInput: GenerateRecipeInput | null = null;
  private variantAttemptIndex: number = 0;

  private constructor() {}

  static getInstance(): SmartRecipeEngine {
    if (SmartRecipeEngine.instance === null) {
      SmartRecipeEngine.instance = new SmartRecipeEngine();
    }
    return SmartRecipeEngine.instance;
  }

  /**
   * ç”Ÿæˆé…æ–¹ (ä¸»å…¥å£)
   */
  generate(input: GenerateRecipeInput): GeneratedRecipe {
    // ä¿å­˜å½“å‰è¾“å…¥
    this.currentInput = input;
    this.variantAttemptIndex = 0;

    // 1. ç¯å¢ƒåˆ†æ
    const analyzer = getContextAnalyzer();
    this.currentAnalysis = analyzer.analyze(input);

    // 2. ç”Ÿæˆé…æ–¹
    const recipe = this.buildRecipe(input, this.currentAnalysis, null);

    // 3. è®°å½•åˆ°å˜ä½“ç®¡ç†å™¨
    const variantManager = getVariantManager();
    const conditionHash = variantManager.hashConditions(input);
    variantManager.recordShownRecipe(conditionHash, recipe);

    // 4. è®°å½•åˆ°åå¥½å­¦ä¹ å™¨
    const prefLearner = getPreferenceLearner();
    if (prefLearner.isLoaded()) {
      prefLearner.recordGenerate(recipe);
    }

    return recipe;
  }

  /**
   * è·å–ä¸‹ä¸€ä¸ªå˜ä½“ (æ¢ä¸€æ¢)
   */
  getNextVariant(): GeneratedRecipe | null {
    if (this.currentInput === null || this.currentAnalysis === null) {
      return null;
    }

    const variantManager = getVariantManager();
    const conditionHash = variantManager.hashConditions(this.currentInput);

    // æ£€æŸ¥æ˜¯å¦å·²ç»å°è¯•å¤ªå¤šæ¬¡
    if (this.variantAttemptIndex >= this.config.maxVariantAttempts) {
      // é‡ç½®å°è¯•è®¡æ•°ï¼Œä½†ä¿ç•™å†å²è®°å½•
      this.variantAttemptIndex = 0;
    }

    // å°è¯•ç”Ÿæˆä¸é‡å¤çš„å˜ä½“
    let attempts = 0;
    while (attempts < this.config.maxVariantAttempts) {
      this.variantAttemptIndex++;
      attempts++;

      // ç”Ÿæˆå˜ä½“å‚æ•°
      const variantParams = variantManager.generateVariantParams(
        this.buildRecipe(this.currentInput, this.currentAnalysis, null),
        this.currentAnalysis,
        this.variantAttemptIndex
      );

      // ä½¿ç”¨å˜ä½“å‚æ•°ç”Ÿæˆæ–°é…æ–¹
      const newRecipe = this.buildRecipe(this.currentInput, this.currentAnalysis, variantParams);

      // æ£€æŸ¥æ˜¯å¦ä¸å†å²é…æ–¹é‡å¤
      if (!variantManager.isDuplicateRecipe(newRecipe)) {
        // è®°å½•æ–°é…æ–¹
        variantManager.recordShownRecipe(conditionHash, newRecipe);
        return newRecipe;
      }
    }

    // å¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼Œå¼ºåˆ¶ç”Ÿæˆä¸€ä¸ªï¼ˆå³ä½¿å¯èƒ½æœ‰äº›ç›¸ä¼¼ï¼‰
    const forcedVariant = variantManager.generateVariantParams(
      this.buildRecipe(this.currentInput, this.currentAnalysis, null),
      this.currentAnalysis,
      Date.now() % 100  // ä½¿ç”¨æ—¶é—´æˆ³å¢åŠ éšæœºæ€§
    );

    const forcedRecipe = this.buildRecipe(this.currentInput, this.currentAnalysis, forcedVariant);
    variantManager.recordShownRecipe(conditionHash, forcedRecipe);
    return forcedRecipe;
  }


  /**
   * æ„å»ºé…æ–¹
   */
  private buildRecipe(
    input: GenerateRecipeInput,
    analysis: AnalysisResult,
    variant: RecipeVariant | null
  ): GeneratedRecipe {
    const recipe = new GeneratedRecipe();
    recipe.id = this.generateId();
    recipe.createTime = Date.now();
    recipe.mode = input.mode;
    recipe.conditions = input;
    recipe.totalWeight = this.config.totalWeight;

    // åº”ç”¨å˜ä½“è°ƒæ•´åˆ°åˆ†æç»“æœ
    let adjustedAnalysis = analysis;
    if (variant !== null) {
      adjustedAnalysis = this.applyVariantToAnalysis(analysis, variant);
    }

    // 1. åŒ¹é…åŸæ–™
    const ingredients = this.matchIngredients(input, adjustedAnalysis, variant);
    recipe.ingredients = ingredients;

    // 2. ç”Ÿæˆé…æ–¹åç§°
    recipe.name = this.generateRecipeName(input, analysis, variant);

    // 3. ç”Ÿæˆå‘³å‹è¯´æ˜
    recipe.flavorProfile = this.generateFlavorProfile(adjustedAnalysis.flavorWeights, input);

    // 4. ç”ŸæˆçŠ¶æ€ç‰¹æ€§
    recipe.stateProfile = this.generateStateProfile(adjustedAnalysis.stateWeights);

    // 5. ç”Ÿæˆä½¿ç”¨å»ºè®®
    recipe.usage = this.generateUsage(input, adjustedAnalysis.stateWeights);

    // 6. ç”Ÿæˆæ¨èç†ç”±
    recipe.reasons = this.generateReasons(input, analysis, variant);

    return recipe;
  }

  /**
   * åº”ç”¨å˜ä½“è°ƒæ•´åˆ°åˆ†æç»“æœ
   */
  private applyVariantToAnalysis(analysis: AnalysisResult, variant: RecipeVariant): AnalysisResult {
    // å…‹éš†åˆ†æç»“æœ
    const adjusted = new AnalysisResult();
    adjusted.flavorWeights = analysis.flavorWeights.clone();
    adjusted.stateWeights = analysis.stateWeights.clone();
    adjusted.fishRule = analysis.fishRule;
    adjusted.specialScenarios = analysis.specialScenarios.slice();
    adjusted.priorityFactors = analysis.priorityFactors.slice();
    adjusted.analysisNotes = analysis.analysisNotes.slice();

    // åº”ç”¨å‘³å‹åç§»
    if (variant.flavorShift !== null) {
      const shift = variant.flavorShift;
      switch (shift.primaryShift) {
        case 'increase_fishy':
          adjusted.flavorWeights.fishy += shift.intensityChange;
          adjusted.flavorWeights.fragrant -= Math.round(shift.intensityChange * 0.3);
          break;
        case 'increase_fragrant':
          adjusted.flavorWeights.fragrant += shift.intensityChange;
          adjusted.flavorWeights.fishy -= Math.round(shift.intensityChange * 0.3);
          break;
        case 'increase_sweet':
          adjusted.flavorWeights.sweet += shift.intensityChange;
          break;
        case 'increase_sour':
          adjusted.flavorWeights.sour += shift.intensityChange;
          adjusted.flavorWeights.sweet -= Math.round(shift.intensityChange * 0.3);
          break;
        case 'decrease_intensity':
          const scale = 1 + shift.intensityChange / 100;
          adjusted.flavorWeights.fishy = Math.round(adjusted.flavorWeights.fishy * scale);
          adjusted.flavorWeights.fragrant = Math.round(adjusted.flavorWeights.fragrant * scale);
          adjusted.flavorWeights.sweet = Math.round(adjusted.flavorWeights.sweet * scale);
          break;
        case 'more_atomization':
          adjusted.stateWeights.atomization += 20;
          adjusted.stateWeights.viscosity -= 10;
          break;
        case 'more_viscosity':
          adjusted.stateWeights.viscosity += 20;
          adjusted.stateWeights.atomization -= 10;
          break;
        case 'lighter':
          adjusted.stateWeights.weight -= 15;
          adjusted.stateWeights.atomization += 10;
          break;
        case 'heavier':
          adjusted.stateWeights.weight += 15;
          adjusted.stateWeights.atomization -= 10;
          break;
      }

      // å½’ä¸€åŒ–
      adjusted.flavorWeights.fishy = Math.min(100, Math.max(0, adjusted.flavorWeights.fishy));
      adjusted.flavorWeights.fragrant = Math.min(100, Math.max(0, adjusted.flavorWeights.fragrant));
      adjusted.flavorWeights.sweet = Math.min(100, Math.max(0, adjusted.flavorWeights.sweet));
      adjusted.flavorWeights.sour = Math.min(100, Math.max(0, adjusted.flavorWeights.sour));
      adjusted.stateWeights.atomization = Math.min(100, Math.max(0, adjusted.stateWeights.atomization));
      adjusted.stateWeights.viscosity = Math.min(100, Math.max(0, adjusted.stateWeights.viscosity));
      adjusted.stateWeights.weight = Math.min(100, Math.max(0, adjusted.stateWeights.weight));
    }

    return adjusted;
  }

  /**
   * åŒ¹é…åŸæ–™
   */
  private matchIngredients(
    input: GenerateRecipeInput,
    analysis: AnalysisResult,
    variant: RecipeVariant | null
  ): RecipeIngredient[] {
    const pool = getIngredientPool();
    const result: RecipeIngredient[] = [];
    const selectedIds: string[] = [];

    // è·å–é±¼ç§æ¨èåŸæ–™
    const fishRule = analysis.fishRule;
    if (fishRule === null) {
      return this.getDefaultIngredients();
    }

    // ç”¨æˆ·å¯ç”¨åŸæ–™è¿‡æ»¤
    const available = input.availableBaits || [];
    const filterAvailable = (ids: string[]): string[] => {
      if (available.length === 0) return ids;
      const filtered: string[] = [];
      for (let i = 0; i < ids.length; i++) {
        for (let j = 0; j < available.length; j++) {
          if (ids[i] === available[j]) {
            filtered.push(ids[i]);
            break;
          }
        }
      }
      return filtered.length > 0 ? filtered : ids;
    };

    // 1. é€‰ä¸»é¥µ (1-2ç§)
    let mainCandidates = filterAvailable(fishRule.recommendedIngredients.main);
    // åº”ç”¨å˜ä½“æ›¿æ¢
    if (variant !== null && variant.ingredientSwaps.length > 0) {
      mainCandidates = this.applySwapsToCandidate(mainCandidates, variant, 'main');
    }
    const mainSelected = pool.matchByFlavor(analysis.flavorWeights, mainCandidates, 2, selectedIds);
    for (let i = 0; i < mainSelected.length; i++) {
      selectedIds.push(mainSelected[i].ingredient.id);
      result.push(this.createRecipeIngredient(mainSelected[i], 'main', this.config.mainRatio / mainSelected.length));
    }

    // 2. é€‰è¾…é¥µ (1ç§)
    let auxCandidates = filterAvailable(fishRule.recommendedIngredients.auxiliary);
    if (variant !== null && variant.ingredientSwaps.length > 0) {
      auxCandidates = this.applySwapsToCandidate(auxCandidates, variant, 'auxiliary');
    }
    const auxSelected = pool.matchByFlavor(analysis.flavorWeights, auxCandidates, 1, selectedIds);
    for (let i = 0; i < auxSelected.length; i++) {
      selectedIds.push(auxSelected[i].ingredient.id);
      result.push(this.createRecipeIngredient(auxSelected[i], 'auxiliary', this.config.auxRatio));
    }

    // 3. é€‰çŠ¶æ€é¥µ (1ç§)
    let stateCandidates = filterAvailable(fishRule.recommendedIngredients.state);
    if (variant !== null && variant.ingredientSwaps.length > 0) {
      stateCandidates = this.applySwapsToCandidate(stateCandidates, variant, 'state');
    }
    const stateSelected = pool.matchByState(analysis.stateWeights, stateCandidates, input.fishingMethod, 1, selectedIds);
    for (let i = 0; i < stateSelected.length; i++) {
      selectedIds.push(stateSelected[i].ingredient.id);
      result.push(this.createRecipeIngredient(stateSelected[i], 'state', this.config.stateRatio));
    }

    // 4. é€‰æ·»åŠ å‰‚ (1ç§)
    let addCandidates = filterAvailable(fishRule.recommendedIngredients.additive);
    if (variant !== null && variant.ingredientSwaps.length > 0) {
      addCandidates = this.applySwapsToCandidate(addCandidates, variant, 'additive');
    }
    const addSelected = pool.matchByFlavor(analysis.flavorWeights, addCandidates, 1, selectedIds);
    for (let i = 0; i < addSelected.length; i++) {
      selectedIds.push(addSelected[i].ingredient.id);
      result.push(this.createRecipeIngredient(addSelected[i], 'additive', this.config.additiveRatio));
    }

    // 5. åº”ç”¨é…æ¯”è°ƒæ•´
    if (variant !== null && variant.ratioAdjustments.length > 0) {
      this.applyRatioAdjustments(result, variant);
    }

    // 6. ç¡®ä¿æ€»æ¯”ä¾‹ä¸º100%
    this.normalizeRatios(result);

    return result;
  }

  /**
   * åº”ç”¨åŸæ–™æ›¿æ¢åˆ°å€™é€‰åˆ—è¡¨
   */
  private applySwapsToCandidate(candidates: string[], variant: RecipeVariant, category: string): string[] {
    const result: string[] = [];

    for (let i = 0; i < candidates.length; i++) {
      let swapped = false;
      for (let j = 0; j < variant.ingredientSwaps.length; j++) {
        const swap = variant.ingredientSwaps[j];
        if (swap.originalId === candidates[i]) {
          // å°†æ›¿æ¢åŸæ–™æ”¾åœ¨å‰é¢ï¼ˆä¼˜å…ˆé€‰æ‹©ï¼‰
          result.unshift(swap.replacementId);
          swapped = true;
          break;
        }
      }
      if (!swapped) {
        result.push(candidates[i]);
      }
    }

    return result;
  }

  /**
   * åº”ç”¨é…æ¯”è°ƒæ•´
   */
  private applyRatioAdjustments(ingredients: RecipeIngredient[], variant: RecipeVariant): void {
    for (let i = 0; i < variant.ratioAdjustments.length; i++) {
      const adj = variant.ratioAdjustments[i];
      for (let j = 0; j < ingredients.length; j++) {
        if (ingredients[j].id === adj.ingredientId) {
          ingredients[j].percentage = adj.newRatio;
          break;
        }
      }
    }
  }

  /**
   * å½’ä¸€åŒ–é…æ¯”
   */
  private normalizeRatios(ingredients: RecipeIngredient[]): void {
    let total = 0;
    for (let i = 0; i < ingredients.length; i++) {
      total += ingredients[i].percentage;
    }

    if (total === 0) return;

    const scale = 100 / total;
    for (let i = 0; i < ingredients.length; i++) {
      ingredients[i].percentage = Math.round(ingredients[i].percentage * scale);
      ingredients[i].weight = Math.round(this.config.totalWeight * ingredients[i].percentage / 100);
    }
  }

  /**
   * åˆ›å»ºé…æ–¹åŸæ–™
   */
  private createRecipeIngredient(scored: ScoredIngredient, category: string, percentage: number): RecipeIngredient {
    const ing = new RecipeIngredient();
    ing.id = scored.ingredient.id;
    ing.name = scored.ingredient.name;
    ing.category = category as 'main' | 'auxiliary' | 'state' | 'additive';
    ing.percentage = Math.round(percentage);
    ing.weight = Math.round(this.config.totalWeight * percentage / 100);
    ing.purpose = this.getIngredientPurpose(category, scored.matchReasons);
    return ing;
  }

  /**
   * è·å–åŸæ–™ç”¨é€”è¯´æ˜
   */
  private getIngredientPurpose(category: string, reasons: string[]): string {
    let base = '';
    if (category === 'main') base = 'ä¸»é¥µï¼Œæä¾›åŸºç¡€å‘³å‹';
    else if (category === 'auxiliary') base = 'è¾…é¥µï¼Œå¢å¼ºè¯±é±¼æ•ˆæœ';
    else if (category === 'state') base = 'çŠ¶æ€ç²‰ï¼Œè°ƒèŠ‚é›¾åŒ–ç²˜åº¦';
    else if (category === 'additive') base = 'æ·»åŠ å‰‚ï¼Œæå‡å‘³å‹æµ“åº¦';

    if (reasons.length > 0) {
      base += 'ï¼Œ' + reasons.join('ã€');
    }
    return base;
  }

  /**
   * è·å–é»˜è®¤åŸæ–™
   */
  private getDefaultIngredients(): RecipeIngredient[] {
    const result: RecipeIngredient[] = [];

    const main = new RecipeIngredient();
    main.id = 'corn_flour'; main.name = 'ç‰ç±³ç²‰'; main.category = 'main';
    main.percentage = 45; main.weight = 225; main.purpose = 'ä¸»é¥µï¼Œæä¾›åŸºç¡€å‘³å‹';
    result.push(main);

    const aux = new RecipeIngredient();
    aux.id = 'fish_meal'; aux.name = 'é±¼ç²‰'; aux.category = 'auxiliary';
    aux.percentage = 25; aux.weight = 125; aux.purpose = 'è¾…é¥µï¼Œå¢å¼ºè¯±é±¼æ•ˆæœ';
    result.push(aux);

    const state = new RecipeIngredient();
    state.id = 'drawing_powder'; state.name = 'æ‹‰ä¸ç²‰'; state.category = 'state';
    state.percentage = 18; state.weight = 90; state.purpose = 'çŠ¶æ€ç²‰ï¼Œè°ƒèŠ‚é›¾åŒ–ç²˜åº¦';
    result.push(state);

    const add = new RecipeIngredient();
    add.id = 'dmpt'; add.name = 'DMPTè¯±é£Ÿå‰‚'; add.category = 'additive';
    add.percentage = 12; add.weight = 60; add.purpose = 'æ·»åŠ å‰‚ï¼Œæå‡å‘³å‹æµ“åº¦';
    result.push(add);

    return result;
  }


  /**
   * ç”Ÿæˆé…æ–¹åç§°
   */
  private generateRecipeName(input: GenerateRecipeInput, analysis: AnalysisResult, variant: RecipeVariant | null): string {
    let season = '';
    if (input.season === 'spring') season = 'æ˜¥å­£';
    else if (input.season === 'summer') season = 'å¤å­£';
    else if (input.season === 'autumn') season = 'ç§‹å­£';
    else if (input.season === 'winter') season = 'å†¬å­£';

    let water = '';
    if (input.waterType === 'river') water = 'é‡æ²³';
    else if (input.waterType === 'pond') water = 'é»‘å‘';
    else if (input.waterType === 'reservoir') water = 'æ°´åº“';
    else if (input.waterType === 'wild_pond') water = 'é‡å¡˜';

    const fishName = analysis.fishRule ? analysis.fishRule.fishName : 'ç›®æ ‡é±¼';

    let suffix = '';
    if (input.mode === 'conservative') suffix = 'ç¨³';
    else if (input.mode === 'aggressive') suffix = 'çŒ›';
    else suffix = 'è¡¡';

    // æ·»åŠ å˜ä½“æ ‡è¯†
    if (variant !== null) {
      const variantSuffix = this.getVariantSuffix(variant);
      return `${season}${water}${fishName}-${suffix}${variantSuffix}`;
    }

    return `${season}${water}${fishName}-${suffix}`;
  }

  /**
   * è·å–å˜ä½“åç¼€
   */
  private getVariantSuffix(variant: RecipeVariant): string {
    switch (variant.strategy) {
      case 'flavor_shift':
        if (variant.flavorShift?.primaryShift === 'increase_fishy') return 'Â·è…¥';
        if (variant.flavorShift?.primaryShift === 'increase_fragrant') return 'Â·é¦™';
        if (variant.flavorShift?.primaryShift === 'increase_sweet') return 'Â·ç”œ';
        if (variant.flavorShift?.primaryShift === 'increase_sour') return 'Â·é…¸';
        if (variant.flavorShift?.primaryShift === 'decrease_intensity') return 'Â·æ·¡';
        return 'Â·å˜';
      case 'ingredient_swap':
        return 'Â·æ¢';
      case 'additive_change':
        return 'Â·è¯';
      case 'ratio_adjust':
        return 'Â·è°ƒ';
      case 'state_change':
        return 'Â·æ€';
      default:
        return '';
    }
  }

  /**
   * ç”Ÿæˆå‘³å‹è¯´æ˜
   */
  private generateFlavorProfile(weights: FlavorWeights, input: GenerateRecipeInput): FlavorDescription {
    const profile = new FlavorDescription();

    profile.primary = weights.getPrimaryFlavor();
    profile.secondary = weights.getSecondaryFlavor();

    // è®¡ç®—æµ“åº¦ (1-10)
    const avgIntensity = weights.getTotalIntensity() / 5;
    profile.intensity = Math.min(10, Math.max(1, Math.round(avgIntensity / 10)));

    // é€‚ç”¨æ°´æ¸©
    if (input.temperature < 10) {
      profile.suitableTemp = '5-15Â°C';
    } else if (input.temperature < 20) {
      profile.suitableTemp = '10-20Â°C';
    } else if (input.temperature < 28) {
      profile.suitableTemp = '18-28Â°C';
    } else {
      profile.suitableTemp = '25-35Â°C';
    }

    return profile;
  }

  /**
   * ç”ŸæˆçŠ¶æ€ç‰¹æ€§
   */
  private generateStateProfile(weights: StateWeights): StateProfile {
    const profile = new StateProfile();

    // è½¬æ¢ä¸º1-5æ˜Ÿçº§ï¼Œå¢åŠ éšæœºå˜åŒ–
    const randomOffset = (): number => {
      // éšæœº -1, 0, æˆ– +1
      return Math.floor(Math.random() * 3) - 1;
    };

    profile.atomization = Math.min(5, Math.max(1, this.toStarRating(weights.atomization) + randomOffset()));
    profile.viscosity = Math.min(5, Math.max(1, this.toStarRating(weights.viscosity) + randomOffset()));
    profile.hookHolding = Math.min(5, Math.max(1, Math.round(weights.viscosity / 20) + randomOffset()));
    profile.weight = Math.min(5, Math.max(1, this.toStarRating(weights.weight) + randomOffset()));

    return profile;
  }

  /**
   * ç”Ÿæˆä½¿ç”¨å»ºè®®
   */
  private generateUsage(input: GenerateRecipeInput, stateWeights: StateWeights): UsageSuggestion {
    const usage = new UsageSuggestion();

    // æ°´æ¯”
    if (stateWeights.atomization > 60) {
      usage.waterRatio = '1:0.8';
    } else if (stateWeights.atomization > 40) {
      usage.waterRatio = '1:0.9';
    } else {
      usage.waterRatio = '1:1';
    }

    // é™ç½®æ—¶é—´
    if (stateWeights.viscosity > 60) {
      usage.restTime = '10-15åˆ†é’Ÿ';
    } else if (stateWeights.viscosity > 40) {
      usage.restTime = '5-10åˆ†é’Ÿ';
    } else {
      usage.restTime = '3-5åˆ†é’Ÿ';
    }

    // é¦–é’“å»ºè®®
    if (input.fishingMethod === 'rub') {
      usage.firstCast = 'æ“å¤§é¥µæ‰¾é±¼å±‚ï¼Œæœ‰å£åæ”¹å°é¥µ';
    } else if (input.fishingMethod === 'pull') {
      usage.firstCast = 'æ‹‰å°é¥µå¿«é¢‘ç‡ï¼Œè¯±é’“ç»“åˆ';
    } else if (input.fishingMethod === 'scatter') {
      usage.firstCast = 'å…ˆæ‰“æ•£ç‚®è¯±é±¼ï¼Œå†æ“é¥µé’“';
    } else if (input.fishingMethod === 'wrap') {
      usage.firstCast = 'å¤–å±‚é›¾åŒ–è¯±é±¼ï¼Œå†…å±‚ç•™é±¼';
    } else {
      usage.firstCast = 'æ“å¤§é¥µè¯•é±¼å±‚';
    }

    // æ‰“çªå»ºè®®
    if (input.waterType === 'river') {
      usage.nestSuggestion = 'é…’ç±³+é¢—ç²’ï¼Œå°‘é‡å¤šæ¬¡';
    } else if (input.waterType === 'pond') {
      usage.nestSuggestion = 'æ•£ç‚®å¸¦çªï¼Œè¾¹é’“è¾¹è¯±';
    } else if (input.waterType === 'reservoir') {
      usage.nestSuggestion = 'å¤§çªå®ˆé’“ï¼Œç‰ç±³+é¢—ç²’';
    } else {
      usage.nestSuggestion = 'é…’ç±³æ‰“åº•ï¼Œé€‚é‡è¡¥çª';
    }

    return usage;
  }

  /**
   * ç”Ÿæˆæ¨èç†ç”±
   */
  private generateReasons(input: GenerateRecipeInput, analysis: AnalysisResult, variant: RecipeVariant | null): GenerateReason[] {
    const reasons: GenerateReason[] = [];

    // æ¸©åº¦ç†ç”±
    const tempTemplate = getTempReasonTemplate(input.temperature);
    const tempReason = new GenerateReason();
    tempReason.condition = tempTemplate.condition;
    tempReason.decision = tempTemplate.decision;
    tempReason.icon = tempTemplate.icon;
    reasons.push(tempReason);

    // æ°´åŸŸç†ç”±
    const waterTemplate = getWaterReasonTemplate(input.waterType);
    const waterReason = new GenerateReason();
    waterReason.condition = waterTemplate.condition;
    waterReason.decision = waterTemplate.decision;
    waterReason.icon = waterTemplate.icon;
    reasons.push(waterReason);

    // é±¼ç§ç†ç”±
    const fishTemplate = getFishReasonTemplate(input.targetFishId);
    const fishReason = new GenerateReason();
    fishReason.condition = fishTemplate.condition;
    fishReason.decision = fishTemplate.decision;
    fishReason.icon = fishTemplate.icon;
    reasons.push(fishReason);

    // é±¼æƒ…ç†ç”±
    const densityTemplate = getDensityReasonTemplate(input.fishDensity);
    if (densityTemplate !== null) {
      const r = new GenerateReason();
      r.condition = densityTemplate.condition;
      r.decision = densityTemplate.decision;
      r.icon = densityTemplate.icon;
      reasons.push(r);
    }

    // å¼€å£ç†ç”±
    const activityTemplate = getActivityReasonTemplate(input.fishActivity);
    if (activityTemplate !== null) {
      const r = new GenerateReason();
      r.condition = activityTemplate.condition;
      r.decision = activityTemplate.decision;
      r.icon = activityTemplate.icon;
      reasons.push(r);
    }

    // æ¨¡å¼ç†ç”±
    const modeTemplate = getModeReasonTemplate(input.mode);
    if (modeTemplate !== null) {
      const r = new GenerateReason();
      r.condition = modeTemplate.condition;
      r.decision = modeTemplate.decision;
      r.icon = modeTemplate.icon;
      reasons.push(r);
    }

    // å˜ä½“ç†ç”±
    if (variant !== null && variant.description) {
      const variantReason = new GenerateReason();
      variantReason.condition = 'é…æ–¹å˜ä½“';
      variantReason.decision = variant.description;
      variantReason.icon = 'ğŸ”„';
      reasons.push(variantReason);
    }

    // ç‰¹æ®Šåœºæ™¯ç†ç”±
    for (let i = 0; i < analysis.specialScenarios.length; i++) {
      const scenario = analysis.specialScenarios[i];
      const scenarioReason = this.getScenarioReason(scenario);
      if (scenarioReason !== null) {
        reasons.push(scenarioReason);
      }
    }

    return reasons;
  }

  /**
   * è·å–ç‰¹æ®Šåœºæ™¯ç†ç”±
   */
  private getScenarioReason(scenario: string): GenerateReason | null {
    const r = new GenerateReason();

    switch (scenario) {
      case 'extreme_cold':
        r.condition = 'æå¯’å¤©æ°”';
        r.decision = 'é«˜è…¥é«˜è›‹ç™½é…æ–¹';
        r.icon = 'â„ï¸';
        return r;
      case 'extreme_hot':
        r.condition = 'é«˜æ¸©å¤©æ°”';
        r.decision = 'æ¸…æ·¡æœé…¸é…æ–¹';
        r.icon = 'ğŸ”¥';
        return r;
      case 'carnivore_fish':
        r.condition = 'è‚‰é£Ÿæ€§é±¼ç±»';
        r.decision = 'æµ“è…¥å‘³å‹ä¸ºä¸»';
        r.icon = 'ğŸ¦ˆ';
        return r;
      case 'black_pit_new':
        r.condition = 'é»‘å‘æ–°æ”¾é±¼';
        r.decision = 'å¯é€‚å½“åŠ å°è¯';
        r.icon = 'ğŸ†•';
        return r;
      case 'black_pit_old':
        r.condition = 'é»‘å‘è€é±¼';
        r.decision = 'æœ¬å‘³ä¸ºä¸»ï¼Œå‡å°‘åˆºæ¿€';
        r.icon = 'ğŸ¢';
        return r;
      case 'flowing_water':
        r.condition = 'æµæ°´ç¯å¢ƒ';
        r.decision = 'å¢åŠ ç²˜åº¦å’Œæ¯”é‡';
        r.icon = 'ğŸŒŠ';
        return r;
      case 'deep_water':
        r.condition = 'æ·±æ°´åŒºåŸŸ';
        r.decision = 'é‡æ¯”é‡å¿«åˆ°åº•';
        r.icon = 'ğŸ”ï¸';
        return r;
      default:
        return null;
    }
  }

  /**
   * è½¬æ¢ä¸ºæ˜Ÿçº§è¯„åˆ†
   */
  private toStarRating(value: number): number {
    return Math.min(5, Math.max(1, Math.round(value / 20)));
  }

  /**
   * ç”Ÿæˆå”¯ä¸€ID
   */
  private generateId(): string {
    return `recipe_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }

  /**
   * é‡ç½®å˜ä½“å†å²
   */
  resetVariantHistory(): void {
    getVariantManager().resetShownHistory();
    this.variantAttemptIndex = 0;
  }

  /**
   * è·å–å½“å‰å­£èŠ‚
   */
  getCurrentSeason(): RecipeSeason {
    const month = new Date().getMonth() + 1;
    if (month >= 3 && month <= 5) return 'spring';
    if (month >= 6 && month <= 8) return 'summer';
    if (month >= 9 && month <= 11) return 'autumn';
    return 'winter';
  }

  /**
   * è·å–é…ç½®
   */
  getConfig(): EngineConfig {
    return this.config;
  }

  /**
   * è®¾ç½®æ€»é‡é‡
   */
  setTotalWeight(weight: number): void {
    this.config.totalWeight = Math.max(100, Math.min(2000, weight));
  }
}

// å¯¼å‡ºå•ä¾‹è·å–å‡½æ•°
export function getSmartRecipeEngine(): SmartRecipeEngine {
  return SmartRecipeEngine.getInstance();
}

// å¯¼å‡ºä¾¿æ·å‡½æ•°
export function generateSmartRecipe(input: GenerateRecipeInput): GeneratedRecipe {
  return getSmartRecipeEngine().generate(input);
}

export function getNextRecipeVariant(): GeneratedRecipe | null {
  return getSmartRecipeEngine().getNextVariant();
}

export function resetRecipeVariantHistory(): void {
  getSmartRecipeEngine().resetVariantHistory();
}

// è®°å½•é…æ–¹ä¿å­˜ï¼ˆä¾›å¤–éƒ¨è°ƒç”¨ï¼‰
export function recordRecipeSave(recipe: GeneratedRecipe): void {
  const prefLearner = getPreferenceLearner();
  if (prefLearner.isLoaded()) {
    prefLearner.recordSave(recipe);
  }
}

// è®°å½•é…æ–¹åé¦ˆï¼ˆä¾›å¤–éƒ¨è°ƒç”¨ï¼‰
export function recordRecipeFeedback(recipeId: string, rating: 'good' | 'normal' | 'bad', note: string): void {
  const prefLearner = getPreferenceLearner();
  if (prefLearner.isLoaded()) {
    prefLearner.recordFeedback(recipeId, rating, note);
  }
}
