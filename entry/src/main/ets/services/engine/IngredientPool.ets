/**
 * åŸæ–™æ±?
 * ç®¡ç†æ‰€æœ‰å¯ç”¨åŸæ–™ï¼Œæ”¯æŒå¤šç»´åº¦ç­›é€‰å’ŒåŒ¹é…
 */
import { Ingredient, IngredientCategory, Season, getAllIngredients, getIngredientById } from '../../data/IngredientDatabase';
import { FlavorWeights, StateWeights } from './ContextAnalyzer';
import { FishingMethod } from '../../common/types/RecipeTypes';
import { getPreferenceLearner } from './PreferenceLearner';

// å¸¦åˆ†æ•°çš„åŸæ–™
export class ScoredIngredient {
  ingredient: Ingredient;
  score: number = 0;
  matchReasons: string[] = [];

  constructor(ing: Ingredient) {
    this.ingredient = ing;
  }
}

// åŸæ–™æ±?
export class IngredientPool {
  private static instance: IngredientPool | null = null;
  private ingredients: Ingredient[] = [];
  private categoryIndex: Map<string, string[]> = new Map();  // category -> id[]
  private fishIndex: Map<string, string[]> = new Map();      // fishId -> id[]
  private seasonIndex: Map<string, string[]> = new Map();    // season -> id[]
  private initialized: boolean = false;
  private usePreference: boolean = true;  // æ˜¯å¦ä½¿ç”¨åå¥½åŠ æˆ

  private constructor() {}

  static getInstance(): IngredientPool {
    if (IngredientPool.instance === null) {
      IngredientPool.instance = new IngredientPool();
    }
    return IngredientPool.instance;
  }

  /**
   * åˆå§‹åŒ–ç´¢å¼?
   */
  initialize(): void {
    if (this.initialized) return;

    this.ingredients = getAllIngredients();

    // æ„å»ºç±»åˆ«ç´¢å¼•
    for (let i = 0; i < this.ingredients.length; i++) {
      const ing = this.ingredients[i];

      // ç±»åˆ«ç´¢å¼•
      const catIds = this.categoryIndex.get(ing.category) || [];
      catIds.push(ing.id);
      this.categoryIndex.set(ing.category, catIds);

      // é±¼ç§ç´¢å¼•
      for (let j = 0; j < ing.targetFish.length; j++) {
        const fishId = ing.targetFish[j];
        const fishIds = this.fishIndex.get(fishId) || [];
        fishIds.push(ing.id);
        this.fishIndex.set(fishId, fishIds);
      }

      // å­£èŠ‚ç´¢å¼•
      for (let j = 0; j < ing.suitableSeason.length; j++) {
        const season = ing.suitableSeason[j];
        const seasonIds = this.seasonIndex.get(season) || [];
        seasonIds.push(ing.id);
        this.seasonIndex.set(season, seasonIds);
      }
    }

    this.initialized = true;
  }

  /**
   * æŒ‰å‘³å‹æƒé‡åŒ¹é…åŸæ–?
   */
  matchByFlavor(
    weights: FlavorWeights,
    candidateIds: string[],
    count: number,
    excludeIds: string[] = []
  ): ScoredIngredient[] {
    this.initialize();
    const scored: ScoredIngredient[] = [];

    for (let i = 0; i < candidateIds.length; i++) {
      const id = candidateIds[i];

      // æ’é™¤å·²é€‰åŸæ–?
      let excluded = false;
      for (let j = 0; j < excludeIds.length; j++) {
        if (excludeIds[j] === id) {
          excluded = true;
          break;
        }
      }
      if (excluded) continue;

      const ing = getIngredientById(id);
      if (ing === null) continue;

      const scoredIng = new ScoredIngredient(ing);
      const fp = ing.flavorProfile;

      // è®¡ç®—å‘³å‹åŒ¹é…åˆ†æ•°
      // ä½¿ç”¨åŠ æƒåŒ¹é…ï¼šåŸæ–™å‘³å‹ä¸ç›®æ ‡æƒé‡çš„åŒ¹é…åº¦
      let score = 0;
      const reasons: string[] = [];

      // è…¥å‘³åŒ¹é…
      if (weights.fishy > 50 && fp.fishy > 50) {
        score += Math.min(fp.fishy, weights.fishy) * 0.3;
        if (fp.fishy > 70) reasons.push('è…¥å‘³æµ“éƒ');
      } else if (weights.fishy < 30 && fp.fishy < 30) {
        score += 20; // éƒ½ä¸éœ€è¦è…¥å‘³ä¹Ÿæ˜¯åŒ¹é…?
      }

      // é¦™å‘³åŒ¹é…
      if (weights.fragrant > 50 && fp.fragrant > 50) {
        score += Math.min(fp.fragrant, weights.fragrant) * 0.25;
        if (fp.fragrant > 70) reasons.push('é¦™å‘³çªå‡º');
      }

      // ç”œå‘³åŒ¹é…
      if (weights.sweet > 50 && fp.sweet > 50) {
        score += Math.min(fp.sweet, weights.sweet) * 0.2;
        if (fp.sweet > 70) reasons.push('ç”œå‘³æ˜æ˜¾');
      }

      // é…¸å‘³åŒ¹é…
      if (weights.sour > 40 && fp.sour > 40) {
        score += Math.min(fp.sour, weights.sour) * 0.15;
        if (fp.sour > 60) reasons.push('é…¸å‘³é€‚ä¸­');
      }

      // è‡­å‘³åŒ¹é…
      if (weights.stinky > 40 && fp.stinky > 40) {
        score += Math.min(fp.stinky, weights.stinky) * 0.1;
        if (fp.stinky > 60) reasons.push('è‡­å‘³ç‹¬ç‰¹');
      }

      // åŠ å…¥éšæœºå› å­å¢åŠ å˜åŒ– (0-15åˆ?
      score += Math.random() * 15;

      // åº”ç”¨ç”¨æˆ·åå¥½åŠ æˆ (0-20åˆ?
      if (this.usePreference) {
        const prefLearner = getPreferenceLearner();
        if (prefLearner.isLoaded()) {
          const prefBoost = prefLearner.getPreferenceBoost(id);
          if (prefBoost > 0) {
            score += prefBoost;
            if (prefBoost >= 10) reasons.push('å¸¸ç”¨åŸæ–™');
          }
        }
      }

      scoredIng.score = score;
      scoredIng.matchReasons = reasons;
      scored.push(scoredIng);
    }

    // æŒ‰åˆ†æ•°æ’åº?
    scored.sort((a: ScoredIngredient, b: ScoredIngredient): number => b.score - a.score);

    // è¿”å›å‰Nä¸?
    const result: ScoredIngredient[] = [];
    const maxCount = Math.min(count, scored.length);
    for (let i = 0; i < maxCount; i++) {
      result.push(scored[i]);
    }
    return result;
  }


  /**
   * æŒ‰çŠ¶æ€æƒé‡åŒ¹é…åŸæ–?
   */
  matchByState(
    weights: StateWeights,
    candidateIds: string[],
    method: FishingMethod,
    count: number,
    excludeIds: string[] = []
  ): ScoredIngredient[] {
    this.initialize();
    const scored: ScoredIngredient[] = [];

    for (let i = 0; i < candidateIds.length; i++) {
      const id = candidateIds[i];

      // æ’é™¤å·²é€‰åŸæ–?
      let excluded = false;
      for (let j = 0; j < excludeIds.length; j++) {
        if (excludeIds[j] === id) {
          excluded = true;
          break;
        }
      }
      if (excluded) continue;

      const ing = getIngredientById(id);
      if (ing === null) continue;

      const scoredIng = new ScoredIngredient(ing);
      const phys = ing.physical;
      let score = 0;
      const reasons: string[] = [];

      // é›¾åŒ–åŒ¹é…
      if (weights.atomization > 60) {
        // éœ€è¦å¿«é›¾åŒ–
        score += phys.atomization * 8;
        if (phys.atomization > 7) reasons.push('é›¾åŒ–å¿?);
      } else if (weights.atomization < 40) {
        // éœ€è¦æ…¢é›¾åŒ–
        score += (10 - phys.atomization) * 8;
        if (phys.atomization < 4) reasons.push('é›¾åŒ–æ…?);
      } else {
        score += 30; // ä¸­ç­‰é›¾åŒ–
      }

      // ç²˜åº¦åŒ¹é…
      if (weights.viscosity > 60) {
        score += phys.viscosity * 6;
        if (phys.viscosity > 7) reasons.push('ç²˜æ€§å¼º');
      } else if (weights.viscosity < 40) {
        score += (10 - phys.viscosity) * 6;
      }

      // æ¯”é‡åŒ¹é…
      if (weights.weight > 60) {
        score += phys.weight * 5;
        if (phys.weight > 7) reasons.push('æ¯”é‡å¤?);
      } else if (weights.weight < 40) {
        score += (10 - phys.weight) * 5;
        if (phys.weight < 4) reasons.push('æ¯”é‡è½?);
      }

      // ä½œé’“æ–¹å¼ç‰¹æ®ŠåŠ åˆ†
      if (method === 'pull' && id === 'drawing_powder') {
        score += 50;
        reasons.push('æ‹‰é¥µå¿…å¤‡');
      }
      if (method === 'scatter' && id === 'snowflake_powder') {
        score += 50;
        reasons.push('æ•£ç‚®å¿…å¤‡');
      }
      if (method === 'scatter' && id === 'light_bran') {
        score += 40;
        reasons.push('æ•£ç‚®æ¨è');
      }

      // éšæœºå› å­
      score += Math.random() * 10;

      scoredIng.score = score;
      scoredIng.matchReasons = reasons;
      scored.push(scoredIng);
    }

    scored.sort((a: ScoredIngredient, b: ScoredIngredient): number => b.score - a.score);

    const result: ScoredIngredient[] = [];
    const maxCount = Math.min(count, scored.length);
    for (let i = 0; i < maxCount; i++) {
      result.push(scored[i]);
    }
    return result;
  }

  /**
   * æŒ‰é±¼ç§ç­›é€‰åŸæ–™ID
   */
  filterByFish(fishId: string): string[] {
    this.initialize();
    return this.fishIndex.get(fishId) || [];
  }

  /**
   * æŒ‰å­£èŠ‚ç­›é€‰åŸæ–™ID
   */
  filterBySeason(season: Season): string[] {
    this.initialize();
    return this.seasonIndex.get(season) || [];
  }

  /**
   * æŒ‰ç±»åˆ«è·å–åŸæ–™ID
   */
  getByCategory(category: IngredientCategory): string[] {
    this.initialize();
    return this.categoryIndex.get(category) || [];
  }

  /**
   * è·å–æ›¿ä»£åŸæ–™
   * æ‰¾åˆ°ä¸æŒ‡å®šåŸæ–™å‘³å‹ç›¸ä¼¼çš„å…¶ä»–åŸæ–™
   */
  getAlternatives(ingredientId: string, count: number = 3): Ingredient[] {
    this.initialize();
    const original = getIngredientById(ingredientId);
    if (original === null) return [];

    const alternatives: ScoredIngredient[] = [];
    const sameCategory = this.categoryIndex.get(original.category) || [];

    for (let i = 0; i < sameCategory.length; i++) {
      const id = sameCategory[i];
      if (id === ingredientId) continue;

      const ing = getIngredientById(id);
      if (ing === null) continue;

      // è®¡ç®—å‘³å‹ç›¸ä¼¼åº?
      const scoredIng = new ScoredIngredient(ing);
      let similarity = 100;

      // å‘³å‹å·®å¼‚è¶Šå°ï¼Œç›¸ä¼¼åº¦è¶Šé«˜
      similarity -= Math.abs(original.flavorProfile.fishy - ing.flavorProfile.fishy) * 0.3;
      similarity -= Math.abs(original.flavorProfile.fragrant - ing.flavorProfile.fragrant) * 0.3;
      similarity -= Math.abs(original.flavorProfile.sweet - ing.flavorProfile.sweet) * 0.2;
      similarity -= Math.abs(original.flavorProfile.sour - ing.flavorProfile.sour) * 0.1;
      similarity -= Math.abs(original.flavorProfile.stinky - ing.flavorProfile.stinky) * 0.1;

      scoredIng.score = Math.max(0, similarity);
      alternatives.push(scoredIng);
    }

    alternatives.sort((a: ScoredIngredient, b: ScoredIngredient): number => b.score - a.score);

    const result: Ingredient[] = [];
    const maxCount = Math.min(count, alternatives.length);
    for (let i = 0; i < maxCount; i++) {
      result.push(alternatives[i].ingredient);
    }
    return result;
  }

  /**
   * è·å–äº’è¡¥åŸæ–™
   * æ‰¾åˆ°èƒ½è¡¥å……æŒ‡å®šåŸæ–™ç¼ºå¤±å‘³å‹çš„åŸæ–™
   */
  getComplementary(ingredientId: string, targetWeights: FlavorWeights, count: number = 2): Ingredient[] {
    this.initialize();
    const original = getIngredientById(ingredientId);
    if (original === null) return [];

    // è®¡ç®—ç¼ºå¤±çš„å‘³å?
    const missing = new FlavorWeights();
    missing.fishy = Math.max(0, targetWeights.fishy - original.flavorProfile.fishy);
    missing.fragrant = Math.max(0, targetWeights.fragrant - original.flavorProfile.fragrant);
    missing.sweet = Math.max(0, targetWeights.sweet - original.flavorProfile.sweet);
    missing.sour = Math.max(0, targetWeights.sour - original.flavorProfile.sour);
    missing.stinky = Math.max(0, targetWeights.stinky - original.flavorProfile.stinky);

    // åœ¨æ‰€æœ‰åŸæ–™ä¸­æ‰¾èƒ½è¡¥å……ç¼ºå¤±å‘³å‹çš?
    const complementary: ScoredIngredient[] = [];

    for (let i = 0; i < this.ingredients.length; i++) {
      const ing = this.ingredients[i];
      if (ing.id === ingredientId) continue;
      if (ing.category === 'live' || ing.category === 'folk') continue; // æ’é™¤æ´»é¥µå’Œé‚ªä¿?

      const scoredIng = new ScoredIngredient(ing);
      let score = 0;

      // èƒ½è¡¥å……ç¼ºå¤±å‘³å‹çš„å¾—åˆ†é«?
      if (missing.fishy > 30 && ing.flavorProfile.fishy > 50) {
        score += ing.flavorProfile.fishy * 0.3;
      }
      if (missing.fragrant > 30 && ing.flavorProfile.fragrant > 50) {
        score += ing.flavorProfile.fragrant * 0.25;
      }
      if (missing.sweet > 30 && ing.flavorProfile.sweet > 50) {
        score += ing.flavorProfile.sweet * 0.2;
      }
      if (missing.sour > 30 && ing.flavorProfile.sour > 40) {
        score += ing.flavorProfile.sour * 0.15;
      }
      if (missing.stinky > 30 && ing.flavorProfile.stinky > 40) {
        score += ing.flavorProfile.stinky * 0.1;
      }

      scoredIng.score = score;
      complementary.push(scoredIng);
    }

    complementary.sort((a: ScoredIngredient, b: ScoredIngredient): number => b.score - a.score);

    const result: Ingredient[] = [];
    const maxCount = Math.min(count, complementary.length);
    for (let i = 0; i < maxCount; i++) {
      if (complementary[i].score > 10) { // åªè¿”å›æœ‰æ„ä¹‰çš„è¡¥å…?
        result.push(complementary[i].ingredient);
      }
    }
    return result;
  }

  /**
   * è·å–åŸæ–™æ€»æ•°
   */
  getIngredientCount(): number {
    this.initialize();
    return this.ingredients.length;
  }

  /**
   * è·å–æ‰€æœ‰åŸæ–?
   */
  getAllIngredients(): Ingredient[] {
    this.initialize();
    return this.ingredients;
  }

  /**
   * è®¾ç½®æ˜¯å¦ä½¿ç”¨åå¥½åŠ æˆ
   */
  setUsePreference(use: boolean): void {
    this.usePreference = use;
  }

  /**
   * è·å–æ˜¯å¦ä½¿ç”¨åå¥½åŠ æˆ
   */
  getUsePreference(): boolean {
    return this.usePreference;
  }
}

// å¯¼å‡ºå•ä¾‹è·å–å‡½æ•°
export function getIngredientPool(): IngredientPool {
  return IngredientPool.getInstance();
}
