/**
 * å˜ä½“ç®¡ç†å™?
 * ç®¡ç†é…æ–¹å˜ä½“ï¼Œç¡®ä¿?æ¢ä¸€æ?åŠŸèƒ½èƒ½æä¾›çœŸæ­£ä¸åŒçš„é…æ–¹
 */
import { GeneratedRecipe, RecipeIngredient, GenerateRecipeInput } from '../../common/types/RecipeTypes';
import { FlavorWeights, StateWeights, AnalysisResult } from './ContextAnalyzer';

// å˜ä½“ç­–ç•¥
export type VariantStrategy =
  'flavor_shift' |      // å‘³å‹åç§» (å¦‚è…¥é¦™â†’é¦™è…¥)
  'ingredient_swap' |   // åŸæ–™æ›¿æ¢
  'additive_change' |   // æ·»åŠ å‰‚æ›´æ?
  'ratio_adjust' |      // é…æ¯”è°ƒæ•´
  'state_change';       // çŠ¶æ€æ”¹å?

// é…æ–¹å˜ä½“
export class RecipeVariant {
  id: string = '';
  strategy: VariantStrategy = 'ingredient_swap';
  baseRecipeId: string = '';
  differenceScore: number = 0;  // ä¸åŸºå‡†é…æ–¹çš„å·®å¼‚åº?(0-100)
  description: string = '';     // å˜ä½“æè¿°

  // å˜ä½“å‚æ•°è°ƒæ•´
  flavorShift: FlavorShiftParams | null = null;
  ingredientSwaps: IngredientSwap[] = [];
  ratioAdjustments: RatioAdjustment[] = [];

  constructor() {
    this.id = `variant_${Date.now()}_${Math.random().toString(36).substring(2, 6)}`;
  }
}

// å‘³å‹åç§»å‚æ•°
export class FlavorShiftParams {
  primaryShift: string = '';    // ä¸»å‘³å‹å˜åŒ–æ–¹å?
  intensityChange: number = 0;  // æµ“åº¦å˜åŒ– (-20 åˆ?+20)

  constructor() {}

  static create(shift: string, intensity: number): FlavorShiftParams {
    const p = new FlavorShiftParams();
    p.primaryShift = shift;
    p.intensityChange = intensity;
    return p;
  }
}

// åŸæ–™æ›¿æ¢
export class IngredientSwap {
  originalId: string = '';
  replacementId: string = '';
  reason: string = '';

  constructor() {}

  static create(orig: string, repl: string, reason: string): IngredientSwap {
    const s = new IngredientSwap();
    s.originalId = orig;
    s.replacementId = repl;
    s.reason = reason;
    return s;
  }
}

// é…æ¯”è°ƒæ•´
export class RatioAdjustment {
  ingredientId: string = '';
  originalRatio: number = 0;
  newRatio: number = 0;

  constructor() {}

  static create(id: string, orig: number, newR: number): RatioAdjustment {
    const a = new RatioAdjustment();
    a.ingredientId = id;
    a.originalRatio = orig;
    a.newRatio = newR;
    return a;
  }
}

// å˜ä½“ç”Ÿæˆé…ç½®
export class VariantConfig {
  minDifference: number = 25;   // æœ€å°å·®å¼‚åº¦è¦æ±‚
  maxAttempts: number = 10;     // æœ€å¤§å°è¯•æ¬¡æ•?
  strategies: VariantStrategy[] = ['ingredient_swap', 'flavor_shift', 'additive_change', 'ratio_adjust'];

  constructor() {}
}

// é…æ¯”è°ƒæ•´æ¨¡å¼
export class RatioPattern {
  main: number = 0;
  aux: number = 0;
  state: number = 0;
  additive: number = 0;

  constructor() {}

  static create(main: number, aux: number, state: number = 0, additive: number = 0): RatioPattern {
    const p = new RatioPattern();
    p.main = main;
    p.aux = aux;
    p.state = state;
    p.additive = additive;
    return p;
  }
}

// å˜ä½“ç®¡ç†å™?
export class VariantManager {
  private static instance: VariantManager | null = null;

  // å·²å±•ç¤ºçš„å˜ä½“è®°å½• (conditionHash -> Set<variantId>)
  private shownVariants: Map<string, Set<string>> = new Map();

  // å˜ä½“ç¼“å­˜ (conditionHash -> RecipeVariant[])
  private variantCache: Map<string, RecipeVariant[]> = new Map();

  // å½“å‰ä¼šè¯çš„é…æ–¹å†å?(ç”¨äºè®¡ç®—å·®å¼‚)
  private sessionRecipes: GeneratedRecipe[] = [];

  // é…ç½®
  private config: VariantConfig = new VariantConfig();

  private constructor() {}

  static getInstance(): VariantManager {
    if (VariantManager.instance === null) {
      VariantManager.instance = new VariantManager();
    }
    return VariantManager.instance;
  }

  /**
   * ç”Ÿæˆå˜ä½“å‚æ•°
   * è¿”å›ç”¨äºç”Ÿæˆä¸åŒé…æ–¹çš„å‚æ•°è°ƒæ•?
   */
  generateVariantParams(
    baseRecipe: GeneratedRecipe,
    analysisResult: AnalysisResult,
    attemptIndex: number
  ): RecipeVariant {
    const variant = new RecipeVariant();
    variant.baseRecipeId = baseRecipe.id;

    // æ ¹æ®å°è¯•æ¬¡æ•°é€‰æ‹©ä¸åŒç­–ç•¥
    const strategyIndex = attemptIndex % this.config.strategies.length;
    variant.strategy = this.config.strategies[strategyIndex];

    switch (variant.strategy) {
      case 'flavor_shift':
        this.applyFlavorShiftStrategy(variant, analysisResult, attemptIndex);
        break;
      case 'ingredient_swap':
        this.applyIngredientSwapStrategy(variant, baseRecipe, attemptIndex);
        break;
      case 'additive_change':
        this.applyAdditiveChangeStrategy(variant, baseRecipe, attemptIndex);
        break;
      case 'ratio_adjust':
        this.applyRatioAdjustStrategy(variant, baseRecipe, attemptIndex);
        break;
      case 'state_change':
        this.applyStateChangeStrategy(variant, analysisResult, attemptIndex);
        break;
    }

    return variant;
  }


  /**
   * å‘³å‹åç§»ç­–ç•¥
   */
  private applyFlavorShiftStrategy(variant: RecipeVariant, analysis: AnalysisResult, index: number): void {
    const shifts = ['increase_fishy', 'increase_fragrant', 'increase_sweet', 'decrease_intensity', 'increase_sour'];
    const shiftType = shifts[index % shifts.length];

    let intensityChange = 0;
    let description = '';

    switch (shiftType) {
      case 'increase_fishy':
        intensityChange = 15 + (index % 3) * 5;
        description = 'å¢åŠ è…¥å‘³æ¯”ä¾‹';
        break;
      case 'increase_fragrant':
        intensityChange = 15 + (index % 3) * 5;
        description = 'å¢åŠ é¦™å‘³æ¯”ä¾‹';
        break;
      case 'increase_sweet':
        intensityChange = 10 + (index % 3) * 5;
        description = 'å¢åŠ ç”œå‘³æ¯”ä¾‹';
        break;
      case 'decrease_intensity':
        intensityChange = -15 - (index % 3) * 5;
        description = 'æ•´ä½“å‘³å‹å‡æ·¡';
        break;
      case 'increase_sour':
        intensityChange = 10 + (index % 2) * 5;
        description = 'å¢åŠ é…¸å‘³æ¯”ä¾‹';
        break;
    }

    variant.flavorShift = FlavorShiftParams.create(shiftType, intensityChange);
    variant.description = description;
    variant.differenceScore = 20 + Math.abs(intensityChange);
  }

  /**
   * åŸæ–™æ›¿æ¢ç­–ç•¥
   */
  private applyIngredientSwapStrategy(variant: RecipeVariant, baseRecipe: GeneratedRecipe, index: number): void {
    // æ ¹æ®indexå†³å®šæ›¿æ¢å“ªç±»åŸæ–™
    const categories = ['main', 'auxiliary', 'additive', 'state'];
    const targetCategory = categories[index % categories.length];

    // æ‰¾åˆ°è¯¥ç±»åˆ«çš„åŸæ–™
    for (let i = 0; i < baseRecipe.ingredients.length; i++) {
      const ing = baseRecipe.ingredients[i];
      if (ing.category === targetCategory) {
        // ç”Ÿæˆæ›¿æ¢å»ºè®®
        const swap = new IngredientSwap();
        swap.originalId = ing.id;
        swap.replacementId = this.getAlternativeIngredientId(ing.id, ing.category, index);
        swap.reason = `æ›´æ¢${this.getCategoryName(targetCategory)}`;
        variant.ingredientSwaps.push(swap);
        break;
      }
    }

    variant.description = `æ›´æ¢${this.getCategoryName(targetCategory)}`;
    variant.differenceScore = 30 + (index % 3) * 10;
  }

  /**
   * æ·»åŠ å‰‚æ›´æ¢ç­–ç•?
   */
  private applyAdditiveChangeStrategy(variant: RecipeVariant, baseRecipe: GeneratedRecipe, index: number): void {
    // ä¸“é—¨é’ˆå¯¹æ·»åŠ å‰‚çš„æ›¿æ¢
    for (let i = 0; i < baseRecipe.ingredients.length; i++) {
      const ing = baseRecipe.ingredients[i];
      if (ing.category === 'additive') {
        const swap = new IngredientSwap();
        swap.originalId = ing.id;
        swap.replacementId = this.getAlternativeAdditiveId(ing.id, index);
        swap.reason = 'æ›´æ¢æ·»åŠ å‰‚ç±»å?;
        variant.ingredientSwaps.push(swap);
      }
    }

    variant.description = 'æ›´æ¢æ·»åŠ å‰‚é…æ–?;
    variant.differenceScore = 25 + (index % 4) * 8;
  }

  /**
   * é…æ¯”è°ƒæ•´ç­–ç•¥
   */
  private applyRatioAdjustStrategy(variant: RecipeVariant, baseRecipe: GeneratedRecipe, index: number): void {
    // è°ƒæ•´ä¸»é¥µå’Œè¾…é¥µçš„æ¯”ä¾‹
    const adjustmentPatterns: RatioPattern[] = [
      RatioPattern.create(5, -5, 0, 0),      // å¢åŠ ä¸»é¥µ
      RatioPattern.create(-5, 5, 0, 0),      // å¢åŠ è¾…é¥µ
      RatioPattern.create(0, -5, 5, 0),      // å¢åŠ çŠ¶æ€é¥µ
      RatioPattern.create(-3, -2, 0, 5)      // å¢åŠ æ·»åŠ å‰?
    ];

    const pattern = adjustmentPatterns[index % adjustmentPatterns.length];

    for (let i = 0; i < baseRecipe.ingredients.length; i++) {
      const ing = baseRecipe.ingredients[i];
      let adjustment = 0;

      if (ing.category === 'main') {
        adjustment = pattern.main;
      } else if (ing.category === 'auxiliary') {
        adjustment = pattern.aux;
      } else if (ing.category === 'state') {
        adjustment = pattern.state;
      } else if (ing.category === 'additive') {
        adjustment = pattern.additive;
      }

      if (adjustment !== 0) {
        const ratioAdj = RatioAdjustment.create(
          ing.id,
          ing.percentage,
          Math.max(5, Math.min(60, ing.percentage + adjustment))
        );
        variant.ratioAdjustments.push(ratioAdj);
      }
    }

    variant.description = 'è°ƒæ•´é…æ¯”æ¯”ä¾‹';
    variant.differenceScore = 15 + (index % 3) * 5;
  }

  /**
   * çŠ¶æ€æ”¹å˜ç­–ç•?
   */
  private applyStateChangeStrategy(variant: RecipeVariant, analysis: AnalysisResult, index: number): void {
    // æ”¹å˜çŠ¶æ€é¥µé€‰æ‹©
    const stateChanges = ['more_atomization', 'more_viscosity', 'lighter', 'heavier'];
    const changeType = stateChanges[index % stateChanges.length];

    let description = '';
    switch (changeType) {
      case 'more_atomization':
        description = 'å¢åŠ é›¾åŒ–æ•ˆæœ';
        break;
      case 'more_viscosity':
        description = 'å¢åŠ ç²˜åº¦';
        break;
      case 'lighter':
        description = 'å‡è½»æ¯”é‡';
        break;
      case 'heavier':
        description = 'å¢åŠ æ¯”é‡';
        break;
    }

    variant.flavorShift = FlavorShiftParams.create(changeType, 0);
    variant.description = description;
    variant.differenceScore = 20 + (index % 3) * 8;
  }

  /**
   * è·å–æ›¿ä»£åŸæ–™ID
   */
  private getAlternativeIngredientId(originalId: string, category: string, index: number): string {
    // ä¸»é¥µæ›¿ä»£åˆ—è¡¨
    const mainAlternatives: Map<string, string[]> = new Map();
    mainAlternatives.set('corn_flour', ['wheat_bran', 'sweet_potato_flour', 'soybean_flour', 'rice_bran']);
    mainAlternatives.set('wheat_bran', ['corn_flour', 'rice_bran', 'bread_crumb', 'soybean_cake']);
    mainAlternatives.set('soybean_flour', ['peanut_flour', 'corn_flour', 'sesame_flour']);
    mainAlternatives.set('sweet_potato_flour', ['potato_flour', 'corn_flour', 'soybean_flour']);

    // è¾…é¥µæ›¿ä»£åˆ—è¡¨
    const auxAlternatives: Map<string, string[]> = new Map();
    auxAlternatives.set('fish_meal', ['shrimp_powder', 'silkworm_pupa_powder', 'squid_powder']);
    auxAlternatives.set('shrimp_powder', ['fish_meal', 'crab_powder', 'clam_powder']);
    auxAlternatives.set('silkworm_pupa_powder', ['fish_meal', 'earthworm_powder', 'bloodworm_powder']);

    // çŠ¶æ€é¥µæ›¿ä»£åˆ—è¡¨
    const stateAlternatives: Map<string, string[]> = new Map();
    stateAlternatives.set('drawing_powder', ['snowflake_powder', 'light_bran', 'sticky_powder']);
    stateAlternatives.set('snowflake_powder', ['light_bran', 'puffed_corn', 'drawing_powder']);
    stateAlternatives.set('sticky_powder', ['glutinous_rice_flour', 'tapioca_starch', 'drawing_powder']);

    let alternatives: string[] = [];
    if (category === 'main') {
      alternatives = mainAlternatives.get(originalId) || ['corn_flour', 'wheat_bran', 'soybean_flour'];
    } else if (category === 'auxiliary') {
      alternatives = auxAlternatives.get(originalId) || ['fish_meal', 'shrimp_powder', 'silkworm_pupa_powder'];
    } else if (category === 'state') {
      alternatives = stateAlternatives.get(originalId) || ['drawing_powder', 'snowflake_powder', 'sticky_powder'];
    }

    return alternatives[index % alternatives.length];
  }

  /**
   * è·å–æ›¿ä»£æ·»åŠ å‰‚ID
   */
  private getAlternativeAdditiveId(originalId: string, index: number): string {
    const additiveGroups: string[][] = [
      ['dmpt', 'betaine', 'amino_acid'],           // è¯±é£Ÿå‰‚ç»„
      ['vanilla_essence', 'strawberry_essence', 'banana_essence', 'honey_essence'],  // ç”œé¦™ç»?
      ['garlic_essence', 'anise_essence', 'fishy_essence'],  // ç‰¹æ®Šé¦™å‹ç»?
      ['white_sugar', 'brown_sugar', 'honey'],     // ç”œå‘³ç»?
      ['sesame_oil', 'peanut_oil', 'fish_oil']     // æ²¹ç±»ç»?
    ];

    // æ‰¾åˆ°åŸæ–™æ‰€åœ¨çš„ç»?
    let groupIndex = -1;
    let posInGroup = -1;
    for (let i = 0; i < additiveGroups.length; i++) {
      for (let j = 0; j < additiveGroups[i].length; j++) {
        if (additiveGroups[i][j] === originalId) {
          groupIndex = i;
          posInGroup = j;
          break;
        }
      }
      if (groupIndex >= 0) break;
    }

    if (groupIndex >= 0) {
      // åœ¨åŒç»„å†…é€‰æ‹©ä¸åŒçš?
      const group = additiveGroups[groupIndex];
      const newPos = (posInGroup + 1 + index) % group.length;
      return group[newPos];
    }

    // é»˜è®¤è¿”å›å¸¸ç”¨æ·»åŠ å‰?
    const defaults = ['dmpt', 'honey_essence', 'garlic_essence', 'white_sugar'];
    return defaults[index % defaults.length];
  }

  /**
   * è·å–ç±»åˆ«åç§°
   */
  private getCategoryName(category: string): string {
    if (category === 'main') return 'ä¸»é¥µ';
    if (category === 'auxiliary') return 'è¾…é¥µ';
    if (category === 'state') return 'çŠ¶æ€é¥µ';
    if (category === 'additive') return 'æ·»åŠ å‰?;
    return 'åŸæ–™';
  }

  /**
   * è®°å½•å·²å±•ç¤ºçš„é…æ–¹
   */
  recordShownRecipe(conditionHash: string, recipe: GeneratedRecipe): void {
    // è®°å½•åˆ°å·²å±•ç¤ºé›†åˆ
    let shown = this.shownVariants.get(conditionHash);
    if (!shown) {
      shown = new Set<string>();
      this.shownVariants.set(conditionHash, shown);
    }
    shown.add(recipe.id);

    // è®°å½•åˆ°ä¼šè¯å†å?
    this.sessionRecipes.push(recipe);

    // é™åˆ¶å†å²å¤§å°
    if (this.sessionRecipes.length > 20) {
      this.sessionRecipes.shift();
    }
  }

  /**
   * è·å–å·²å±•ç¤ºçš„é…æ–¹æ•°é‡
   */
  getShownCount(conditionHash: string): number {
    const shown = this.shownVariants.get(conditionHash);
    return shown ? shown.size : 0;
  }

  /**
   * æ£€æŸ¥é…æ–¹æ˜¯å¦ä¸å†å²é…æ–¹é‡å¤
   */
  isDuplicateRecipe(recipe: GeneratedRecipe): boolean {
    for (let i = 0; i < this.sessionRecipes.length; i++) {
      if (this.calculateRecipeDifference(recipe, this.sessionRecipes[i]) < this.config.minDifference) {
        return true;
      }
    }
    return false;
  }

  /**
   * è®¡ç®—ä¸¤ä¸ªé…æ–¹çš„å·®å¼‚åº¦
   */
  calculateRecipeDifference(recipe1: GeneratedRecipe, recipe2: GeneratedRecipe): number {
    let ingredientDiff = 0;
    let flavorDiff = 0;
    let stateDiff = 0;

    // 1. åŸæ–™å·®å¼‚ (æƒé‡50%)
    const ids1 = new Set<string>();
    const ids2 = new Set<string>();
    for (let i = 0; i < recipe1.ingredients.length; i++) {
      ids1.add(recipe1.ingredients[i].id);
    }
    for (let i = 0; i < recipe2.ingredients.length; i++) {
      ids2.add(recipe2.ingredients[i].id);
    }

    // è®¡ç®—ä¸åŒçš„åŸæ–™æ•°é‡?
    let diffCount = 0;
    ids1.forEach((id) => {
      if (!ids2.has(id)) diffCount++;
    });
    ids2.forEach((id) => {
      if (!ids1.has(id)) diffCount++;
    });

    ingredientDiff = diffCount * 15; // æ¯ä¸ªä¸åŒåŸæ–™15åˆ?

    // 2. å‘³å‹å·®å¼‚ (æƒé‡30%)
    const fp1 = recipe1.flavorProfile;
    const fp2 = recipe2.flavorProfile;
    if (fp1.primary !== fp2.primary) flavorDiff += 20;
    if (fp1.secondary !== fp2.secondary) flavorDiff += 10;
    flavorDiff += Math.abs(fp1.intensity - fp2.intensity) * 3;

    // 3. çŠ¶æ€å·®å¼?(æƒé‡20%)
    const sp1 = recipe1.stateProfile;
    const sp2 = recipe2.stateProfile;
    stateDiff += Math.abs(sp1.atomization - sp2.atomization) * 4;
    stateDiff += Math.abs(sp1.viscosity - sp2.viscosity) * 3;
    stateDiff += Math.abs(sp1.weight - sp2.weight) * 3;

    // ç»¼åˆå·®å¼‚åº?
    const totalDiff = ingredientDiff * 0.5 + flavorDiff * 0.3 + stateDiff * 0.2;
    return Math.min(100, totalDiff);
  }

  /**
   * ç”Ÿæˆæ¡ä»¶å“ˆå¸Œ
   */
  hashConditions(input: GenerateRecipeInput): string {
    return `${input.targetFishId}_${input.waterType}_${input.season}_${input.mode}`;
  }

  /**
   * é‡ç½®å·²å±•ç¤ºå†å?
   */
  resetShownHistory(): void {
    this.shownVariants.clear();
    this.sessionRecipes = [];
  }

  /**
   * é‡ç½®ç‰¹å®šæ¡ä»¶çš„å†å?
   */
  resetConditionHistory(conditionHash: string): void {
    this.shownVariants.delete(conditionHash);
  }

  /**
   * è·å–é…ç½®
   */
  getConfig(): VariantConfig {
    return this.config;
  }

  /**
   * è®¾ç½®æœ€å°å·®å¼‚åº¦
   */
  setMinDifference(value: number): void {
    this.config.minDifference = Math.max(10, Math.min(50, value));
  }
}

// å¯¼å‡ºå•ä¾‹è·å–å‡½æ•°
export function getVariantManager(): VariantManager {
  return VariantManager.getInstance();
}
