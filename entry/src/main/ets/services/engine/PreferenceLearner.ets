/**
 * åå¥½å­¦ä¹ å™?
 * å­¦ä¹ ç”¨æˆ·åå¥½ï¼Œä¼˜åŒ–æ¨èç»“æ?
 */
import { preferences } from '@kit.ArkData';
import { GeneratedRecipe, RecipeIngredient } from '../../common/types/RecipeTypes';

// ç”¨æˆ·åå¥½æ•°æ®
export class UserPreference {
  // åŸæ–™ä½¿ç”¨é¢‘ç‡ (ingredientId -> count)
  ingredientUsage: Map<string, number> = new Map();

  // å‘³å‹åå¥½ (flavorType -> preferenceScore)
  flavorPreference: Map<string, number> = new Map();

  // ä¿å­˜çš„é…æ–¹IDåˆ—è¡¨
  savedRecipeIds: string[] = [];

  // é…æ–¹åé¦ˆå†å²
  feedbackHistory: RecipeFeedback[] = [];

  // å¸¸ç”¨åŸæ–™åˆ—è¡¨ (æ‰‹åŠ¨è®¾ç½®)
  favoriteIngredients: string[] = [];

  // ç»Ÿè®¡æ•°æ®
  totalRecipesGenerated: number = 0;
  totalRecipesSaved: number = 0;

  constructor() {}
}

// é…æ–¹åé¦ˆ
export class RecipeFeedback {
  recipeId: string = '';
  rating: 'good' | 'normal' | 'bad' = 'normal';
  note: string = '';
  createTime: number = 0;

  constructor() {}

  static create(recipeId: string, rating: 'good' | 'normal' | 'bad', note: string): RecipeFeedback {
    const f = new RecipeFeedback();
    f.recipeId = recipeId;
    f.rating = rating;
    f.note = note;
    f.createTime = Date.now();
    return f;
  }
}

// åé¦ˆåºåˆ—åŒ–ç±» (ç”¨äºJSONå­˜å‚¨)
export class FeedbackSerializable {
  recipeId: string = '';
  rating: string = 'normal';
  note: string = '';
  createTime: number = 0;

  constructor() {}

  static create(recipeId: string, rating: string, note: string, createTime: number): FeedbackSerializable {
    const f = new FeedbackSerializable();
    f.recipeId = recipeId;
    f.rating = rating;
    f.note = note;
    f.createTime = createTime;
    return f;
  }
}

// åŸæ–™ä½¿ç”¨æ¡ç›® (ç”¨äºæ’åº)
export class IngredientUsageEntry {
  id: string = '';
  count: number = 0;

  constructor() {}

  static create(id: string, count: number): IngredientUsageEntry {
    const e = new IngredientUsageEntry();
    e.id = id;
    e.count = count;
    return e;
  }
}

// å‘³å‹åˆ†æ•°æ¡ç›® (ç”¨äºæ’åº)
export class FlavorScoreEntry {
  flavor: string = '';
  score: number = 0;

  constructor() {}

  static create(flavor: string, score: number): FlavorScoreEntry {
    const e = new FlavorScoreEntry();
    e.flavor = flavor;
    e.score = score;
    return e;
  }
}

// åå¥½ç»Ÿè®¡æ•°æ®
export class PreferenceStatistics {
  generated: number = 0;
  saved: number = 0;
  feedbackCount: number = 0;

  constructor() {}

  static create(generated: number, saved: number, feedbackCount: number): PreferenceStatistics {
    const s = new PreferenceStatistics();
    s.generated = generated;
    s.saved = saved;
    s.feedbackCount = feedbackCount;
    return s;
  }
}

// åå¥½å­¦ä¹ å™?
export class PreferenceLearner {
  private static instance: PreferenceLearner | null = null;
  private preference: UserPreference = new UserPreference();
  private loaded: boolean = false;
  private store: preferences.Preferences | null = null;
  private readonly STORE_NAME = 'user_preference_store';

  private constructor() {}

  static getInstance(): PreferenceLearner {
    if (PreferenceLearner.instance === null) {
      PreferenceLearner.instance = new PreferenceLearner();
    }
    return PreferenceLearner.instance;
  }

  /**
   * åŠ è½½åå¥½æ•°æ®
   */
  async load(context: Context): Promise<void> {
    if (this.loaded) return;

    try {
      this.store = await preferences.getPreferences(context, this.STORE_NAME);

      // åŠ è½½åŸæ–™ä½¿ç”¨é¢‘ç‡
      const usageJson = await this.store.get('ingredientUsage', '{}') as string;
      const usageObj = JSON.parse(usageJson) as Record<string, number>;
      this.preference.ingredientUsage = new Map();
      const usageKeys = Object.keys(usageObj);
      for (let i = 0; i < usageKeys.length; i++) {
        this.preference.ingredientUsage.set(usageKeys[i], usageObj[usageKeys[i]]);
      }

      // åŠ è½½å‘³å‹åå¥½
      const flavorJson = await this.store.get('flavorPreference', '{}') as string;
      const flavorObj = JSON.parse(flavorJson) as Record<string, number>;
      this.preference.flavorPreference = new Map();
      const flavorKeys = Object.keys(flavorObj);
      for (let i = 0; i < flavorKeys.length; i++) {
        this.preference.flavorPreference.set(flavorKeys[i], flavorObj[flavorKeys[i]]);
      }

      // åŠ è½½ä¿å­˜çš„é…æ–¹ID
      const savedJson = await this.store.get('savedRecipeIds', '[]') as string;
      this.preference.savedRecipeIds = JSON.parse(savedJson) as string[];

      // åŠ è½½å¸¸ç”¨åŸæ–™
      const favJson = await this.store.get('favoriteIngredients', '[]') as string;
      this.preference.favoriteIngredients = JSON.parse(favJson) as string[];

      // åŠ è½½ç»Ÿè®¡æ•°æ®
      this.preference.totalRecipesGenerated = await this.store.get('totalRecipesGenerated', 0) as number;
      this.preference.totalRecipesSaved = await this.store.get('totalRecipesSaved', 0) as number;

      // åŠ è½½åé¦ˆå†å²
      const feedbackJson = await this.store.get('feedbackHistory', '[]') as string;
      const feedbackArr = JSON.parse(feedbackJson) as Array<Record<string, Object>>;
      this.preference.feedbackHistory = [];
      for (let i = 0; i < feedbackArr.length; i++) {
        const fb = new RecipeFeedback();
        fb.recipeId = feedbackArr[i].recipeId as string || '';
        fb.rating = feedbackArr[i].rating as 'good' | 'normal' | 'bad' || 'normal';
        fb.note = feedbackArr[i].note as string || '';
        fb.createTime = feedbackArr[i].createTime as number || 0;
        this.preference.feedbackHistory.push(fb);
      }

      this.loaded = true;
    } catch (err) {
      console.error('Load preference failed:', err);
      this.loaded = true;
    }
  }

  /**
   * ä¿å­˜åå¥½æ•°æ®
   */
  private async save(): Promise<void> {
    if (this.store === null) return;

    try {
      // ä¿å­˜åŸæ–™ä½¿ç”¨é¢‘ç‡
      const usageObj: Record<string, number> = {};
      this.preference.ingredientUsage.forEach((value, key) => {
        usageObj[key] = value;
      });
      await this.store.put('ingredientUsage', JSON.stringify(usageObj));

      // ä¿å­˜å‘³å‹åå¥½
      const flavorObj: Record<string, number> = {};
      this.preference.flavorPreference.forEach((value, key) => {
        flavorObj[key] = value;
      });
      await this.store.put('flavorPreference', JSON.stringify(flavorObj));

      // ä¿å­˜å…¶ä»–æ•°æ®
      await this.store.put('savedRecipeIds', JSON.stringify(this.preference.savedRecipeIds));
      await this.store.put('favoriteIngredients', JSON.stringify(this.preference.favoriteIngredients));
      await this.store.put('totalRecipesGenerated', this.preference.totalRecipesGenerated);
      await this.store.put('totalRecipesSaved', this.preference.totalRecipesSaved);

      // ä¿å­˜åé¦ˆå†å² (åªä¿ç•™æœ€è¿?0æ?
      const recentFeedback = this.preference.feedbackHistory.slice(-50);
      const feedbackArr: Array<FeedbackSerializable> = [];
      for (let i = 0; i < recentFeedback.length; i++) {
        const fb = recentFeedback[i];
        feedbackArr.push(FeedbackSerializable.create(fb.recipeId, fb.rating, fb.note, fb.createTime));
      }
      await this.store.put('feedbackHistory', JSON.stringify(feedbackArr));

      await this.store.flush();
    } catch (err) {
      console.error('Save preference failed:', err);
    }
  }


  /**
   * è®°å½•é…æ–¹ç”Ÿæˆ
   */
  recordGenerate(recipe: GeneratedRecipe): void {
    this.preference.totalRecipesGenerated++;

    // è®°å½•åŸæ–™ä½¿ç”¨
    for (let i = 0; i < recipe.ingredients.length; i++) {
      const ing = recipe.ingredients[i];
      const count = this.preference.ingredientUsage.get(ing.id) || 0;
      this.preference.ingredientUsage.set(ing.id, count + 1);
    }

    // è®°å½•å‘³å‹åå¥½
    const primary = recipe.flavorProfile.primary;
    const secondary = recipe.flavorProfile.secondary;
    if (primary) {
      const pScore = this.preference.flavorPreference.get(primary) || 0;
      this.preference.flavorPreference.set(primary, pScore + 1);
    }
    if (secondary) {
      const sScore = this.preference.flavorPreference.get(secondary) || 0;
      this.preference.flavorPreference.set(secondary, sScore + 0.5);
    }

    this.save();
  }

  /**
   * è®°å½•é…æ–¹ä¿å­˜
   */
  recordSave(recipe: GeneratedRecipe): void {
    this.preference.totalRecipesSaved++;

    // æ·»åŠ åˆ°ä¿å­˜åˆ—è¡?
    if (this.preference.savedRecipeIds.indexOf(recipe.id) < 0) {
      this.preference.savedRecipeIds.push(recipe.id);
      // é™åˆ¶ä¿å­˜åˆ—è¡¨å¤§å°
      if (this.preference.savedRecipeIds.length > 100) {
        this.preference.savedRecipeIds.shift();
      }
    }

    // ä¿å­˜çš„é…æ–¹ï¼ŒåŸæ–™ä½¿ç”¨æƒé‡æ›´é«˜
    for (let i = 0; i < recipe.ingredients.length; i++) {
      const ing = recipe.ingredients[i];
      const count = this.preference.ingredientUsage.get(ing.id) || 0;
      this.preference.ingredientUsage.set(ing.id, count + 2); // ä¿å­˜çš„é…æ–¹æƒé‡?2
    }

    // å‘³å‹åå¥½æƒé‡æ›´é«˜
    const primary = recipe.flavorProfile.primary;
    const secondary = recipe.flavorProfile.secondary;
    if (primary) {
      const pScore = this.preference.flavorPreference.get(primary) || 0;
      this.preference.flavorPreference.set(primary, pScore + 3);
    }
    if (secondary) {
      const sScore = this.preference.flavorPreference.get(secondary) || 0;
      this.preference.flavorPreference.set(secondary, sScore + 1.5);
    }

    this.save();
  }

  /**
   * è®°å½•åŸæ–™ä½¿ç”¨
   */
  recordIngredientUse(ingredientId: string): void {
    const count = this.preference.ingredientUsage.get(ingredientId) || 0;
    this.preference.ingredientUsage.set(ingredientId, count + 1);
    this.save();
  }

  /**
   * è®°å½•é…æ–¹åé¦ˆ
   */
  recordFeedback(recipeId: string, rating: 'good' | 'normal' | 'bad', note: string): void {
    const feedback = RecipeFeedback.create(recipeId, rating, note);
    this.preference.feedbackHistory.push(feedback);

    // æ ¹æ®åé¦ˆè°ƒæ•´åå¥½
    // å¥½è¯„å¢åŠ æƒé‡ï¼Œå·®è¯„å‡å°‘æƒé‡?
    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…å¯ä»¥æ›´å¤æ?

    this.save();
  }

  /**
   * è·å–åŸæ–™åå¥½åŠ æˆ
   * è¿”å› 0-20 çš„åŠ æˆå€?
   */
  getPreferenceBoost(ingredientId: string): number {
    const count = this.preference.ingredientUsage.get(ingredientId) || 0;

    // å¸¸ç”¨åŸæ–™é¢å¤–åŠ æˆ
    let isFavorite = false;
    for (let i = 0; i < this.preference.favoriteIngredients.length; i++) {
      if (this.preference.favoriteIngredients[i] === ingredientId) {
        isFavorite = true;
        break;
      }
    }

    let boost = 0;

    // ä½¿ç”¨é¢‘ç‡åŠ æˆ (æœ€é«?0åˆ?
    if (count > 20) boost += 10;
    else if (count > 10) boost += 7;
    else if (count > 5) boost += 5;
    else if (count > 2) boost += 3;
    else if (count > 0) boost += 1;

    // å¸¸ç”¨åŸæ–™åŠ æˆ (é¢å¤–10åˆ?
    if (isFavorite) boost += 10;

    return Math.min(20, boost);
  }

  /**
   * è·å–å‘³å‹åå¥½åŠ æˆ
   */
  getFlavorBoost(flavorType: string): number {
    const score = this.preference.flavorPreference.get(flavorType) || 0;

    if (score > 30) return 15;
    if (score > 20) return 10;
    if (score > 10) return 7;
    if (score > 5) return 5;
    if (score > 0) return 2;
    return 0;
  }

  /**
   * è·å–å¸¸ç”¨åŸæ–™åˆ—è¡¨
   */
  getFrequentIngredients(limit: number = 10): string[] {
    const entries: Array<IngredientUsageEntry> = [];
    this.preference.ingredientUsage.forEach((count, id) => {
      entries.push(IngredientUsageEntry.create(id, count));
    });

    // æŒ‰ä½¿ç”¨æ¬¡æ•°æ’åº?
    entries.sort((a, b) => b.count - a.count);

    const result: string[] = [];
    const maxCount = Math.min(limit, entries.length);
    for (let i = 0; i < maxCount; i++) {
      result.push(entries[i].id);
    }
    return result;
  }

  /**
   * è·å–åå¥½çš„å‘³å?
   */
  getPreferredFlavors(): string[] {
    const entries: Array<FlavorScoreEntry> = [];
    this.preference.flavorPreference.forEach((score, flavor) => {
      entries.push(FlavorScoreEntry.create(flavor, score));
    });

    entries.sort((a, b) => b.score - a.score);

    const result: string[] = [];
    const maxCount = Math.min(3, entries.length);
    for (let i = 0; i < maxCount; i++) {
      result.push(entries[i].flavor);
    }
    return result;
  }

  /**
   * è®¾ç½®å¸¸ç”¨åŸæ–™
   */
  setFavoriteIngredients(ingredientIds: string[]): void {
    this.preference.favoriteIngredients = ingredientIds.slice(0, 20); // æœ€å¤?0ä¸?
    this.save();
  }

  /**
   * æ·»åŠ å¸¸ç”¨åŸæ–™
   */
  addFavoriteIngredient(ingredientId: string): void {
    if (this.preference.favoriteIngredients.indexOf(ingredientId) < 0) {
      this.preference.favoriteIngredients.push(ingredientId);
      if (this.preference.favoriteIngredients.length > 20) {
        this.preference.favoriteIngredients.shift();
      }
      this.save();
    }
  }

  /**
   * ç§»é™¤å¸¸ç”¨åŸæ–™
   */
  removeFavoriteIngredient(ingredientId: string): void {
    const index = this.preference.favoriteIngredients.indexOf(ingredientId);
    if (index >= 0) {
      this.preference.favoriteIngredients.splice(index, 1);
      this.save();
    }
  }

  /**
   * è·å–å¸¸ç”¨åŸæ–™åˆ—è¡¨
   */
  getFavoriteIngredients(): string[] {
    return this.preference.favoriteIngredients.slice();
  }

  /**
   * é‡ç½®åå¥½æ•°æ®
   */
  async resetPreferences(): Promise<void> {
    this.preference = new UserPreference();
    await this.save();
  }

  /**
   * è·å–ç»Ÿè®¡æ•°æ®
   */
  getStatistics(): PreferenceStatistics {
    return PreferenceStatistics.create(
      this.preference.totalRecipesGenerated,
      this.preference.totalRecipesSaved,
      this.preference.feedbackHistory.length
    );
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²åŠ è½½
   */
  isLoaded(): boolean {
    return this.loaded;
  }

  /**
   * è·å–åå¥½æ•°æ®ï¼ˆç”¨äºè°ƒè¯•ï¼‰
   */
  getPreference(): UserPreference {
    return this.preference;
  }
}

// å¯¼å‡ºå•ä¾‹è·å–å‡½æ•°
export function getPreferenceLearner(): PreferenceLearner {
  return PreferenceLearner.getInstance();
}
