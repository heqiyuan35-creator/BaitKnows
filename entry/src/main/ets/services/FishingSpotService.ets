/**
 * é’“ç‚¹æœåŠ¡ - æ”¯æŒåä¸ºåœ°å›¾å’Œé«˜å¾·åœ°å›¾æœç´?
 */
import { site } from '@kit.MapKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { FishingSpot, WaterType, BaitInfo, BaitDatabase, WaterTypeNames } from '../data/FishingSpotData';

class FishingSpotServiceClass {
  private TAG = 'FishingSpotService';
  private _cachedSpots: FishingSpot[] = [];

  get cachedSpots(): FishingSpot[] {
    return this._cachedSpots;
  }

  updateCachedSpots(spots: FishingSpot[]): void {
    this._cachedSpots = spots;
    console.info(this.TAG, `ç¼“å­˜æ›´æ–°: ${spots.length} ä¸ªé’“ç‚¹`);
  }

  // è·å–é™„è¿‘é’“ç‚¹ï¼ˆä¼˜å…ˆä½¿ç”¨ç¼“å­˜ï¼Œå¦‚æœç¼“å­˜ä¸ºç©ºåˆ™ä½¿ç”¨é¢„è®¾æ•°æ®ï¼‰
  async searchNearbySpots(userLat: number, userLng: number, radiusMeters: number = 5000): Promise<FishingSpot[]> {
    // å¦‚æœå·²æœ‰ç¼“å­˜æ•°æ®ï¼ˆä»åœ°å›¾é¡µè·å–çš„ï¼‰ï¼Œç›´æ¥è¿”å›
    if (this._cachedSpots.length > 0) {
      console.info(this.TAG, `ä½¿ç”¨ç¼“å­˜æ•°æ®: ${this._cachedSpots.length} ä¸ªé’“ç‚¹`);
      return this._cachedSpots;
    }

    // å°è¯•ä½¿ç”¨åä¸ºåœ°å›¾ API æœç´¢
    const spots = await this.searchWithHuaweiMap(userLat, userLng, radiusMeters);
    
    // å¦‚æœåä¸ºåœ°å›¾æœç´¢å¤±è´¥æˆ–æ— ç»“æœï¼Œä½¿ç”¨é¢„è®¾çš„çœŸå®é’“ç‚¹æ•°æ®
    if (spots.length === 0) {
      console.info(this.TAG, 'åä¸ºåœ°å›¾æœç´¢æ— ç»“æœï¼Œä½¿ç”¨é¢„è®¾é’“ç‚¹æ•°æ®');
      return this.getPresetSpots(userLat, userLng);
    }

    return spots;
  }

  // ä½¿ç”¨åä¸ºåœ°å›¾ Site API æœç´¢
  private async searchWithHuaweiMap(userLat: number, userLng: number, radiusMeters: number): Promise<FishingSpot[]> {
    const spots: FishingSpot[] = [];
    const searchKeywords: string[] = ['æ±Ÿæ»©', 'æ²³æ»©', 'æ°´åº“', 'é±¼å¡˜', 'é’“åœº', 'å‚é’“', 'æ¹¿åœ°å…¬å›­', 'æ¹–æ³Š', 'ç å¤´'];

    for (const keyword of searchKeywords) {
      try {
        const params: site.NearbySearchParams = {
          query: keyword,
          location: { latitude: userLat, longitude: userLng },
          radius: radiusMeters,
          language: 'zh'
        };

        const result = await site.nearbySearch(params);

        if (result && result.sites) {
          for (const siteInfo of result.sites) {
            if (!siteInfo.location || !siteInfo.name) continue;
            if (!this.isWaterRelated(siteInfo.name)) continue;

            const exists = spots.some(s =>
              Math.abs(s.latitude - siteInfo.location!.latitude) < 0.0001 &&
              Math.abs(s.longitude - siteInfo.location!.longitude) < 0.0001
            );

            if (!exists) {
              const waterType = this.detectWaterType(siteInfo.name, siteInfo.poi?.poiTypes || []);
              const distance = this.calculateDistance(userLat, userLng, siteInfo.location.latitude, siteInfo.location.longitude);

              const spot: FishingSpot = {
                id: siteInfo.siteId || `spot_${spots.length}`,
                name: siteInfo.name,
                latitude: siteInfo.location.latitude,
                longitude: siteInfo.location.longitude,
                waterType: waterType,
                description: siteInfo.formatAddress || this.getSpotDescription(waterType),
                distance: Math.round(distance)
              };
              spots.push(spot);
            }
          }
        }
      } catch (error) {
        const err = error as BusinessError;
        console.error(this.TAG, `Search ${keyword} failed: ${err.code}, ${err.message}`);
      }
    }

    spots.sort((a, b) => (a.distance || 0) - (b.distance || 0));
    return spots.slice(0, 20);
  }

  // è·å–é¢„è®¾çš„çœŸå®é’“ç‚¹æ•°æ®ï¼ˆæ­¦æ±‰åœ°åŒºï¼?
  private getPresetSpots(userLat: number, userLng: number): FishingSpot[] {
    const realSpots: FishingSpot[] = [
      // ä¸œæ¹–åŒºåŸŸ
      { id: 'preset_1', name: 'ä¸œæ¹–è½é›æ™¯åŒº', latitude: 30.5547, longitude: 114.4283, waterType: WaterType.RESERVOIR, description: 'ä¸œæ¹–æœ€å¤§çš„æ¹–æ±Šï¼Œæ°´è´¨å¥½ï¼Œé±¼ç§ä¸°å¯?, distance: 0 },
      { id: 'preset_2', name: 'ä¸œæ¹–ç£¨å±±æ™¯åŒº', latitude: 30.5489, longitude: 114.4089, waterType: WaterType.RESERVOIR, description: 'é£æ™¯ä¼˜ç¾ï¼Œé€‚åˆä¼‘é—²å‚é’“', distance: 0 },
      { id: 'preset_3', name: 'ä¸œæ¹–å¬æ¶›æ™¯åŒº', latitude: 30.5612, longitude: 114.3856, waterType: WaterType.RESERVOIR, description: 'äº¤é€šä¾¿åˆ©ï¼Œå²¸è¾¹é’“ä½å¤?, distance: 0 },
      // æ²™æ¹–åŒºåŸŸ
      { id: 'preset_4', name: 'æ²™æ¹–å…¬å›­', latitude: 30.5734, longitude: 114.3412, waterType: WaterType.POND, description: 'å¸‚åŒºå†…é’“åœºï¼Œé€‚åˆä¼‘é—²', distance: 0 },
      // æ±¤é€Šæ¹–åŒºåŸŸ
      { id: 'preset_5', name: 'æ±¤é€Šæ¹–', latitude: 30.4523, longitude: 114.3678, waterType: WaterType.RESERVOIR, description: 'æ­¦æ±‰æœ€å¤§åŸä¸­æ¹–ï¼Œå¤§ç‰©é¢‘å‡?, distance: 0 },
      // é•¿æ±ŸåŒºåŸŸ
      { id: 'preset_6', name: 'æ±‰å£æ±Ÿæ»©', latitude: 30.5912, longitude: 114.2934, waterType: WaterType.RIVER, description: 'é•¿æ±Ÿé’“åœºï¼Œé±¼å£æ´»è·?, distance: 0 },
      { id: 'preset_7', name: 'æ­¦æ˜Œæ±Ÿæ»©', latitude: 30.5523, longitude: 114.3123, waterType: WaterType.RIVER, description: 'æ±Ÿè¾¹é’“ä½ï¼Œæ³¨æ„å®‰å…?, distance: 0 },
      // å…¶ä»–æ¹–æ³Š
      { id: 'preset_8', name: 'å¢¨æ°´æ¹?, latitude: 30.5234, longitude: 114.2156, waterType: WaterType.POND, description: 'æ±‰é˜³åŒºé’“åœºï¼Œé²«é±¼å¤?, distance: 0 },
      { id: 'preset_9', name: 'å—æ¹–', latitude: 30.5089, longitude: 114.3534, waterType: WaterType.POND, description: 'æ´ªå±±åŒºæ¹–æ³Šï¼Œç¯å¢ƒä¼˜ç¾', distance: 0 },
      { id: 'preset_10', name: 'åå®˜æ¹?, latitude: 30.4912, longitude: 114.1234, waterType: WaterType.RESERVOIR, description: 'è”¡ç”¸åŒºå¤§å‹æ°´åº“ï¼Œé±¼ç§å¤?, distance: 0 },
      { id: 'preset_11', name: 'ä¸¥è¥¿æ¹?, latitude: 30.5234, longitude: 114.4789, waterType: WaterType.RESERVOIR, description: 'å…‰è°·é™„è¿‘ï¼Œæ°´è´¨æ¸…æ¾?, distance: 0 },
      { id: 'preset_12', name: 'æ¢å­æ¹?, latitude: 30.2567, longitude: 114.5234, waterType: WaterType.RESERVOIR, description: 'æ­¦æ±‰æœ€å¤§æ·¡æ°´æ¹–ï¼Œé‡é’“åœ£åœ?, distance: 0 }
    ];

    // è®¡ç®—æ¯ä¸ªé’“ç‚¹åˆ°ç”¨æˆ·çš„è·ç¦»
    realSpots.forEach(spot => {
      spot.distance = Math.round(this.calculateDistance(userLat, userLng, spot.latitude, spot.longitude));
    });

    // æŒ‰è·ç¦»æ’åºï¼Œå–æœ€è¿‘çš„10ä¸?
    realSpots.sort((a, b) => (a.distance || 0) - (b.distance || 0));
    return realSpots.slice(0, 10);
  }

  private isWaterRelated(name: string): boolean {
    // ç¬¬ä¸€æ­¥ï¼šä¸¥æ ¼æ’é™¤éé’“ç‚¹ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
    const strictExcludeKeywords = [
      // å…¬å…±è®¾æ–½
      'å•æ‰€', 'å«ç”Ÿé—?, 'æ´—æ‰‹é—?, 'å…¬å•', 'å…¬å…±å•æ‰€',
      // ç¾å®¹ç¾å‘
      'æŠ¤è‚¤', 'ç¾è‚¤', 'ç¾å®¹', 'ç¾å‘', 'ç†å‘', 'SPA', 'spa', 'é€ å‹', 'æ—¶å°š',
      // é¤é¥®ï¼ˆåŒ…æ‹¬å„ç§åº—é“ºå½¢å¼ï¼‰
      'ç«é”…', 'çƒ§çƒ¤', 'é¤å…', 'é¥­åº—', 'é…’æ¥¼', 'é£Ÿå ‚', 'å°åƒ', 'é¢é¦†', 'ä¸²ä¸²', 'çƒ¤è‚‰',
      'å’–å•¡', 'å¥¶èŒ¶', 'ç”œå“', 'è›‹ç³•', 'å¿«é¤', 'å¤–å–', 'ç¾é£Ÿ', 'é…’å§', 'é…’åº—', 'å®¾é¦†',
      'çƒ­ç‚¼', 'é¥­æ©˜', 'åˆ†åº—', 'è¿é”', 'åŠ ç›Ÿ',
      // å•†ä¸šæœåŠ¡
      'è¶…å¸‚', 'å•†åœº', 'è´­ç‰©', 'ä¸“å–', 'æ‰¹å‘', 'é›¶å”®', 'é“¶è¡Œ', 'è¯åº—',
      // æ•™è‚²åŒ»ç–—
      'åŒ»é™¢', 'è¯Šæ‰€', 'å­¦æ ¡', 'å¹¼å„¿å›?, 'å­¦é™¢', 'å¤§å­¦', 'åŸ¹è®­',
      // åœè½¦äº¤é€?
      'åœè½¦åœ?, 'åœè½¦', 'åŠ æ²¹ç«?, 'å……ç”µç«?,
      // è¿åŠ¨å¨±ä¹ï¼ˆéé’“é±¼ï¼?
      'è·³ä¼', 'è¹¦æ', 'KTV', 'ç½‘å§', 'æ¸¸æˆ', 'ç”µå½±', 'å¥èº«', 'æ¸¸æ³³æ±?,
      'åˆ’èˆ¹', 'çš®åˆ’è‰?, 'èµ›è‰‡', 'è®­ç»ƒåŸºåœ°', 'ä¿±ä¹éƒ?,
      // ä¼ä¸šè¡Œæ”¿
      'å…¬å¸', 'é›†å›¢', 'å¤§å¦', 'å¹¿åœº', 'å†™å­—æ¥?, 'åŠå…¬', 'è¥é”€', 'ä¸­å¿ƒ',
      // ä½å®…
      'å°åŒº', 'èŠ±å›­', 'å®¶å›­', 'è‹?, 'åº?, 'å…¬å¯“', 'æ°‘å®¿'
    ];

    for (const exclude of strictExcludeKeywords) {
      if (name.includes(exclude)) return false;
    }

    // ç¬¬äºŒæ­¥ï¼šæ’é™¤å¸?åº?å­—çš„ï¼ˆåŸºæœ¬éƒ½æ˜¯å•†é“ºï¼‰
    if (name.includes('åº?)) return false;

    // ç¬¬ä¸‰æ­¥ï¼šå¿…é¡»åŒ…å«çœŸæ­£çš„é’“é±?æ°´åŸŸå…³é”®è¯?
    const realFishingKeywords = [
      // é’“é±¼ä¸“ç”¨ï¼ˆæœ€å¯é ï¼?
      'å‚é’“', 'é’“åœº', 'é’“é±¼', 'æ¸”åœº', 'é±¼å¡˜', 'é±¼æ± ', 'é’“å›­', 'æ¸”å…·',
      // è‡ªç„¶æ°´åŸŸ
      'æ±Ÿæ»©', 'æ²³æ»©', 'æ¹–æ»©', 'æ°´åº“',
      'æ¹¿åœ°å…¬å›­', 'æ¹¿åœ°',
      // å¸?å¡?ä½†ä¸æ˜¯å…¶ä»–ç”¨é€”çš„
      'é±¼å¡˜', 'è·å¡˜', 'è²å¡˜'
    ];

    // ä¼˜å…ˆåŒ¹é…é’“é±¼ä¸“ç”¨å…³é”®è¯?
    for (const keyword of realFishingKeywords) {
      if (name.includes(keyword)) return true;
    }

    // ç¬¬å››æ­¥ï¼šå¯¹äºé€šç”¨æ°´åŸŸè¯ï¼ˆæ¹–ã€æ²³ã€æ±Ÿç­‰ï¼‰ï¼Œéœ€è¦æ›´ä¸¥æ ¼åˆ¤æ–­
    // å¿…é¡»æ˜?XXæ¹?ã€?XXæ²?è¿™ç§åœ°åå½¢å¼
    const waterBodyPatterns = [
      /æ¹?/,      // ä»?æ¹?ç»“å°¾ï¼šä¸œæ¹–ã€å—æ¹?
      /æ²?/,      // ä»?æ²?ç»“å°¾
      /æ±?/,      // ä»?æ±?ç»“å°¾
      /æ½?/,      // ä»?æ½?ç»“å°¾
      /å¡?/,      // ä»?å¡?ç»“å°¾ï¼šå‚æŸ³å¡˜
      /æº?/,      // ä»?æº?ç»“å°¾
      /æ¸?/,      // ä»?æ¸?ç»“å°¾ï¼ˆå†…é™†æ²³æ¸¯ï¼‰
      /æ¸¡å£$/     // ä»?æ¸¡å£"ç»“å°¾
    ];

    for (const pattern of waterBodyPatterns) {
      if (pattern.test(name)) return true;
    }

    return false;
  }

  private detectWaterType(name: string, poiTypes: string[]): WaterType {
    const nameAndTypes = name + poiTypes.join(',');

    // æ¹–æ³Š
    if (nameAndTypes.includes('æ¹?) || nameAndTypes.includes('æ½?)) {
      return WaterType.LAKE;
    }

    // æ²³æµï¼šæ±Ÿã€æ²³ã€æºªã€æ¸¯ï¼ˆå†…é™†æ¸¯å£å±äºæ²³æµï¼‰ã€ç å¤?
    if (nameAndTypes.includes('æ±?) || nameAndTypes.includes('æ²?) ||
        nameAndTypes.includes('æº?) || nameAndTypes.includes('æ¸?) ||
        nameAndTypes.includes('ç å¤´') || nameAndTypes.includes('æ¸¡å£')) {
      return WaterType.RIVER;
    }

    // æ°´åº“
    if (nameAndTypes.includes('æ°´åº“')) {
      return WaterType.RESERVOIR;
    }

    // é»˜è®¤æ± å¡˜
    return WaterType.POND;
  }

  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
    const R = 6371000;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLng / 2) * Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  private getSpotDescription(type: WaterType): string {
    const descriptions: Record<string, string> = {
      [WaterType.POND]: 'é€‚åˆä¼‘é—²å‚é’“',
      [WaterType.RESERVOIR]: 'æ°´åŸŸå¼€é˜”ï¼Œé€‚åˆå®ˆé’“',
      [WaterType.RIVER]: 'æµæ°´é’“åœºï¼Œé±¼å£æ´»è·?,
      [WaterType.LAKE]: 'æ¹–æ³Šé’“åœºï¼Œé±¼ç§ä¸°å¯?
    };
    return descriptions[type] || 'é’“ç‚¹ç¯å¢ƒè‰¯å¥½';
  }

  recommendBaits(waterType: WaterType): BaitInfo[] {
    const allBaits = BaitDatabase[waterType] || [];
    if (allBaits.length === 0) return [];
    const shuffled = [...allBaits].sort(() => Math.random() - 0.5);
    const count = Math.min(Math.floor(Math.random() * 2) + 2, shuffled.length);
    return shuffled.slice(0, count);
  }

  getWaterTypeName(type: WaterType): string {
    return WaterTypeNames[type] || 'æœªçŸ¥';
  }

  formatDistance(meters: number): string {
    if (meters < 1000) return `${meters}ç±³`;
    return `${(meters / 1000).toFixed(1)}å…¬é‡Œ`;
  }
}

export const FishingSpotService = new FishingSpotServiceClass();
