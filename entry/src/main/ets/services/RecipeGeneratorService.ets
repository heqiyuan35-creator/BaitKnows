/**
 * æ™ºèƒ½é…æ–¹ç”ŸæˆæœåŠ¡
 * æ ¸å¿ƒè§„åˆ™å¼•æ“ï¼Œå®ç°ç¡®å®šæ€§çš„é…æ–¹ç”Ÿæˆç®—æ³•
 */
import {
  GenerateRecipeInput, GeneratedRecipe, RecipeIngredient,
  FlavorDescription, StateProfile, UsageSuggestion, GenerateReason,
  FlavorModifier, StateModifier, FishRecipeRule, TemperatureRule,
  RecipeSeason, RecipeWaterType, FishingMethod
} from '../common/types/RecipeTypes';
import {
  getFishRule, getTemperatureRule, getDensityModifier,
  getActivityModifier, getMethodModifier, getModeModifier,
  getTempReasonTemplate, getWaterReasonTemplate, getDensityReasonTemplate,
  getActivityReasonTemplate, getModeReasonTemplate, getFishReasonTemplate
} from '../data/RecipeRules';
import { getIngredientById, getIngredientNameMap, Ingredient } from '../data/IngredientDatabase';

// å‘³å‹æƒé‡
class FlavorWeights {
  fishy: number = 0;
  fragrant: number = 0;
  sweet: number = 0;
  sour: number = 0;
  stinky: number = 0;
  constructor() {}
}

// çŠ¶æ€æƒé‡?
class StateWeights {
  atomization: number = 0;
  viscosity: number = 0;
  intensity: number = 0;
  constructor() {}
}

// åŒ¹é…çš„åŸæ–?
class MatchedIngredient {
  id: string = '';
  name: string = '';
  category: string = '';
  score: number = 0;
  constructor() {}
}

class RecipeGeneratorServiceClass {
  private ingredientNames: Map<string, string> = new Map();

  constructor() {
    this.ingredientNames = getIngredientNameMap();
  }

  /**
   * ä¸»ç”Ÿæˆæ–¹æ³?
   */
  generateRecipe(input: GenerateRecipeInput): GeneratedRecipe {
    const recipe = new GeneratedRecipe();
    recipe.id = this.generateId();
    recipe.createTime = Date.now();
    recipe.mode = input.mode;
    recipe.conditions = input;
    recipe.totalWeight = 500;

    // 1. è·å–é±¼ç§åŸºç¡€è§„åˆ™
    const fishRule: FishRecipeRule | null = getFishRule(input.targetFishId);
    if (fishRule === null) {
      recipe.name = 'é»˜è®¤é…æ–¹';
      return recipe;
    }

    // 2. è®¡ç®—æœ€ç»ˆå‘³å‹æƒé‡?
    const flavorWeights = this.calculateFlavorWeights(fishRule, input);

    // 3. è®¡ç®—æœ€ç»ˆçŠ¶æ€æƒé‡?
    const stateWeights = this.calculateStateWeights(fishRule, input);

    // 4. åŒ¹é…åŸæ–™
    const matchedIngredients = this.matchIngredients(fishRule, flavorWeights, stateWeights, input);

    // 5. è®¡ç®—é…æ¯”
    recipe.ingredients = this.calculateRatio(matchedIngredients, recipe.totalWeight);

    // 6. ç”Ÿæˆé…æ–¹åç§°
    recipe.name = this.generateRecipeName(input, fishRule);

    // 7. ç”Ÿæˆå‘³å‹è¯´æ˜
    recipe.flavorProfile = this.generateFlavorProfile(flavorWeights, input);

    // 8. ç”ŸæˆçŠ¶æ€ç‰¹æ€?
    recipe.stateProfile = this.generateStateProfile(stateWeights, input);

    // 9. ç”Ÿæˆä½¿ç”¨å»ºè®®
    recipe.usage = this.generateUsage(input, stateWeights);

    // 10. ç”Ÿæˆç†ç”±
    recipe.reasons = this.generateReasons(input, flavorWeights, stateWeights);

    return recipe;
  }


  /**
   * è®¡ç®—å‘³å‹æƒé‡
   */
  private calculateFlavorWeights(fishRule: FishRecipeRule, input: GenerateRecipeInput): FlavorWeights {
    // åŸºç¡€å€?
    const weights = new FlavorWeights();
    weights.fishy = fishRule.baseFlavor.fishy;
    weights.fragrant = fishRule.baseFlavor.fragrant;
    weights.sweet = fishRule.baseFlavor.sweet;
    weights.sour = fishRule.baseFlavor.sour;
    weights.stinky = fishRule.baseFlavor.stinky;

    // å­£èŠ‚ä¿®æ­£
    const seasonMod = this.getSeasonModifier(fishRule, input.season);
    this.applyFlavorModifier(weights, seasonMod);

    // æ¸©åº¦ä¿®æ­£
    const tempRule = getTemperatureRule(input.temperature);
    this.applyFlavorModifier(weights, tempRule.flavorModifier);

    // é±¼æƒ…ä¿®æ­£ - å¼€å£å·®æ—¶å‘³å‹åŠ é‡?
    if (input.fishActivity === 'poor') {
      this.scaleFlavorWeights(weights, 1.2);
    } else if (input.fishActivity === 'good') {
      this.scaleFlavorWeights(weights, 0.9);
    }

    // æ¨¡å¼ä¿®æ­£
    const modeMod = getModeModifier(input.mode);
    this.scaleFlavorWeights(weights, modeMod.flavorScale);

    // é™åˆ¶èŒƒå›´ 0-100
    this.clampFlavorWeights(weights);

    return weights;
  }

  /**
   * è®¡ç®—çŠ¶æ€æƒé‡?
   */
  private calculateStateWeights(fishRule: FishRecipeRule, input: GenerateRecipeInput): StateWeights {
    // åŸºç¡€å€?
    const weights = new StateWeights();
    weights.atomization = 50;
    weights.viscosity = 50;
    weights.intensity = 50;

    // æ°´åŸŸä¿®æ­£
    const waterMod = this.getWaterModifier(fishRule, input.waterType);
    this.applyStateModifier(weights, waterMod);

    // æ¸©åº¦ä¿®æ­£
    const tempRule = getTemperatureRule(input.temperature);
    this.applyStateModifier(weights, tempRule.stateModifier);

    // é±¼å¯†åº¦ä¿®æ­?
    const densityMod = getDensityModifier(input.fishDensity);
    this.applyStateModifier(weights, densityMod);

    // å¼€å£æƒ…å†µä¿®æ­?
    const activityMod = getActivityModifier(input.fishActivity);
    this.applyStateModifier(weights, activityMod);

    // ä½œé’“æ–¹å¼ä¿®æ­£
    const methodMod = getMethodModifier(input.fishingMethod);
    this.applyStateModifier(weights, methodMod);

    // æ¨¡å¼ä¿®æ­£
    const modeMod = getModeModifier(input.mode);
    weights.atomization += modeMod.atomizationBias;

    // é™åˆ¶èŒƒå›´ 0-100
    this.clampStateWeights(weights);

    return weights;
  }

  /**
   * åŒ¹é…åŸæ–™
   */
  private matchIngredients(
    fishRule: FishRecipeRule,
    flavorWeights: FlavorWeights,
    stateWeights: StateWeights,
    input: GenerateRecipeInput
  ): MatchedIngredient[] {
    const matched: MatchedIngredient[] = [];
    const available = input.availableBaits || [];

    // è¿‡æ»¤å‡ºç”¨æˆ·æœ‰çš„åŸæ–?
    const filterAvailable = (ids: string[]): string[] => {
      if (available.length === 0) return ids;
      const filtered: string[] = [];
      for (let i = 0; i < ids.length; i++) {
        if (available.indexOf(ids[i]) >= 0) {
          filtered.push(ids[i]);
        }
      }
      return filtered.length > 0 ? filtered : ids;
    };

    // 1. é€‰ä¸»é¥µï¼ˆ1-2ç§ï¼‰
    const mainIds = filterAvailable(fishRule.recommendedIngredients.main);
    const mainSelected = this.selectByFlavor(mainIds, flavorWeights, 2);
    for (let i = 0; i < mainSelected.length; i++) {
      const item = new MatchedIngredient();
      item.id = mainSelected[i].id;
      item.name = mainSelected[i].name;
      item.category = 'main';
      item.score = mainSelected[i].score;
      matched.push(item);
    }

    // 2. é€‰è¾…é¥µï¼ˆ1ç§ï¼‰
    const auxIds = filterAvailable(fishRule.recommendedIngredients.auxiliary);
    const auxSelected = this.selectByFlavor(auxIds, flavorWeights, 1);
    for (let i = 0; i < auxSelected.length; i++) {
      const item = new MatchedIngredient();
      item.id = auxSelected[i].id;
      item.name = auxSelected[i].name;
      item.category = 'auxiliary';
      item.score = auxSelected[i].score;
      matched.push(item);
    }

    // 3. é€‰çŠ¶æ€ç²‰ï¼?ç§ï¼‰
    const stateIds = filterAvailable(fishRule.recommendedIngredients.state);
    const stateSelected = this.selectByState(stateIds, stateWeights, input.fishingMethod, 1);
    for (let i = 0; i < stateSelected.length; i++) {
      const item = new MatchedIngredient();
      item.id = stateSelected[i].id;
      item.name = stateSelected[i].name;
      item.category = 'state';
      item.score = stateSelected[i].score;
      matched.push(item);
    }

    // 4. é€‰æ·»åŠ å‰‚ï¼?ç§ï¼‰
    const addIds = filterAvailable(fishRule.recommendedIngredients.additive);
    const addSelected = this.selectByFlavor(addIds, flavorWeights, 1);
    for (let i = 0; i < addSelected.length; i++) {
      const item = new MatchedIngredient();
      item.id = addSelected[i].id;
      item.name = addSelected[i].name;
      item.category = 'additive';
      item.score = addSelected[i].score;
      matched.push(item);
    }

    return matched;
  }


  /**
   * è®¡ç®—é…æ¯”
   */
  private calculateRatio(matched: MatchedIngredient[], totalWeight: number): RecipeIngredient[] {
    const result: RecipeIngredient[] = [];

    // ç»Ÿè®¡å„ç±»åˆ«æ•°é‡?
    let mainCount = 0, auxCount = 0, stateCount = 0, addCount = 0;
    for (let i = 0; i < matched.length; i++) {
      if (matched[i].category === 'main') mainCount++;
      else if (matched[i].category === 'auxiliary') auxCount++;
      else if (matched[i].category === 'state') stateCount++;
      else if (matched[i].category === 'additive') addCount++;
    }

    // é…æ¯”è§„åˆ™ï¼šä¸»é¥?0-50%ï¼Œè¾…é¥?0-30%ï¼ŒçŠ¶æ€?5-20%ï¼Œæ·»åŠ å‰‚5-10%
    const mainTotal = 45;   // ä¸»é¥µæ€»å æ¯?
    const auxTotal = 25;    // è¾…é¥µæ€»å æ¯?
    const stateTotal = 18;  // çŠ¶æ€æ€»å æ¯?
    const addTotal = 12;    // æ·»åŠ å‰‚æ€»å æ¯?

    for (let i = 0; i < matched.length; i++) {
      const ing = matched[i];
      const item = new RecipeIngredient();
      item.id = ing.id;
      item.name = ing.name;
      item.category = ing.category as 'main' | 'auxiliary' | 'state' | 'additive';

      // è®¡ç®—ç™¾åˆ†æ¯?
      if (ing.category === 'main') {
        item.percentage = Math.round(mainTotal / mainCount);
      } else if (ing.category === 'auxiliary') {
        item.percentage = Math.round(auxTotal / auxCount);
      } else if (ing.category === 'state') {
        item.percentage = Math.round(stateTotal / stateCount);
      } else {
        item.percentage = Math.round(addTotal / addCount);
      }

      // è®¡ç®—å…‹æ•°
      item.weight = Math.round(totalWeight * item.percentage / 100);

      // ç”¨é€”è¯´æ˜?
      item.purpose = this.getIngredientPurpose(ing.category);

      result.push(item);
    }

    return result;
  }

  /**
   * ç”Ÿæˆé…æ–¹åç§°
   */
  private generateRecipeName(input: GenerateRecipeInput, fishRule: FishRecipeRule): string {
    let season = '';
    if (input.season === 'spring') season = 'æ˜¥å­£';
    else if (input.season === 'summer') season = 'å¤å­£';
    else if (input.season === 'autumn') season = 'ç§‹å­£';
    else if (input.season === 'winter') season = 'å†¬å­£';

    let water = '';
    if (input.waterType === 'river') water = 'é‡æ²³';
    else if (input.waterType === 'pond') water = 'é»‘å‘';
    else if (input.waterType === 'reservoir') water = 'æ°´åº“';
    else if (input.waterType === 'wild_pond') water = 'é‡å¡˜';

    let mode = 'å‡è¡¡';
    if (input.mode === 'conservative') mode = 'ä¿å®ˆ';
    else if (input.mode === 'aggressive') mode = 'æ¿€è¿?;

    return `${season}${water}${fishRule.fishName}-${mode}é…æ–¹`;
  }

  /**
   * ç”Ÿæˆå‘³å‹è¯´æ˜
   */
  private generateFlavorProfile(weights: FlavorWeights, input: GenerateRecipeInput): FlavorDescription {
    const profile = new FlavorDescription();

    // ç¡®å®šä¸»å‘³å?- æ‰‹åŠ¨æ¯”è¾ƒæ‰¾å‡ºæœ€å¤§çš„ä¸¤ä¸ª
    let primary = 'è…?;
    let primaryValue = weights.fishy;
    let secondary = 'é¦?;
    let secondaryValue = weights.fragrant;

    // æ£€æŸ¥é¦™
    if (weights.fragrant > primaryValue) {
      secondary = primary; secondaryValue = primaryValue;
      primary = 'é¦?; primaryValue = weights.fragrant;
    } else if (weights.fragrant > secondaryValue) {
      secondary = 'é¦?; secondaryValue = weights.fragrant;
    }
    // æ£€æŸ¥ç”œ
    if (weights.sweet > primaryValue) {
      secondary = primary; secondaryValue = primaryValue;
      primary = 'ç”?; primaryValue = weights.sweet;
    } else if (weights.sweet > secondaryValue) {
      secondary = 'ç”?; secondaryValue = weights.sweet;
    }
    // æ£€æŸ¥é…¸
    if (weights.sour > primaryValue) {
      secondary = primary; secondaryValue = primaryValue;
      primary = 'é…?; primaryValue = weights.sour;
    } else if (weights.sour > secondaryValue) {
      secondary = 'é…?; secondaryValue = weights.sour;
    }
    // æ£€æŸ¥è‡­
    if (weights.stinky > primaryValue) {
      secondary = primary; secondaryValue = primaryValue;
      primary = 'è‡?; primaryValue = weights.stinky;
    } else if (weights.stinky > secondaryValue) {
      secondary = 'è‡?; secondaryValue = weights.stinky;
    }

    profile.primary = primary;
    profile.secondary = secondary;

    // è®¡ç®—æµ“åº¦ (1-10)
    const avgIntensity = (primaryValue + secondaryValue) / 2;
    profile.intensity = Math.min(10, Math.max(1, Math.round(avgIntensity / 10)));

    // é€‚ç”¨æ°´æ¸©
    if (input.temperature < 10) {
      profile.suitableTemp = '5-15Â°C';
    } else if (input.temperature < 20) {
      profile.suitableTemp = '10-20Â°C';
    } else if (input.temperature < 28) {
      profile.suitableTemp = '18-28Â°C';
    } else {
      profile.suitableTemp = '25-35Â°C';
    }

    return profile;
  }

  /**
   * ç”ŸæˆçŠ¶æ€ç‰¹æ€?
   */
  private generateStateProfile(weights: StateWeights, input: GenerateRecipeInput): StateProfile {
    const profile = new StateProfile();

    // è½¬æ¢ä¸?-5æ˜Ÿçº§
    profile.atomization = this.toStarRating(weights.atomization);
    profile.viscosity = this.toStarRating(weights.viscosity);

    // æŒé’©æ€§ä¸ç²˜åº¦æ­£ç›¸å…?
    profile.hookHolding = Math.min(5, Math.max(1, Math.round(weights.viscosity / 20)));

    // æ¯”é‡ï¼šé›¾åŒ–å¿«åˆ™è½»ï¼Œç²˜åº¦é«˜åˆ™é‡
    const weightScore = 50 - weights.atomization * 0.3 + weights.viscosity * 0.3;
    profile.weight = this.toStarRating(weightScore);

    return profile;
  }


  /**
   * ç”Ÿæˆä½¿ç”¨å»ºè®®
   */
  generateUsage(input: GenerateRecipeInput, stateWeights: StateWeights): UsageSuggestion {
    const usage = new UsageSuggestion();

    // æ°´æ¯”ï¼šé›¾åŒ–å¿«ç”¨æ°´å°‘ï¼Œç²˜åº¦é«˜ç”¨æ°´å¤š
    const atomLevel = stateWeights.atomization;
    if (atomLevel > 60) {
      usage.waterRatio = '1:0.8';
    } else if (atomLevel > 40) {
      usage.waterRatio = '1:0.9';
    } else {
      usage.waterRatio = '1:1';
    }

    // é™ç½®æ—¶é—´ï¼šç²˜åº¦é«˜éœ€è¦æ›´é•¿æ—¶é—?
    const viscLevel = stateWeights.viscosity;
    if (viscLevel > 60) {
      usage.restTime = '10-15åˆ†é’Ÿ';
    } else if (viscLevel > 40) {
      usage.restTime = '5-10åˆ†é’Ÿ';
    } else {
      usage.restTime = '3-5åˆ†é’Ÿ';
    }

    // é¦–é’“å»ºè®®
    if (input.fishingMethod === 'rub') {
      usage.firstCast = 'æ“å¤§é¥µæ‰¾é±¼å±‚ï¼Œæœ‰å£åæ”¹å°é¥?;
    } else if (input.fishingMethod === 'pull') {
      usage.firstCast = 'æ‹‰å°é¥µå¿«é¢‘ç‡ï¼Œè¯±é’“ç»“å?;
    } else if (input.fishingMethod === 'scatter') {
      usage.firstCast = 'å…ˆæ‰“æ•£ç‚®è¯±é±¼ï¼Œå†æ“é¥µé’?;
    } else if (input.fishingMethod === 'wrap') {
      usage.firstCast = 'å¤–å±‚é›¾åŒ–è¯±é±¼ï¼Œå†…å±‚ç•™é±?;
    } else {
      usage.firstCast = 'æ“å¤§é¥µè¯•é±¼å±‚';
    }

    // æ‰“çªå»ºè®®
    if (input.waterType === 'river') {
      usage.nestSuggestion = 'é…’ç±³+é¢—ç²’ï¼Œå°‘é‡å¤šæ¬?;
    } else if (input.waterType === 'pond') {
      usage.nestSuggestion = 'æ•£ç‚®å¸¦çªï¼Œè¾¹é’“è¾¹è¯?;
    } else if (input.waterType === 'reservoir') {
      usage.nestSuggestion = 'å¤§çªå®ˆé’“ï¼Œç‰ç±?é¢—ç²’';
    } else {
      usage.nestSuggestion = 'é…’ç±³æ‰“åº•ï¼Œé€‚é‡è¡¥çª';
    }

    return usage;
  }

  /**
   * ç”Ÿæˆç†ç”±
   */
  generateReasons(input: GenerateRecipeInput, flavorWeights: FlavorWeights, stateWeights: StateWeights): GenerateReason[] {
    const reasons: GenerateReason[] = [];

    // æ¸©åº¦ç†ç”±
    const tempTemplate = getTempReasonTemplate(input.temperature);
    const tempReason = new GenerateReason();
    tempReason.condition = tempTemplate.condition;
    tempReason.decision = tempTemplate.decision;
    tempReason.icon = tempTemplate.icon;
    reasons.push(tempReason);

    // æ°´åŸŸç†ç”±
    const waterTemplate = getWaterReasonTemplate(input.waterType);
    const waterReason = new GenerateReason();
    waterReason.condition = waterTemplate.condition;
    waterReason.decision = waterTemplate.decision;
    waterReason.icon = waterTemplate.icon;
    reasons.push(waterReason);

    // é±¼ç§ç†ç”±
    const fishTemplate = getFishReasonTemplate(input.targetFishId);
    const fishReason = new GenerateReason();
    fishReason.condition = fishTemplate.condition;
    fishReason.decision = fishTemplate.decision;
    fishReason.icon = fishTemplate.icon;
    reasons.push(fishReason);

    // é±¼æƒ…ç†ç”±
    const densityTemplate = getDensityReasonTemplate(input.fishDensity);
    if (densityTemplate !== null) {
      const r = new GenerateReason();
      r.condition = densityTemplate.condition;
      r.decision = densityTemplate.decision;
      r.icon = densityTemplate.icon;
      reasons.push(r);
    }

    // å¼€å£ç†ç”?
    const activityTemplate = getActivityReasonTemplate(input.fishActivity);
    if (activityTemplate !== null) {
      const r = new GenerateReason();
      r.condition = activityTemplate.condition;
      r.decision = activityTemplate.decision;
      r.icon = activityTemplate.icon;
      reasons.push(r);
    }

    // æ¨¡å¼ç†ç”±
    const modeTemplate = getModeReasonTemplate(input.mode);
    if (modeTemplate !== null) {
      const r = new GenerateReason();
      r.condition = modeTemplate.condition;
      r.decision = modeTemplate.decision;
      r.icon = modeTemplate.icon;
      reasons.push(r);
    }

    return reasons;
  }


  // ============================================================
  // è¾…åŠ©æ–¹æ³•
  // ============================================================

  private getSeasonModifier(fishRule: FishRecipeRule, season: RecipeSeason): FlavorModifier {
    if (season === 'spring') return fishRule.seasonModifier.spring;
    if (season === 'summer') return fishRule.seasonModifier.summer;
    if (season === 'autumn') return fishRule.seasonModifier.autumn;
    return fishRule.seasonModifier.winter;
  }

  private getWaterModifier(fishRule: FishRecipeRule, waterType: RecipeWaterType): StateModifier {
    if (waterType === 'river') return fishRule.waterModifier.river;
    if (waterType === 'pond') return fishRule.waterModifier.pond;
    if (waterType === 'reservoir') return fishRule.waterModifier.reservoir;
    return fishRule.waterModifier.wild_pond;
  }

  private applyFlavorModifier(weights: FlavorWeights, mod: FlavorModifier): void {
    weights.fishy += mod.fishy;
    weights.fragrant += mod.fragrant;
    weights.sweet += mod.sweet;
    weights.sour += mod.sour;
    weights.stinky += mod.stinky;
  }

  private applyStateModifier(weights: StateWeights, mod: StateModifier): void {
    weights.atomization += mod.atomization;
    weights.viscosity += mod.viscosity;
    weights.intensity += mod.intensity;
  }

  private scaleFlavorWeights(weights: FlavorWeights, scale: number): void {
    weights.fishy = Math.round(weights.fishy * scale);
    weights.fragrant = Math.round(weights.fragrant * scale);
    weights.sweet = Math.round(weights.sweet * scale);
    weights.sour = Math.round(weights.sour * scale);
    weights.stinky = Math.round(weights.stinky * scale);
  }

  private clampFlavorWeights(weights: FlavorWeights): void {
    weights.fishy = Math.min(100, Math.max(0, weights.fishy));
    weights.fragrant = Math.min(100, Math.max(0, weights.fragrant));
    weights.sweet = Math.min(100, Math.max(0, weights.sweet));
    weights.sour = Math.min(100, Math.max(0, weights.sour));
    weights.stinky = Math.min(100, Math.max(0, weights.stinky));
  }

  private clampStateWeights(weights: StateWeights): void {
    weights.atomization = Math.min(100, Math.max(0, weights.atomization));
    weights.viscosity = Math.min(100, Math.max(0, weights.viscosity));
    weights.intensity = Math.min(100, Math.max(0, weights.intensity));
  }

  private selectByFlavor(ids: string[], weights: FlavorWeights, count: number): MatchedIngredient[] {
    const scored: MatchedIngredient[] = [];

    for (let i = 0; i < ids.length; i++) {
      const id: string = ids[i];
      const ing: Ingredient | null = getIngredientById(id);
      if (ing === null) continue;

      // è®¡ç®—å‘³å‹åŒ¹é…åˆ†æ•°
      const fp = ing.flavorProfile;
      let score: number = 0;
      score += Math.min(fp.fishy, weights.fishy);
      score += Math.min(fp.fragrant, weights.fragrant);
      score += Math.min(fp.sweet, weights.sweet);

      const item = new MatchedIngredient();
      item.id = id;
      item.name = ing.name;
      item.category = '';
      item.score = score;
      scored.push(item);
    }

    // æŒ‰åˆ†æ•°æ’åº?
    scored.sort((a: MatchedIngredient, b: MatchedIngredient): number => b.score - a.score);

    // è¿”å›å‰Nä¸?
    const result: MatchedIngredient[] = [];
    const maxCount: number = Math.min(count, scored.length);
    for (let i = 0; i < maxCount; i++) {
      result.push(scored[i]);
    }
    return result;
  }

  private selectByState(ids: string[], weights: StateWeights, method: FishingMethod, count: number): MatchedIngredient[] {
    const scored: MatchedIngredient[] = [];

    for (let i = 0; i < ids.length; i++) {
      const id: string = ids[i];
      const ing: Ingredient | null = getIngredientById(id);
      if (ing === null) continue;

      // è®¡ç®—çŠ¶æ€åŒ¹é…åˆ†æ•?
      const phys = ing.physical;
      let score: number = 0;

      // é›¾åŒ–åŒ¹é…
      if (weights.atomization > 60) {
        score += phys.atomization * 10;  // éœ€è¦å¿«é›¾åŒ–
      } else if (weights.atomization < 40) {
        score += (10 - phys.atomization) * 10;  // éœ€è¦æ…¢é›¾åŒ–
      }

      // æ‹‰é¥µéœ€è¦æ‹‰ä¸ç²‰
      if (method === 'pull' && id === 'drawing_powder') {
        score += 50;
      }

      // æ•£ç‚®éœ€è¦é›ªèŠ±ç²‰
      if (method === 'scatter' && id === 'snowflake_powder') {
        score += 50;
      }

      const item = new MatchedIngredient();
      item.id = id;
      item.name = ing.name;
      item.category = '';
      item.score = score;
      scored.push(item);
    }

    scored.sort((a: MatchedIngredient, b: MatchedIngredient): number => b.score - a.score);

    const result: MatchedIngredient[] = [];
    const maxCount: number = Math.min(count, scored.length);
    for (let i = 0; i < maxCount; i++) {
      result.push(scored[i]);
    }
    return result;
  }


  private getIngredientPurpose(category: string): string {
    if (category === 'main') return 'ä¸»é¥µï¼Œæä¾›åŸºç¡€å‘³å‹å’ŒçŠ¶æ€?;
    if (category === 'auxiliary') return 'è¾…é¥µï¼Œå¢å¼ºè¯±é±¼æ•ˆæ?;
    if (category === 'state') return 'çŠ¶æ€ç²‰ï¼Œè°ƒèŠ‚é›¾åŒ–å’Œç²˜åº¦';
    if (category === 'additive') return 'æ·»åŠ å‰‚ï¼Œæå‡å‘³å‹æµ“åº¦';
    return '';
  }

  private toStarRating(value: number): number {
    // 0-100 è½¬æ¢ä¸?1-5
    return Math.min(5, Math.max(1, Math.round(value / 20)));
  }

  private generateId(): string {
    return `recipe_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }

  /**
   * æ ¹æ®å½“å‰æ—¥æœŸè·å–å­£èŠ‚
   */
  getCurrentSeason(): RecipeSeason {
    const month = new Date().getMonth() + 1;
    if (month >= 3 && month <= 5) return 'spring';
    if (month >= 6 && month <= 8) return 'summer';
    if (month >= 9 && month <= 11) return 'autumn';
    return 'winter';
  }
}

// å¯¼å‡ºå•ä¾‹
export const recipeGeneratorService = new RecipeGeneratorServiceClass();

// å¯¼å‡ºä¾¿æ·å‡½æ•°
export function generateRecipe(input: GenerateRecipeInput): GeneratedRecipe {
  return recipeGeneratorService.generateRecipe(input);
}

export function getCurrentSeason(): RecipeSeason {
  return recipeGeneratorService.getCurrentSeason();
}
