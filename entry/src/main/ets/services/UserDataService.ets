/**
 * é¥µçŸ¥é?- ç”¨æˆ·è‡ªå®šä¹‰æ•°æ®æœåŠ?
 * ç®¡ç†ç”¨æˆ·è‡ªå®šä¹‰çš„åŸæ–™ã€é±¼ç§ã€é…æ–¹æ•°æ?
 */
import { storageService } from './StorageService';

// ç”¨æˆ·è‡ªå®šä¹‰åŸæ–?
export class CustomIngredient {
  id: string = '';
  name: string = '';
  category: string = '';
  description: string = '';
  targetFish: string[] = [];
  usage: string = '';
  createdAt: number = 0;
}

// ç”¨æˆ·è‡ªå®šä¹‰é±¼ç§?
export class CustomFish {
  id: string = '';
  name: string = '';
  nameEn: string = '';
  icon: string = '';  // é±¼ç§å›¾ç‰‡è·¯å¾„
  waterTypes: string[] = [];
  feedingType: string = '';
  waterLayer: string = '';
  activityTime: string = '';
  preferredTemp: string = '';
  favoriteFood: string[] = [];
  description: string = '';
  createdAt: number = 0;
}

// ç”¨æˆ·è‡ªå®šä¹‰é…æ–¹åŸæ–™é¡¹
export class CustomRecipeIngredient {
  ingredientId: string = '';
  name: string = '';
  ratio: number = 1;
  weight: number = 0;
  purpose: string = '';
  category: string = '';
}

// é…æ–¹çŠ¶æ€ç‰¹æ€?
export class RecipeStateProfile {
  atomization: number = 3;
  viscosity: number = 3;
  hookHolding: number = 3;
  weight: number = 3;
}

// é…æ–¹å‘³å‹ç‰¹æ€?
export class RecipeFlavorProfile {
  primary: string = '';
  secondary: string = '';
  intensity: number = 3;
  suitableTemp: string = '15-25Â°C';
}

// ç”¨æˆ·è‡ªå®šä¹‰é…æ–?
export class CustomRecipe {
  id: string = '';
  name: string = '';
  targetFish: string[] = [];
  waterType: string = '';
  season: string = '';
  ingredients: CustomRecipeIngredient[] = [];
  steps: string[] = [];
  tips: string = '';
  createdAt: number = 0;
  // éš¾åº¦ï¼šeasy, medium, hard
  difficulty: string = 'medium';
  // å‡†å¤‡æ—¶é—´
  prepTime: string = '15åˆ†é’Ÿ';
  // æ‰©å±•å­—æ®µï¼šçŠ¶æ€ç‰¹æ€?
  stateProfile: RecipeStateProfile = new RecipeStateProfile();
  // æ‰©å±•å­—æ®µï¼šå‘³å‹ç‰¹æ€?
  flavorProfile: RecipeFlavorProfile = new RecipeFlavorProfile();
  // æ‰©å±•å­—æ®µï¼šæ€»é‡é‡?
  totalWeight: number = 500;
}

// ç»Ÿè®¡ä¿¡æ¯æ¥å£
export class UserDataStats {
  ingredients: number = 0;
  fish: number = 0;
  recipes: number = 0;
}

// å­˜å‚¨é”?
const STORAGE_KEY_INGREDIENTS = 'user_custom_ingredients';
const STORAGE_KEY_FISH = 'user_custom_fish';
const STORAGE_KEY_RECIPES = 'user_custom_recipes';
const STORAGE_KEY_FAVORITES = 'user_favorite_recipes';
const STORAGE_KEY_PRECISE_PREFERENCES = 'user_precise_preferences';
const STORAGE_KEY_PRECISE_HISTORY = 'user_precise_history';
const STORAGE_KEY_FEEDBACK_HISTORY = 'user_feedback_history';

// ç²¾ç¡®åŒ¹é…ç”¨æˆ·åå¥½
export class PreciseMatchPreferences {
  waterDepth: string = 'medium';
  waterQuality: string = 'clear';
  lightCondition: string = 'bright';
  windCondition: string = 'none';
  baitState: string = 'fast_dissolve';
  flavorIntensity: string = 'medium';
  targetFishSize: string = 'medium';
  lastUpdated: number = 0;
}

// ç²¾ç¡®åŒ¹é…å†å²è®°å½•
export class PreciseMatchHistoryItem {
  id: string = '';
  recipeName: string = '';
  targetFish: string = '';
  matchScore: number = 0;
  createdAt: number = 0;
  inputParams: string = '';  // JSONå­—ç¬¦ä¸²å­˜å‚¨è¾“å…¥å‚æ•?
}

// ç”¨æˆ·åé¦ˆè®°å½•
export class FeedbackHistoryItem {
  id: string = '';
  recipeId: string = '';
  feedbackTypes: string[] = [];
  otherReason: string = '';
  createdAt: number = 0;
}

// åˆ›å»ºåŸæ–™çš„è¾…åŠ©å‡½æ•?
function createIngredient(
  name: string,
  category: string,
  description: string,
  targetFish: string[],
  usage: string
): CustomIngredient {
  const ing = new CustomIngredient();
  ing.id = `user_ing_${Date.now()}`;
  ing.name = name;
  ing.category = category;
  ing.description = description;
  ing.targetFish = targetFish;
  ing.usage = usage;
  ing.createdAt = Date.now();
  return ing;
}

// åˆ›å»ºé±¼ç§çš„è¾…åŠ©å‡½æ•?
function createFish(
  name: string,
  nameEn: string,
  icon: string,
  waterTypes: string[],
  feedingType: string,
  waterLayer: string,
  activityTime: string,
  preferredTemp: string,
  favoriteFood: string[],
  description: string
): CustomFish {
  const fish = new CustomFish();
  fish.id = `user_fish_${Date.now()}`;
  fish.name = name;
  fish.nameEn = nameEn;
  fish.icon = icon;
  fish.waterTypes = waterTypes;
  fish.feedingType = feedingType;
  fish.waterLayer = waterLayer;
  fish.activityTime = activityTime;
  fish.preferredTemp = preferredTemp;
  fish.favoriteFood = favoriteFood;
  fish.description = description;
  fish.createdAt = Date.now();
  return fish;
}

// åˆ›å»ºé…æ–¹çš„è¾…åŠ©å‡½æ•?
function createRecipe(
  name: string,
  targetFish: string[],
  waterType: string,
  season: string,
  ingredients: CustomRecipeIngredient[],
  steps: string[],
  tips: string,
  stateProfile: RecipeStateProfile | null,
  flavorProfile: RecipeFlavorProfile | null,
  totalWeight: number,
  difficulty: string,
  prepTime: string
): CustomRecipe {
  const recipe = new CustomRecipe();
  recipe.id = `user_recipe_${Date.now()}`;
  recipe.name = name;
  recipe.targetFish = targetFish;
  recipe.waterType = waterType;
  recipe.season = season;
  recipe.ingredients = ingredients;
  recipe.steps = steps;
  recipe.tips = tips;
  recipe.createdAt = Date.now();
  recipe.totalWeight = totalWeight;
  recipe.difficulty = difficulty;
  recipe.prepTime = prepTime;

  if (stateProfile !== null) {
    recipe.stateProfile = stateProfile;
  }
  if (flavorProfile !== null) {
    recipe.flavorProfile = flavorProfile;
  }

  return recipe;
}

class UserDataServiceClass {
  private static instance: UserDataServiceClass;
  private customIngredients: CustomIngredient[] = [];
  private customFish: CustomFish[] = [];
  private customRecipes: CustomRecipe[] = [];
  private favoriteRecipes: string[] = [];  // æ”¶è—çš„é…æ–¹IDåˆ—è¡¨
  private precisePreferences: PreciseMatchPreferences = new PreciseMatchPreferences();
  private preciseHistory: PreciseMatchHistoryItem[] = [];
  private feedbackHistory: FeedbackHistoryItem[] = [];
  private isLoaded: boolean = false;

  private constructor() {}

  static getInstance(): UserDataServiceClass {
    if (!UserDataServiceClass.instance) {
      UserDataServiceClass.instance = new UserDataServiceClass();
    }
    return UserDataServiceClass.instance;
  }

  // åŠ è½½æ‰€æœ‰ç”¨æˆ·æ•°æ?
  async load(forceReload: boolean = false): Promise<void> {
    if (this.isLoaded && !forceReload) return;

    this.customIngredients = await storageService.load<CustomIngredient[]>(
      STORAGE_KEY_INGREDIENTS, []
    );
    this.customFish = await storageService.load<CustomFish[]>(
      STORAGE_KEY_FISH, []
    );
    this.customRecipes = await storageService.load<CustomRecipe[]>(
      STORAGE_KEY_RECIPES, []
    );

    this.favoriteRecipes = await storageService.load<string[]>(
      STORAGE_KEY_FAVORITES, []
    );

    // åŠ è½½ç²¾ç¡®åŒ¹é…ç›¸å…³æ•°æ®
    this.precisePreferences = await storageService.load<PreciseMatchPreferences>(
      STORAGE_KEY_PRECISE_PREFERENCES, new PreciseMatchPreferences()
    );
    this.preciseHistory = await storageService.load<PreciseMatchHistoryItem[]>(
      STORAGE_KEY_PRECISE_HISTORY, []
    );
    this.feedbackHistory = await storageService.load<FeedbackHistoryItem[]>(
      STORAGE_KEY_FEEDBACK_HISTORY, []
    );

    this.isLoaded = true;
    console.info('[UserDataService] loaded, recipes count:', this.customRecipes.length);
  }

  // ==================== åŸæ–™ç®¡ç† ====================

  getCustomIngredients(): CustomIngredient[] {
    return this.customIngredients.slice();
  }

  async addIngredient(
    name: string,
    category: string,
    description: string,
    targetFish: string[],
    usage: string
  ): Promise<CustomIngredient> {
    const ingredient = createIngredient(name, category, description, targetFish, usage);
    this.customIngredients.push(ingredient);
    await this.saveIngredients();
    return ingredient;
  }

  async deleteIngredient(id: string): Promise<boolean> {
    const index = this.customIngredients.findIndex((i: CustomIngredient) => i.id === id);
    if (index === -1) return false;
    this.customIngredients.splice(index, 1);
    await this.saveIngredients();
    return true;
  }

  private async saveIngredients(): Promise<void> {
    await storageService.save(STORAGE_KEY_INGREDIENTS, this.customIngredients);
  }

  // ==================== é±¼ç§ç®¡ç† ====================

  getCustomFish(): CustomFish[] {
    return this.customFish.slice();
  }

  async addFish(
    name: string,
    nameEn: string,
    icon: string,
    waterTypes: string[],
    feedingType: string,
    waterLayer: string,
    activityTime: string,
    preferredTemp: string,
    favoriteFood: string[],
    description: string
  ): Promise<CustomFish> {
    const fish = createFish(name, nameEn, icon, waterTypes, feedingType, waterLayer, activityTime, preferredTemp, favoriteFood, description);
    this.customFish.push(fish);
    await this.saveFish();
    return fish;
  }

  async deleteFish(id: string): Promise<boolean> {
    const index = this.customFish.findIndex((f: CustomFish) => f.id === id);
    if (index === -1) return false;
    this.customFish.splice(index, 1);
    await this.saveFish();
    return true;
  }

  private async saveFish(): Promise<void> {
    await storageService.save(STORAGE_KEY_FISH, this.customFish);
  }

  // ==================== é…æ–¹ç®¡ç† ====================

  getCustomRecipes(): CustomRecipe[] {
    return this.customRecipes.slice();
  }

  async addRecipe(
    name: string,
    targetFish: string[],
    waterType: string,
    season: string,
    ingredients: CustomRecipeIngredient[],
    steps: string[],
    tips: string,
    stateProfile: RecipeStateProfile | null = null,
    flavorProfile: RecipeFlavorProfile | null = null,
    totalWeight: number = 500,
    difficulty: string = 'medium',
    prepTime: string = '15åˆ†é’Ÿ'
  ): Promise<CustomRecipe> {
    const recipe = createRecipe(name, targetFish, waterType, season, ingredients, steps, tips, stateProfile, flavorProfile, totalWeight, difficulty, prepTime);
    this.customRecipes.push(recipe);
    await this.saveRecipes();
    return recipe;
  }

  // æ£€æŸ¥é…æ–¹åç§°æ˜¯å¦å·²å­˜åœ¨
  isRecipeNameExists(name: string): boolean {
    for (let i = 0; i < this.customRecipes.length; i++) {
      if (this.customRecipes[i].name === name) {
        return true;
      }
    }
    return false;
  }

  async deleteRecipe(id: string): Promise<boolean> {
    const index = this.customRecipes.findIndex((r: CustomRecipe) => r.id === id);
    if (index === -1) return false;
    this.customRecipes.splice(index, 1);
    await this.saveRecipes();
    return true;
  }

  private async saveRecipes(): Promise<void> {
    await storageService.save(STORAGE_KEY_RECIPES, this.customRecipes);
  }

  // ==================== æ”¶è—ç®¡ç† ====================

  // è·å–æ‰€æœ‰æ”¶è—çš„é…æ–¹ID
  getFavoriteRecipes(): string[] {
    return this.favoriteRecipes.slice();
  }

  // æ£€æŸ¥é…æ–¹æ˜¯å¦å·²æ”¶è—
  isFavorite(recipeId: string): boolean {
    return this.favoriteRecipes.includes(recipeId);
  }

  // æ·»åŠ æ”¶è—
  async addFavorite(recipeId: string): Promise<boolean> {
    if (this.favoriteRecipes.includes(recipeId)) {
      return false;  // å·²ç»æ”¶è—è¿‡äº†
    }
    this.favoriteRecipes.push(recipeId);
    await this.saveFavorites();
    console.info('[UserDataService] Added favorite:', recipeId);
    return true;
  }

  // å–æ¶ˆæ”¶è—
  async removeFavorite(recipeId: string): Promise<boolean> {
    const index = this.favoriteRecipes.indexOf(recipeId);
    if (index === -1) {
      return false;  // æ²¡æœ‰æ”¶è—è¿?
    }
    this.favoriteRecipes.splice(index, 1);
    await this.saveFavorites();
    console.info('[UserDataService] Removed favorite:', recipeId);
    return true;
  }

  // åˆ‡æ¢æ”¶è—çŠ¶æ€?
  async toggleFavorite(recipeId: string): Promise<boolean> {
    if (this.isFavorite(recipeId)) {
      await this.removeFavorite(recipeId);
      return false;  // è¿”å›æ–°çš„æ”¶è—çŠ¶æ€?
    } else {
      await this.addFavorite(recipeId);
      return true;  // è¿”å›æ–°çš„æ”¶è—çŠ¶æ€?
    }
  }

  private async saveFavorites(): Promise<void> {
    await storageService.save(STORAGE_KEY_FAVORITES, this.favoriteRecipes);
  }

  // ==================== ç»Ÿè®¡ä¿¡æ¯ ====================

  getStats(): UserDataStats {
    const stats = new UserDataStats();
    stats.ingredients = this.customIngredients.length;
    stats.fish = this.customFish.length;
    stats.recipes = this.customRecipes.length;
    return stats;
  }

  // ==================== ç²¾ç¡®åŒ¹é…åå¥½ç®¡ç† ====================

  // è·å–ç²¾ç¡®åŒ¹é…åå¥½
  getPrecisePreferences(): PreciseMatchPreferences {
    return this.precisePreferences;
  }

  // ä¿å­˜ç²¾ç¡®åŒ¹é…åå¥½
  async savePrecisePreferences(prefs: PreciseMatchPreferences): Promise<void> {
    prefs.lastUpdated = Date.now();
    this.precisePreferences = prefs;
    await storageService.save(STORAGE_KEY_PRECISE_PREFERENCES, this.precisePreferences);
    console.info('[UserDataService] Saved precise preferences');
  }

  // æ›´æ–°å•ä¸ªåå¥½é¡?
  async updatePrecisePreference(key: string, value: string): Promise<void> {
    // æ ¹æ®keyæ›´æ–°å¯¹åº”çš„åå¥½é¡¹
    switch (key) {
      case 'waterDepth':
        this.precisePreferences.waterDepth = value;
        break;
      case 'waterQuality':
        this.precisePreferences.waterQuality = value;
        break;
      case 'lightCondition':
        this.precisePreferences.lightCondition = value;
        break;
      case 'windCondition':
        this.precisePreferences.windCondition = value;
        break;
      case 'baitState':
        this.precisePreferences.baitState = value;
        break;
      case 'flavorIntensity':
        this.precisePreferences.flavorIntensity = value;
        break;
      case 'targetFishSize':
        this.precisePreferences.targetFishSize = value;
        break;
    }
    this.precisePreferences.lastUpdated = Date.now();
    await storageService.save(STORAGE_KEY_PRECISE_PREFERENCES, this.precisePreferences);
  }

  // ==================== ç²¾ç¡®åŒ¹é…å†å²ç®¡ç† ====================

  // è·å–ç²¾ç¡®åŒ¹é…å†å²
  getPreciseHistory(): PreciseMatchHistoryItem[] {
    return this.preciseHistory.slice().sort((a: PreciseMatchHistoryItem, b: PreciseMatchHistoryItem) =>
      b.createdAt - a.createdAt
    );
  }

  // æ·»åŠ ç²¾ç¡®åŒ¹é…å†å²è®°å½•
  async addPreciseHistory(
    recipeName: string,
    targetFish: string,
    matchScore: number,
    inputParams: string
  ): Promise<PreciseMatchHistoryItem> {
    const item = new PreciseMatchHistoryItem();
    item.id = `precise_${Date.now()}`;
    item.recipeName = recipeName;
    item.targetFish = targetFish;
    item.matchScore = matchScore;
    item.inputParams = inputParams;
    item.createdAt = Date.now();

    this.preciseHistory.unshift(item);

    // åªä¿ç•™æœ€è¿?0æ¡è®°å½?
    if (this.preciseHistory.length > 50) {
      this.preciseHistory = this.preciseHistory.slice(0, 50);
    }

    await storageService.save(STORAGE_KEY_PRECISE_HISTORY, this.preciseHistory);
    console.info('[UserDataService] Added precise history:', recipeName);
    return item;
  }

  // æ¸…ç©ºç²¾ç¡®åŒ¹é…å†å²
  async clearPreciseHistory(): Promise<void> {
    this.preciseHistory = [];
    await storageService.save(STORAGE_KEY_PRECISE_HISTORY, this.preciseHistory);
  }

  // ==================== åé¦ˆå†å²ç®¡ç† ====================

  // è·å–åé¦ˆå†å²
  getFeedbackHistory(): FeedbackHistoryItem[] {
    return this.feedbackHistory.slice();
  }

  // æ·»åŠ åé¦ˆè®°å½•
  async addFeedback(
    recipeId: string,
    feedbackTypes: string[],
    otherReason: string = ''
  ): Promise<FeedbackHistoryItem> {
    const item = new FeedbackHistoryItem();
    item.id = `feedback_${Date.now()}`;
    item.recipeId = recipeId;
    item.feedbackTypes = feedbackTypes;
    item.otherReason = otherReason;
    item.createdAt = Date.now();

    this.feedbackHistory.unshift(item);

    // åªä¿ç•™æœ€è¿?00æ¡åé¦?
    if (this.feedbackHistory.length > 100) {
      this.feedbackHistory = this.feedbackHistory.slice(0, 100);
    }

    await storageService.save(STORAGE_KEY_FEEDBACK_HISTORY, this.feedbackHistory);
    console.info('[UserDataService] Added feedback for recipe:', recipeId);
    return item;
  }

  // è·å–æŸä¸ªé…æ–¹çš„åé¦ˆç»Ÿè®?
  getFeedbackStats(recipeId: string): Record<string, number> {
    const stats: Record<string, number> = {};
    for (const item of this.feedbackHistory) {
      if (item.recipeId === recipeId) {
        for (const type of item.feedbackTypes) {
          stats[type] = (stats[type] || 0) + 1;
        }
      }
    }
    return stats;
  }

  // ==================== é‡ç½®æ‰€æœ‰æ•°æ?====================

  // æ¸…é™¤æ‰€æœ‰ç”¨æˆ·æ•°æ?
  async clearAllData(): Promise<void> {
    // æ¸…ç©ºå†…å­˜æ•°æ®
    this.customIngredients = [];
    this.customFish = [];
    this.customRecipes = [];
    this.favoriteRecipes = [];
    this.precisePreferences = new PreciseMatchPreferences();
    this.preciseHistory = [];
    this.feedbackHistory = [];
    this.isLoaded = false;  // é‡ç½®åŠ è½½æ ‡å¿—

    // æ¸…ç©ºå­˜å‚¨
    await storageService.remove(STORAGE_KEY_INGREDIENTS);
    await storageService.remove(STORAGE_KEY_FISH);
    await storageService.remove(STORAGE_KEY_RECIPES);
    await storageService.remove(STORAGE_KEY_FAVORITES);
    await storageService.remove(STORAGE_KEY_PRECISE_PREFERENCES);
    await storageService.remove(STORAGE_KEY_PRECISE_HISTORY);
    await storageService.remove(STORAGE_KEY_FEEDBACK_HISTORY);

    console.info('[UserDataService] All user data cleared');
  }
}

export const userDataService = UserDataServiceClass.getInstance();
