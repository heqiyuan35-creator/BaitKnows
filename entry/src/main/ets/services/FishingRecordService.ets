/**
 * é¥µçŸ¥é?- æ¸”è·è®°å½•æœåŠ¡
 * ç®¡ç†æ¸”è·è®°å½•çš„å¢åˆ æ”¹æŸ?
 */
import { FishingRecord } from '../common/types/UserTypes';
import { storageService } from './StorageService';
import { userService } from './UserService';
import { AppConstants } from '../common/constants/AppConstants';

class FishingRecordServiceClass {
  private _records: FishingRecord[] = [];
  private _isLoaded: boolean = false;

  get records(): FishingRecord[] {
    return this._records;
  }

  get isLoaded(): boolean {
    return this._isLoaded;
  }

  /**
   * åŠ è½½æ‰€æœ‰è®°å½?
   */
  async load(): Promise<FishingRecord[]> {
    if (this._isLoaded) {
      return this._records;
    }

    const saved = await storageService.load<FishingRecord[]>(
      AppConstants.STORAGE_RECORDS,
      []
    );

    this._records = saved || [];
    // æŒ‰æ—¥æœŸå€’åºæ’åˆ—
    this._records.sort((a, b) => b.date - a.date);
    this._isLoaded = true;

    return this._records;
  }

  /**
   * ä¿å­˜æ‰€æœ‰è®°å½?
   */
  private async save(): Promise<void> {
    await storageService.save(AppConstants.STORAGE_RECORDS, this._records);
  }

  /**
   * æ·»åŠ è®°å½•
   */
  async addRecord(record: FishingRecord): Promise<FishingRecord> {
    // ç¡®ä¿æœ‰ID
    if (!record.id) {
      record.id = `record_${Date.now()}_${Math.random().toString(36).substring(2, 6)}`;
    }
    record.createTime = Date.now();
    record.updateTime = Date.now();

    // è®¡ç®—æœ€å¤§å•å°¾ï¼ˆå¦‚æœæœªè®¾ç½®ï¼Œé»˜è®¤ä¸ºæ€»é‡é‡?æ•°é‡ï¼?
    if (record.maxSingle <= 0 && record.count > 0) {
      record.maxSingle = Math.round((record.weight / record.count) * 100) / 100;
    }

    this._records.unshift(record);
    await this.save();

    // æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
    await userService.onRecordAdded(record);

    return record;
  }

  /**
   * æ›´æ–°è®°å½•
   */
  async updateRecord(record: FishingRecord): Promise<boolean> {
    const index = this._records.findIndex(r => r.id === record.id);
    if (index < 0) {
      return false;
    }

    const oldRecord = this._records[index];
    record.updateTime = Date.now();
    this._records[index] = record;

    // é‡æ–°æ’åº
    this._records.sort((a, b) => b.date - a.date);
    await this.save();

    // é‡æ–°è®¡ç®—ç”¨æˆ·ç»Ÿè®¡
    await userService.recalculateFromRecords(this._records);

    return true;
  }

  /**
   * åˆ é™¤è®°å½•
   */
  async deleteRecord(recordId: string): Promise<boolean> {
    const index = this._records.findIndex(r => r.id === recordId);
    if (index < 0) {
      return false;
    }

    const deletedRecord = this._records[index];
    this._records.splice(index, 1);
    await this.save();

    // æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
    await userService.onRecordDeleted(deletedRecord);

    return true;
  }

  /**
   * æ ¹æ®IDè·å–è®°å½•
   */
  getRecordById(recordId: string): FishingRecord | null {
    const record = this._records.find(r => r.id === recordId);
    return record || null;
  }

  /**
   * è·å–ç»Ÿè®¡æ•°æ®
   */
  getStatistics(): RecordStatistics {
    const stats = new RecordStatistics();

    if (this._records.length === 0) {
      return stats;
    }

    let totalWeight = 0;
    let totalCount = 0;
    let maxSingle = 0;
    let monthTrips = 0;

    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();

    for (const record of this._records) {
      totalWeight += record.weight;
      totalCount += record.count;

      if (record.maxSingle > maxSingle) {
        maxSingle = record.maxSingle;
      }

      // ç»Ÿè®¡æœ¬æœˆå‡ºé’“æ¬¡æ•°
      const recordDate = new Date(record.date);
      if (recordDate.getMonth() === currentMonth && recordDate.getFullYear() === currentYear) {
        monthTrips++;
      }
    }

    stats.totalWeight = Math.round(totalWeight * 10) / 10;
    stats.totalCount = totalCount;
    stats.maxSingle = Math.round(maxSingle * 10) / 10;
    stats.monthTrips = monthTrips;
    stats.totalTrips = this._records.length;

    return stats;
  }

  /**
   * è·å–æœ€è¿‘Næ¡è®°å½?
   */
  getRecentRecords(limit: number = 10): FishingRecord[] {
    return this._records.slice(0, limit);
  }

  /**
   * æŒ‰é±¼ç§ç­›é€?
   */
  filterByFish(fishName: string): FishingRecord[] {
    if (!fishName) {
      return this._records;
    }
    return this._records.filter(r => r.fishName === fishName);
  }

  /**
   * æŒ‰æ—¥æœŸèŒƒå›´ç­›é€?
   */
  filterByDateRange(startDate: number, endDate: number): FishingRecord[] {
    return this._records.filter(r => r.date >= startDate && r.date <= endDate);
  }

  /**
   * æŒ‰é’“ç‚¹æœç´?
   */
  searchByLocation(keyword: string): FishingRecord[] {
    if (!keyword || !keyword.trim()) {
      return this._records;
    }
    const lowerKeyword = keyword.toLowerCase().trim();
    return this._records.filter(r =>
      r.location && r.location.toLowerCase().includes(lowerKeyword)
    );
  }

  /**
   * è·å–æ‰€æœ‰é’“ç‚¹åˆ—è¡¨ï¼ˆå»é‡ï¼?
   */
  getAllLocations(): string[] {
    const locations = new Set<string>();
    for (const record of this._records) {
      if (record.location && record.location.trim()) {
        locations.add(record.location.trim());
      }
    }
    return Array.from(locations).sort();
  }

  /**
   * è·å–æ‰€æœ‰é±¼ç§åˆ—è¡¨ï¼ˆå»é‡ï¼?
   */
  getAllFishNames(): string[] {
    const fishNames = new Set<string>();
    for (const record of this._records) {
      if (record.fishName && record.fishName.trim()) {
        fishNames.add(record.fishName.trim());
      }
    }
    return Array.from(fishNames).sort();
  }

  /**
   * ç»„åˆç­›é€‰ï¼ˆé±¼ç§ + æ—¥æœŸèŒƒå›´ + é’“ç‚¹ï¼?
   */
  filterRecords(fishName?: string, startDate?: number, endDate?: number, location?: string): FishingRecord[] {
    let result = this._records;

    if (fishName && fishName.trim()) {
      result = result.filter(r => r.fishName === fishName);
    }

    if (startDate && startDate > 0) {
      result = result.filter(r => r.date >= startDate);
    }

    if (endDate && endDate > 0) {
      result = result.filter(r => r.date <= endDate);
    }

    if (location && location.trim()) {
      const lowerLocation = location.toLowerCase().trim();
      result = result.filter(r =>
        r.location && r.location.toLowerCase().includes(lowerLocation)
      );
    }

    return result;
  }

  /**
   * å¼ºåˆ¶é‡æ–°åŠ è½½æ•°æ®
   */
  async reload(): Promise<FishingRecord[]> {
    this._isLoaded = false;
    return this.load();
  }

  /**
   * æ¸…é™¤æ‰€æœ‰è®°å½?
   */
  async clearAllRecords(): Promise<void> {
    this._records = [];
    this._isLoaded = false;  // é‡ç½®åŠ è½½æ ‡å¿—
    await this.save();
    console.info('[FishingRecordService] All records cleared');
  }
}

// ç»Ÿè®¡æ•°æ®ç±?
export class RecordStatistics {
  totalWeight: number = 0;
  totalCount: number = 0;
  maxSingle: number = 0;
  monthTrips: number = 0;
  totalTrips: number = 0;

  constructor() {}
}

export const fishingRecordService = new FishingRecordServiceClass();
