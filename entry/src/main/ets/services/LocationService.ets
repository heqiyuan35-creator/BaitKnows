/**
 * å…¨å±€å®šä½æœåŠ¡ - å•ä¾‹æ¨¡å¼
 * åœ?App å¯åŠ¨æ—¶è·å–ä½ç½®ï¼Œä¾›å„é¡µé¢ä½¿ç”¨
 */
import { geoLocationManager } from '@kit.LocationKit';
import { abilityAccessCtrl, bundleManager, common, Permissions } from '@kit.AbilityKit';

export interface LocationInfo {
  latitude: number;
  longitude: number;
  accuracy?: number;
  isValid: boolean;
  errorMsg?: string;
}

class LocationServiceClass {
  private TAG = 'LocationService';
  private static instance: LocationServiceClass;
  private _currentLocation: LocationInfo = {
    latitude: 30.5844,  // é»˜è®¤æ­¦æ±‰
    longitude: 114.2986,
    isValid: false
  };
  private _hasPermission: boolean = false;
  private _isLocating: boolean = false;
  private _context: common.UIAbilityContext | null = null;

  private constructor() {}

  static getInstance(): LocationServiceClass {
    if (!LocationServiceClass.instance) {
      LocationServiceClass.instance = new LocationServiceClass();
    }
    return LocationServiceClass.instance;
  }

  get currentLocation(): LocationInfo {
    return this._currentLocation;
  }

  get hasPermission(): boolean {
    return this._hasPermission;
  }

  get isLocating(): boolean {
    return this._isLocating;
  }

  // åˆå§‹åŒ–å®šä½ï¼ˆåœ?EntryAbility ä¸­è°ƒç”¨ï¼‰
  async init(context: common.UIAbilityContext): Promise<void> {
    console.info(this.TAG, 'Initializing location service...');
    this._context = context;
    
    // å…ˆæ£€æŸ¥å®šä½æœåŠ¡æ˜¯å¦å¼€å?
    const isEnabled = await this.checkLocationEnabled();
    if (!isEnabled) {
      console.warn(this.TAG, 'Location service is disabled');
      this._currentLocation.errorMsg = 'å®šä½æœåŠ¡æœªå¼€å?;
      // ä½¿ç”¨é»˜è®¤ä½ç½®ï¼Œä½†æ ‡è®°ä¸ºæœ‰æ•ˆä»¥ä¾¿åœ°å›¾èƒ½æ˜¾ç¤º
      this._currentLocation.isValid = true;
      return;
    }
    
    await this.checkAndRequestPermission(context);
  }

  // æ£€æŸ¥å®šä½æœåŠ¡æ˜¯å¦å¼€å?
  private async checkLocationEnabled(): Promise<boolean> {
    try {
      return geoLocationManager.isLocationEnabled();
    } catch (error) {
      console.error(this.TAG, `Check location enabled failed: ${error}`);
      return false;
    }
  }

  // æ£€æŸ¥å¹¶è¯·æ±‚æƒé™
  private async checkAndRequestPermission(context: common.UIAbilityContext): Promise<void> {
    try {
      const permission: Permissions = 'ohos.permission.LOCATION';
      const atManager = abilityAccessCtrl.createAtManager();
      const bundleInfo = await bundleManager.getBundleInfoForSelf(
        bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION
      );
      const tokenId = bundleInfo.appInfo.accessTokenId;
      const grantStatus = await atManager.checkAccessToken(tokenId, permission);

      console.info(this.TAG, `Permission status: ${grantStatus}`);

      if (grantStatus === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
        this._hasPermission = true;
        await this.fetchCurrentLocation();
      } else {
        await this.requestPermissions(context);
      }
    } catch (error) {
      console.error(this.TAG, `Permission check failed: ${error}`);
      // æƒé™æ£€æŸ¥å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®
      this._currentLocation.isValid = true;
      this._currentLocation.errorMsg = 'æƒé™æ£€æŸ¥å¤±è´?;
    }
  }

  // è¯·æ±‚æƒé™
  private async requestPermissions(context: common.UIAbilityContext): Promise<void> {
    const permissions: Permissions[] = [
      'ohos.permission.APPROXIMATELY_LOCATION',
      'ohos.permission.LOCATION'
    ];

    try {
      const atManager = abilityAccessCtrl.createAtManager();
      const result = await atManager.requestPermissionsFromUser(context, permissions);
      
      console.info(this.TAG, `Permission request result: ${JSON.stringify(result.authResults)}`);
      
      const allGranted = result.authResults.every(status => status === 0);

      if (allGranted) {
        this._hasPermission = true;
        await this.fetchCurrentLocation();
      } else {
        this._hasPermission = false;
        console.warn(this.TAG, 'Location permission denied');
        // æƒé™è¢«æ‹’ç»ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®
        this._currentLocation.isValid = true;
        this._currentLocation.errorMsg = 'å®šä½æƒé™è¢«æ‹’ç»?;
      }
    } catch (error) {
      console.error(this.TAG, `Request permission failed: ${error}`);
      // è¯·æ±‚æƒé™å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä½ç½?
      this._currentLocation.isValid = true;
      this._currentLocation.errorMsg = 'è¯·æ±‚æƒé™å¤±è´¥';
    }
  }

  // è·å–å½“å‰ä½ç½®
  async fetchCurrentLocation(): Promise<LocationInfo> {
    if (this._isLocating) {
      return this._currentLocation;
    }

    this._isLocating = true;
    console.info(this.TAG, 'Fetching current location...');

    try {
      // å…ˆæ£€æŸ¥å®šä½æœåŠ?
      const isEnabled = geoLocationManager.isLocationEnabled();
      if (!isEnabled) {
        console.warn(this.TAG, 'Location service is disabled');
        this._currentLocation.isValid = true;  // ä½¿ç”¨é»˜è®¤ä½ç½®
        this._currentLocation.errorMsg = 'å®šä½æœåŠ¡æœªå¼€å?;
        return this._currentLocation;
      }

      const request: geoLocationManager.CurrentLocationRequest = {
        priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        maxAccuracy: 100,
        timeoutMs: 10000  // 10ç§’è¶…æ—?
      };

      console.info(this.TAG, 'Calling getCurrentLocation...');
      const location = await geoLocationManager.getCurrentLocation(request);
      
      this._currentLocation = {
        latitude: location.latitude,
        longitude: location.longitude,
        accuracy: location.accuracy,
        isValid: true
      };
      console.info(this.TAG, `Location updated: ${location.latitude}, ${location.longitude}`);
    } catch (error) {
      const err = error as Error;
      console.error(this.TAG, `Get location failed: ${err.message || error}`);
      
      // å®šä½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®ä½†æ ‡è®°ä¸ºæœ‰æ•?
      this._currentLocation.isValid = true;
      this._currentLocation.errorMsg = `å®šä½å¤±è´¥: ${err.message || 'æœªçŸ¥é”™è¯¯'}`;
    } finally {
      this._isLocating = false;
    }

    return this._currentLocation;
  }

  // æ‰‹åŠ¨åˆ·æ–°ä½ç½®ï¼ˆä¾›é¡µé¢è°ƒç”¨ï¼?
  async refreshLocation(): Promise<LocationInfo> {
    // å¦‚æœæ²¡æœ‰æƒé™ï¼Œå°è¯•é‡æ–°è¯·æ±?
    if (!this._hasPermission && this._context) {
      await this.requestPermissions(this._context);
    }
    
    return this.fetchCurrentLocation();
  }
}

export const LocationService = LocationServiceClass.getInstance();
